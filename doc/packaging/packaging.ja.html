<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Fink Documentation - Fink パッケージの作成</title></head><body>
<table width="100%" cellspacing="0">
<tr valign="bottom">
<td align="center">
Available Languages:  | 
<a href="packaging.en.html">English</a> | 
<a href="packaging.fr.html">Fran&ccedil;ais</a> | 
&#26085;&#26412;&#35486; (Nihongo) | 
<a href="packaging.zh.html">&#20013;&#25991; (&#31616;) (Simplified Chinese)</a> | 
</td>
</tr>
</table>
<h1 style="text-align: center;">Fink パッケージの作成</h1>
		<p>
			このマニュアルではパッケージ管理システム Fink 用のパッケージ情報の記述方法を解説します．
			また Fink ディストリビューションのポリシーとガイドラインも解説します．
			パッケージ情報の書式もディストリビューションのポリシーも共に発展途上なので，
			"Last changed" (最終更新) 情報とこのページの CVS タグに注意して，更新に気付いて下さい．
			ここで扱うのはパッケージ管理システム Fink の「0.9.0 開発版」以降で使われる書式とポリシーの説明です．
		</p>
		<p>
			Fink 用にパッケージを作成した場合，メーリングリスト
			<a href="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</a> を購読するとよいでしょう．
			Fink に貢献する方法をお探しで，この分野のスキルをお持ちなら，
			<a href="http://fink.sourceforge.net/pdb/nomaintainer.php">現在メインテナのいないパッケージ</a>
			を引き継ぐことをご考慮下さい．
		</p>
	<h2>Contents</h2><ul><li><a href="#intro"><b>1 始めに</b></a><ul><li><a href="#intro.def1">1.1 パッケージとは何か?</a></li><li><a href="#intro.ident">1.2 パッケージの区別</a></li></ul></li><li><a href="#format"><b>2 パッケージ記述情報</b></a><ul><li><a href="#format.trees">2.1 ツリーレイアウト</a></li><li><a href="#format.format">2.2 ファイル形式</a></li><li><a href="#format.percent">2.3 パーセント記法の展開</a></li></ul></li><li><a href="#policy"><b>3 パッケージ化ポリシー</b></a><ul><li><a href="#policy.licenses">3.1 パッケージのライセンス</a></li><li><a href="#policy.prefix">3.2 基盤システムへの干渉問題</a></li><li><a href="#policy.sharedlibs">3.3 共有ライブラリ (Shared Libraries)</a></li><li><a href="#policy.perlmods">3.4 Perl モジュール</a></li></ul></li><li><a href="#fslayout"><b>4 ファイルシステムのレイアウト</b></a><ul><li><a href="#fslayout.fhs">4.1 ファイルシステム構造標準 (Filesystem Hierarchy Standard)</a></li><li><a href="#fslayout.dirs">4.2 ディレクトリ</a></li><li><a href="#fslayout.avoid">4.3 避けるべきこと</a></li></ul></li><li><a href="#reference"><b>5 リファレンスマニュアル</b></a><ul><li><a href="#reference.build">5.1 ビルドプロセス</a></li><li><a href="#reference.fields">5.2 フィールド</a></li><li><a href="#reference.splitoffs">5.3 スプリットオフ (SplitOff)</a></li><li><a href="#reference.scripts">5.4 スクリプト</a></li><li><a href="#reference.patches">5.5 パッチ</a></li><li><a href="#reference.profile.d">5.6 Profile.d スクリプト</a></li></ul></li></ul><h2><a name="intro">1 始めに</a></h2>
		
		

		<h3><a name="intro.def1">1.1 パッケージとは何か?</a></h3>
			
			<p>
				パッケージとは，基本的単位を構成するソフトウェアのまとまりを指します．
				典型的なパッケージには，例えば実行可能プログラム，それが必要とするデータファイル，
				国際化のためのメッセージカタログ，そしてドキュメントが含まれます．
				Fink のパッケージには2種類の形式があります．
				すなわちパッケージ記述情報と，そのままインストール可能なバイナリパッケージファイルです．
			</p>
			<p>
				パッケージ記述情報は人でも読めるテキストファイルで，
				パッケージをビルドするために必要な (つまりバイナリパッケージファイルを作るのに必要な) 全ての情報を含みます．
				それにはメタデータ (パッケージ名や目的など) やソースコードの URL の他，
				configure やコンパイル，インストールに必要な命令が書かれています．
			</p>
			<p>
				バイナリパッケージファイルとは，パッケージを実際に構成する各ファイルのアーカイブを指します．
				これには実行可能プログラム，データファイル，メッセージカタログ，ライブラリ，インクルードファイルなどが入っています．
				また，そのパッケージに関するメタデータも含まれます．
				バイナリパッケージは既に使用できる形式ですので，インストールとは主に中身のファイルを展開することです．
				Finkはパッケージ管理システム dpkg の上に構築されたシステムなので，
				バイナリパッケージには dpkg の形式を使い，拡張子は .deb です．
			</p>
		

		<h3><a name="intro.ident">1.2 パッケージの区別</a></h3>
			
			<p>
				パッケージは3つの文字列で区別されます．
				すなわち「パッケージ名」，「バージョン」と「版」です．
				これらのいずれにも英小文字 (a から z)，数字 (0 から 9)， ダッシュ (-)，プラス (+)，ドット (.) のみが使えます．
				この他の字は使えません．
				特に，大文字とアンダースコアが使えないことに注意して下さい．
			</p>
			<p>
				「パッケージ名」には単にソフトウェアの名前 (openssh など) を使います．
				「バージョン」は「upstreamバージョン」とも呼ばれますが，これには元となるソフトウェアパッケージのバージョンを使います．
				「バージョン」には (2.9p1 のように) 数字以外を使っても構いません．
				Fink も dpkg もそれらを認識してソートできます．
				「版」は整数で， 1 で始まり，パッケージ記述情報に変更回数に応じて 1 ずつ増加します．
				「upstreamバージョン」が変化すると再び 1 に戻ります．
				「版」にダッシュを使ってはいけません．
				パッケージの正式名称は「パッケージ名」，「バージョン」と「版」をダッシュでつないだもので，
				openssh-2.9p1-2 などという形式になります．
			</p>
		

	<h2><a name="format">2 パッケージ記述情報</a></h2>
		
		

		<h3><a name="format.trees">2.1 ツリーレイアウト</a></h3>
			
			<p>
				パッケージ記述情報はディレクトリ <tt style="white-space: nowrap;">/sw/fink/dists</tt> の下のディレクトリ <tt style="white-space: nowrap;">finkinfo</tt> から読み込まれます．
				「ツリー」の設定はファイル <tt style="white-space: nowrap;">/sw/etc/fink.conf</tt> にあり，どのディレクトリを読むかを指定します．
				パッケージ記述情報ファイルの名前は，パッケージの正式名称に拡張子 ".info" を付けたものです．
				Fink 0.13.0 以降，手間を省くため，簡略形式の「パッケージ名」に拡張子 ".info" を付けたものも使えます．
			</p>
			<p>
				パッケージ記述情報ツリーはいくつかの階層のディレクトリにまとめられています．
				最上段にあるディレクトリは:
			</p>
			<ul>
				<li>
					<tt style="white-space: nowrap;">dists</tt> から始まる．
					<tt style="white-space: nowrap;">dists</tt> ディレクトリは Debian ツールで必須．
				</li>
				<li>
					ディストリビューション．
					<tt style="white-space: nowrap;">stable</tt>,<tt style="white-space: nowrap;">unstable</tt>, <tt style="white-space: nowrap;">local</tt> に分かれる．
					ディレクトリ <tt style="white-space: nowrap;">local</tt> は各システムの管理者とユーザが管理する．
					ディレクトリ <tt style="white-space: nowrap;">stable</tt> と <tt style="white-space: nowrap;">unstable</tt> は Fink システムの一部．
				</li>
				<li>
					ツリー．
					ツリー <tt style="white-space: nowrap;">main</tt> にはパッケージの大部分が含まれる．
					暗号を使うソフトウェアは別ツリー <tt style="white-space: nowrap;">crypto</tt> に収められ，必要に応じて簡単に取り除ける．
				</li>
				<li>
					<tt style="white-space: nowrap;">finkinfo</tt> または <tt style="white-space: nowrap;">binary-darwin-powerpc</tt>．
					<tt style="white-space: nowrap;">finkinfo</tt> は Fink のパッケージ情報記述ファイルとパッチを含み，
					<tt style="white-space: nowrap;">binary-darwin-powerpc</tt> は <tt style="white-space: nowrap;">.deb</tt> 形式のバイナリパッケージを含む．
				</li>
				<li>
					セクション．
					ツリー <tt style="white-space: nowrap;">main</tt> は，管理しやすくするために種類別に分類されている．
					ツリー <tt style="white-space: nowrap;">crypto</tt> は現在のところ分類されていない．
				</li>
			</ul>
		

		<h3><a name="format.format">2.2 ファイル形式</a></h3>
			
			<p>
				パッケージ情報記述ファイルはキーと値の組 (別名「フィールド」) の単純なリストです．
				各行はキーで始まり，コロン (:) 以降が値になります:
			</p>
<pre>Key: Value</pre>
			<p>
				複数行に渡るフィールドには 2 通りの記法があります．
			</p>
			<p>
				1 つ目はシェルスクリプトで言う "here-document" 風の形式で，こちらの方が望ましいです．
				この方式では，第1行はキー，コロンの次に，値として <tt style="white-space: nowrap;">&lt;&lt;</tt> が続くものになります．
				その後の行は全て実質的な値となり，行頭に <tt style="white-space: nowrap;">&lt;&lt;</tt> を置いた行が値の終端区切りです．
				例:
			</p>
<pre>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</pre>
			<p>
				この形式ではインデントを付けて構いません．
				その方が読みやすくなるでしょう．
			</p>
			<p>
				here-document 形式はネストできます．
				これはフィールド <tt style="white-space: nowrap;">SplitOff</tt> や <tt style="white-space: nowrap;">SplitOff<b>N</b></tt> でよく使われます．
				これらのフィールドは他の (複数行の) フィールドを含むことができ，
				here-document 形式を使えば部分フィールド (含まれる方のフィールド) にも複数行の値が使えます．
				内側でも同じ区切り <tt style="white-space: nowrap;">&lt;&lt;</tt> が使われます．
			</p>
<pre>
SplitOff: &lt;&lt;
Package: %N-shlibs
InstallScript: &lt;&lt;
ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
&lt;&lt;
&lt;&lt;
</pre>
			<p>
				推奨されない，旧式の記法は「RFC 822 ヘッダ折り畳み方法」を手本に作られました．
				空白で始まる行を前の行からの続きと認識します．
				例:
			</p>
<pre>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</pre>
			<p>
				各行の先頭の空白に気づきましたでしょうか．
			</p>
			<p>
				どちらの形式でも，空行と，シャープ (#) で始まる行は無視されます．
				キー (フィールド名) では大文字と小文字の区別がないので，
				<tt style="white-space: nowrap;">InstallScript</tt> を <tt style="white-space: nowrap;">installscript</tt> や <tt style="white-space: nowrap;">INSTALLSCRIPT</tt> とも書けますが，
				最初の <tt style="white-space: nowrap;">InstallScript</tt> という方式が一般的です．
				真偽値を取るフィールドでは "true", "yes", "on", "1" (大文字，小文字の区別なし)
				のいずれも「真」となり，それ以外は全て「偽」になります．
			</p>
		

		<h3><a name="format.percent">2.3 パーセント記法の展開</a></h3>
			
			<p>
				簡便のため， Fink はいくつかのフィールドで以下の文字列展開をサポートします．
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left"></th><th align="left"></th></tr><tr valign="top"><td>%n</td><td>
						<p>
							<b>n</b>ame．「パッケージ名」．
						</p>
					</td></tr><tr valign="top"><td>%N</td><td>
						<p>
							<b>N</b>ame．親パッケージの「パッケージ名」． (<tt style="white-space: nowrap;">SplitOff</tt> 内部以外では %n と同じ)
						</p>
					</td></tr><tr valign="top"><td>%e</td><td>
						<p>
							<b>e</b>poch．パッケージの「エポック」．
						</p>
					</td></tr><tr valign="top"><td>%v</td><td>
						<p>
							<b>v</b>ersion．「バージョン」．
						</p>
					</td></tr><tr valign="top"><td>%r</td><td>
						<p>
							<b>r</b>evision．パッケージの「版」．
						</p>
					</td></tr><tr valign="top"><td>%f</td><td>
						<p>
							<b>f</b>ull package name．%n-%v-%r と等価．
						</p>
					</td></tr><tr valign="top"><td>%p, %P</td><td>
						<p>
							<b>p</b>refix．Fink のインストール場所．例: <tt style="white-space: nowrap;">/sw</tt>．
						</p>
					</td></tr><tr valign="top"><td>%d</td><td>
						<p>
							<b>d</b>estination．パッケージ化するツリーのビルド先．
							例:<tt style="white-space: nowrap;">/sw/src/root-gimp-1.2.1-1</tt>
						</p>
					</td></tr><tr valign="top"><td>%D</td><td>
						<p>
							<b>D</b>estination．
							親パッケージのビルド先 (<tt style="white-space: nowrap;">SplitOff</tt> 内部以外では %d と同じ)．
						</p>
					</td></tr><tr valign="top"><td>%i</td><td>
						<p>
							<b>i</b>nstall-phase prefix．インストール過程での完全なプリフィックス． %d%p と等価．
						</p>
					</td></tr><tr valign="top"><td>%I</td><td>
						<p>
							<b>I</b>nstall prefix．
							親パッケージのインストール過程での完全プリフィクス．%D%Pと等価 (<tt style="white-space: nowrap;">SplitOff</tt> 内部以外では %i と同じ)．
						</p>
					</td></tr><tr valign="top"><td>%a</td><td>
						<p>
							p<b>a</b>tches ．
							パッチを検索するパス．
						</p>
					</td></tr><tr valign="top"><td>%b</td><td>
						<p>
							<b>b</b>uild．
							ビルドディレクトリ．例: <tt style="white-space: nowrap;">/sw/src/gimp-1.2.1-1/gimp-1.2.1</tt>
						</p>
						<p>
							注記: %b は使わざるを得ないときだけ使用して下さい．
							ビルドディレクトリはスクリプトが実行されるときのカレントディレクトリです．
							コマンドでは相対パス名を使って下さい．
						</p>
					</td></tr><tr valign="top"><td>%c</td><td>
						<p>
							The parameters for <b>c</b>onfigure．
							configure に渡すパラメータ: <tt style="white-space: nowrap;">--prefix=%p</tt> の他， ConfigureParams で指定したもの全て．
						</p>
					</td></tr><tr valign="top"><td>%m</td><td>
						<p>
							<b>m</b>achine architecture．
							マシンアーキテクチャーを示す記号で，<tt style="white-space: nowrap;">uname -p</tt> の出力．
							現在のところ， PPC マシンでは 'powerpc' ， x86 マシンでは 'i386' という値になる
							(0.12.1 以降の CVS版 fink で導入)．
						</p>
					</td></tr><tr valign="top"><td>%%</td><td>
						<p>
							パーセント記号そのもの (これ以降にどの文字が続いても展開されない)．
							展開は厳密に左から右に行われるので， %%n はパッケージ名とは一切関係なく，単なる文字列 %n を表します．
							(fink-0.18.0 で導入)
						</p>
					</td></tr></table>

		

	<h2><a name="policy">3 パッケージ化ポリシー</a></h2>
		
		

		<h3><a name="policy.licenses">3.1 パッケージのライセンス</a></h3>
			
			<p>
				Fink に含まれるパッケージのライセンスは多肢に渡ります．
				それらの大部分は，ソース全体の再配布と，特に実行可能ファイルの配布に制限を課します．
				パッケージの中には，ライセンスのためにバイナリ配布を行えないものもあります．
				そのため，パッケージのメインテナがライセンスを注意深くチェックすることが大変に重要です．
			</p>
			<p>
				バイナリ・パッケージとして配布される全てのパッケージは，ライセンスのコピーも含んでいなければいけません．
				ライセンスは doc ディレクトリすなわち <tt style="white-space: nowrap;">%p/share/doc/%n</tt> にインストールされます．
				(InstallScript では，当然ながら %p でなく %i を使う必要があります．
				フィールド DocFiles に記述することで細々とした処理は自動的に処理されます．)
				元のソースに明示的なライセンスが存在しない場合，パッケージの状態を記した短いテキストを代わりとします．
				大半のライセンスは，ライセンスが配布物に必ず含まれるよう定めています．
				Finkのポリシーは「ライセンスを含めるよう明示的に要求されなくとも，常にライセンスを含める」ことです．
			</p>
			<p>
				バイナリディストリビューションのメインテナンスを自動化するため，
				配布されるどのパッケージにもフィールド <tt style="white-space: nowrap;">License</tt> がなければいけません．
				このフィールドはライセンスの性質に関するもので，
				当該パッケージをバイナリディストリビューションに含めるかどうかを決定する際に参照されます．
				このフィールドは実際のライセンス条項ファイルが上記のようにバイナリパッケージに含まれているときのみ存在できます．
			</p>
			<p>
				フィールド License を有効に使用するため，値は下記の中から選択して下さい．
				下記の選択肢に当てはまらないパッケージの場合，開発用メーリングリストへ質問を投げかけて下さい．
			</p>
			<ul>

				<li>
					<tt style="white-space: nowrap;">GPL</tt> - GNU General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<tt style="white-space: nowrap;">LGPL</tt> - GNU Lesser General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<tt style="white-space: nowrap;">GPL/LGPL</tt> -
					これはパッケージの一部 (実行可能ファイルなど) が GPL で，別の部分 (ライブラリなど) が LGPL などの特殊な場合．
				</li>
				<li>
					<tt style="white-space: nowrap;">BSD</tt>  -
					BSD形式のライセンス．
					これには，いわゆる「オリジナル」 BSD ライセンス，「修正」 BSD ライセンスおよび MIT ライセンスが含まれる．
					The Apache lisence もこの一種とみなす．
					これらのライセンスでは，ソースコードの配布は必須ではない．
				</li>
				<li>
					<tt style="white-space: nowrap;">Artistic</tt> -
					The Artistic lisence 及びその派生型．
				</li>
				<li>
					<tt style="white-space: nowrap;">Artistic/GPL</tt> -
					Artistic と GPL のデュアルライセンス．
				</li>
				<li>
					<tt style="white-space: nowrap;">GNU Free Documentation License</tt> および <tt style="white-space: nowrap;">Linux Documentation Project</tt> -
					付属ドキュメントが明示的にこのライセンスのどちらかを採用している場合，
					そのことは <tt style="white-space: nowrap;">/GFDL</tt> と <tt style="white-space: nowrap;">/LDP</tt> のいずれか，または両方を後置することで示す．
					結果として，以下の組合せが可能: "GFDL", "GPL/GFDL", "LGPL/GFDL", "GPL/LGPL/GFDL",
					"LDP", "GPL/LGPL/LDP".
				</li>
				<li>
					<tt style="white-space: nowrap;">OSI-Approved</tt> -
					<a href="http://www.opensource.org/">Open Source Initiative</a> が承認した，その他の Open Source ライセンス．
					OSIの要求には，バイナリとソースの自由な配布が許されることが含まれる．
					デュアルライセンスのパッケージにとりあえずこの選択肢を選ぶこともできます．
				</li>
				<li>
					<tt style="white-space: nowrap;">Restrictive</tt> -
					制限付きのライセンス．
					作者からソース形式で free use のために入手できるが，自由な再配布は許可されないパッケージに使う．
				</li>
				<li>
					<tt style="white-space: nowrap;">Restrictive/Distributable</tt> -
					ソースとバイナリの配布を許可するが制限のあるライセンス．
					当該パッケージが作者からソース形式で入手でき，ソースとバイナリの配布も許可されているが，
					Open Source ライセンスと認められない制限がある場合に使用する．
				</li>
				<li>
					<tt style="white-space: nowrap;">Commercial</tt> -
					制限付きの商用ライセンス．
					ソースやバイナリの自由な再配布を許可しない商用パッケージ (例えばフリーウェアやシェアウェア) に使う．
				</li>
				<li>
					<tt style="white-space: nowrap;">Public Domain</tt> -
					パブリックドメインにあるパッケージ．
					パブリックドメインとは，作者がコードに対するコピーライトを放棄したことを指す．
					この場合，パッケージにはライセンスが存在せず，だれが何をしても良い．
				</li>
			</ul>
		

		<h3><a name="policy.prefix">3.2 基盤システムへの干渉問題</a></h3>
			
			<p>
				Finkは基盤システムから分離したディレクトリにインストールされるアドオン・ディストリビューションです．
				パッケージは Fink のディレクトリ外にはファイルをインストールしてはしてはいけません．
			</p>
			<p>
				この決まりを破る他に可能性がないときには例外 (XFree86 など) が設けられます．
				この場合，パッケージはインストール前に既存のファイルを調べ，上書きの恐れがある場合はインストールを中止する必要があります．
				そのようなパッケージは，そのパッケージが削除されるときに Fink ディレクトリ外にインストールしたファイルを全て削除するか，
				あるいは残しても問題がないかを十分確認する必要があります
				(例えば，実行前に実行可能ファイルが存在するかなどのチェックなどを行う必要があります)．
			</p>
		

		<h3><a name="policy.sharedlibs">3.3 共有ライブラリ (Shared Libraries)</a></h3>
			
			<p>
				Fink は共有ライブラリに関して新しいポリシーを定め， 2002 年 2 月から施行しています．
				本節では Fink 0.5.0 と共に公布された，共有ライブラリについてのポリシー第4版について説明します．
				最初に要点をかいつまんで述べ，後から詳細に移ります．
			</p>
			<p>
				共有ライブラリをビルドするパッケージで，
				(1) ツリー stable に入っているか，または (2) 新規のパッケージである場合，
				Fink ポリシーに従って共有ライブラリを扱う必要があります．
				すなわち以下の約束に従うことになります．
			</p>
			<ul>
				<li>
					コマンド <tt style="white-space: nowrap;">otool -L</tt> を使い，各ライブラリの install_name ，互換性，現在のバージョン番号が適切か確認する．
				</li>
				<li>
					共有ライブラリを別パッケージとし (例外は libfoo.dylib から install_name へのリンク) ，
					さらに，そうしてできた別パッケージにフィールド <tt style="white-space: nowrap;">Shlibs</tt> を設ける．
				</li>
				<li>
					ヘッダと libfoo.dylib からの最終的リンクを <tt style="white-space: nowrap;">BuildDependsOnly: True</tt> となっているパッケージに入れ，
					他のパッケージが一切そのパッケージに依存しないようにする．
				</li>
			</ul>
			<p>
				このポリシーに反し，パッケージを分割しない場合には，フィールド <tt style="white-space: nowrap;">DescPackaging</tt> に理由を記述する．
			</p>
			<p>
				パッケージによっては，主パッケージと -shlib パッケージを作成するだけで済みます．
				しかしさらに別のパッケージが必要な場合もあります．
				新設されたフィールド <tt style="white-space: nowrap;">SplitOff</tt> はこの作業の手間を省きます．
			</p>
			<p>
				3つのパッケージに分ける必要があるとき，
				パッケージの実質的な中身がライブラリなのか実行可能プログラムなのかによって命名法が変わります．
				実行可能プログラムが重要な場合:
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Package</th><th align="left">Contents</th></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo-shlibs</tt></td><td><p>共有ライブラリ</p></td></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo</tt></td><td><p>ヘッダ</p></td></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo-bin</tt></td><td><p>実行可能プログラムなど</p></td></tr></table>

			<p>ライブラリが重要な場合:</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Package</th><th align="left">Contents</th></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo-shlibs</tt></td><td><p>共有ライブラリ</p></td></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo-dev</tt></td><td><p>ヘッダ</p></td></tr><tr valign="top"><td><tt style="white-space: nowrap;">foo</tt></td><td><p>実行可能プログラムなど</p></td></tr></table>

			<p>
				既存のパッケージのアップグレードでは後者を選ぶと手間がかかります．
				すなわち，アップグレードと同時に <tt style="white-space: nowrap;">Depends: foo</tt> との記述のある全てのパッケージに
				<tt style="white-space: nowrap;">BuildDepends: foo-dev</tt> を加える必要があります．
				注意すべき点は他にもあります．
				(中間に別のパッケージを経由して) 間接的に当該パッケージに依存するパッケージのアップグレードを確かに成功させるためには，
				<tt style="white-space: nowrap;">BuildDepends: foo</tt> あるいは <tt style="white-space: nowrap;">BuildDepends: foo-dev</tt> を加える必要があるかもしれません．
				(これがないとアップグレードに失敗する可能性があります．)
				当該パッケージのメインテナには，他のパッケージに <tt style="white-space: nowrap;">BuildDepends</tt> が追加されるのを確認する責任があります．
			</p>
			<p>
				<b>ポリシー詳細</b>
			</p>
			<p>
				以下ではさらに詳しく解説します．
				まず新規にソフトウェアをポートする際のポリシーを，次に既存 Fink パッケージのアップグレードを解説します．
				現在進行形のポリシーの例としては libpng, libjpeg や libtiff を参照して下さい．
			</p>
			<p>
				Darwin にポートされたソフトウェアはできる限り共有ライブラリをビルドすることになります．
				(パッケージにとって適切な場合にパッケージメインテナが静的ライブラリをビルドするのは自由です．
				または静的ライブラリのみを含むパッケージを登録することも問題ありません．)
				共有ライブラリをビルドする場合，<b>ふたつの</b>相互関連する Fink パッケージを作成しなければいけません．
				それらは例えば foo と foo-shlibs といった名称になります．
				共有ライブラリは foo-shlibs に，ヘッダは foo に入ります．
				これら2つのパッケージを単一の .info ファイルから作れます．
				それには後述のフィールド <tt style="white-space: nowrap;">SplitOff</tt> を利用します．
				(現実には3つ以上のパッケージに分割する必要がある場合も多く，
				この場合は <tt style="white-space: nowrap;">SplitOff2</tt>, <tt style="white-space: nowrap;">SplitOff3</tt> と追加していきます．)
			</p>
			<p>
				共有ライブラリが作れるソフトウェアパッケージには，それぞれの<b>「メジャー・バージョン番号」</b> N がなければいけません．
				「メジャー・バージョン番号」はライブラリの API にパッケージ間で非互換な変更が加えられたときのみ変わることになっています．
				Fink では，名称は以下の要領で作成されます．
				すなわち， upstream パッケージ名が bar なら，そのFinkパッケージの名前は barN と barN-shlibs になります．
				(この規約が厳密に適用されるのは新規に作られるパッケージと「メジャーバージョン」が変わったパッケージのみです．)
				例えば既存のFinkパッケージ libpng の「メジャーバージョン」は 2 でしたが，最近のものでは 3 になっています．
				そこで当面はこのライブラリに関わるFinkパッケージは4種類あることになります:
				libpng, libpng-shlibs, libpng3, libpng3-shlibs です．
				libpng と libpng3 はどちらか片方しか同時にインストールできませんが，libpng-shlibs と libpng3-shlibs は同時にインストールできます．
				(これら4つのパッケージのビルドに必要な .info ファイルは2つだけであることに注意して下さい．)
			</p>
			<p>
				共有ライブラリ自身とそれに関わるファイルはパッケージ barN-shlibs に入ります．
				また「インクルード」ファイルとその他のファイルはパッケージ barN に入ります．
				これら2つに重複して含まれるファイルがあってはならず，また barN-shlibs に含まれるファイルのいずれにも，
				何らかの形で「メジャーバージョン」 N を含むパス名が付けられなくてはいけません．
				多くの場合，パッケージは，(典型的には <tt style="white-space: nowrap;">%i/lib/bar</tt> や
				<tt style="white-space: nowrap;">%i/share/bar/</tt> にインストールされる) いくつかのファイルを実行時に必要とします．
				そのときはインストール先パスを <tt style="white-space: nowrap;">%i/lib/bar/N</tt> や
				<tt style="white-space: nowrap;">%i/share/bar/N/</tt> に修正することになります．
			</p>
			<p>
				「メジャーバージョン」が N であるようなパッケージ bar に依存するパッケージは，全て次のような依存情報を使うことになります．
			</p>
<pre>
Depends: barN-shlibs
BuildDepends: barN
</pre>
			<p>
				この方式が機能するようになって以降は，他のパッケージが barN 自体に依存するようにしてはいけません．
				(後方互換性のため，既存のパッケージは barN に依存して構いません．)
				以上を他の開発者に知らせるため，barN のパッケージ記述情報の中に次の真偽値フィールドを設けます．
			</p>
<pre>
BuildDependsOnly: True
</pre>
			<p>
				共有ライブラリと実行可能プログラムの両方を含むパッケージの場合，実行可能プログラムが (ビルド時だけでなく) 実行時に必要であれば，
				それらの実行可能プログラムは barN-bin という名の第3のパッケージに split off されなければいけません．
				他のパッケージが barN-shlibs の他に barN-bin に依存しても構いません．
			</p>
			<p>
				「メジャーバージョン」が N の共有ライブラリをビルドするとき，その共有ライブラリの "install_name" が
				<tt style="white-space: nowrap;">%p/lib/bar.N.dylib</tt> になることが重要です．
				(install_name は，ライブラリに <tt style="white-space: nowrap;">otool -L</tt> を実行するとわかります．)
				実際のライブラリファイルのインストール先は，
			</p>
<pre>
%i/lib/bar.N.x.y.dylib
</pre>
			<p>
				でなければならず，パッケージ側で次のようにシンボリックリンクを貼らなければいけません．
			</p>
<pre>
%i/lib/bar.N.dylib -&gt; %p/lib/bar.N.x.y.dylib
%i/lib/bar.dylib -&gt; %p/lib/bar.N.x.y.dylib
</pre>
			<p>
				静的ライブラリもビルドする場合，次の場所にインストールされることになります．
			</p>
<pre>
%i/lib/bar.a
</pre>
			<p>
				パッケージが libtool を利用する場合，上記のことはほぼ自動的に処理されますが，
				どの段階でも処理が適切に行われたかチェックしなければいけません．
				また， current_version と compatibility_version が適切に定義されているかも確認して下さい．
				(これらも <tt style="white-space: nowrap;">otool -L</tt> で表示されます．)
			</p>
			<p>
				次にファイルを以下のように2つのパッケージに分類します．
			</p>
			<ul>
				<li>パッケージ barN-shlibs:
<pre>
%i/lib/bar.N.x.y.dylib
%i/lib/bar.N.dylib -&gt; %p/lib/bar.N.x.y.dylib
%i/lib/bar/N/*
%i/share/bar/N/*
%i/share/doc/barN-shlibs/*
</pre>
				</li>
				<li>パッケージ barN:
<pre>
%i/include/*
%i/lib/bar.dylib -&gt; %p/lib/bar.N.x.y.dylib
%i/lib/bar.a
%i/share/doc/barN/*
必要に応じて，他のファイルも含める
</pre>
				</li>
			</ul>
			<p>
				どちらのパッケージにもライセンスに関する何らかの文書が必要ですが， DocFiles を含むディレクトリは異なることに注意して下さい．
			</p>
			<p>
				このことはフィールド <tt style="white-space: nowrap;">SplitOff</tt> を使えば実際には非常に簡単です．
				以下に上の例を実現するためにどのように記述するか (の一部) を示します．
			</p>
<pre>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
Package: barN-shlibs
Files: lib/bar.N.x.y.dylib lib/bar.N.dylib lib/bar/N
DocFiles: COPYING
&lt;&lt;
</pre>
			<p>
				フィールド <tt style="white-space: nowrap;">SplitOff</tt> の実行で，指定したファイルとディレクトリが，
				メインパッケージのインストールディレクトリ %I から splitoff パッケージのインストールディレクトリ %i に移動します．
				(これは命名法とも似ています．
				すなわち，%N が中核パッケージの「パッケージ名」で，%n が splitoff パッケージの「パッケージ名」です．)
				次に <tt style="white-space: nowrap;">DocFiles</tt> のコマンドはドキュメントファイルを <tt style="white-space: nowrap;">%i/share/doc/barN-shlibs</tt> にコピーします．
			</p>
			<p>
				barN-shlibs の正確な「バージョン」 (これは "%N-shlibs (= %v-%r)" と略記できます)
				をメインパッケージ barN の依存情報に含めたことに注意して下さい．
				これにより「バージョン」が確かに適合するようになり，
				さらにパッケージ barN が自動的にパッケージ barN-shlibs の依存情報を「継承する」ことを保証します．
			</p>
			<p>
				<b>フィールド Shlibs:</b>
			</p>
			<p>
				共有ライブラリを適切なパッケージに分類する他に， Fink ポリシー第4版では，
				共有ライブラリを持つパッケージ全てがフィールド <tt style="white-space: nowrap;">Shlibs</tt> を使うようにしなければいけません．
				このフィールドでは，各共有ライブラリに対して 1) ライブラリの -install_name， 2) ライブラリの -compatibility_version，
				3) そのライブラリを提供する Fink パッケージを指定するバージョン付き依存性情報 (ただし -compatibility_version が同じでなければならない)
				を1行ずつ記します．
				依存性情報は <tt style="white-space: nowrap;">foo (&gt;= バージョン-版)</tt> という形式で示します．
				ここで <tt style="white-space: nowrap;">バージョン-版</tt> にはこの (-compatibility_version が同じ) ライブラリを利用可能にしてくれる
				Fink パッケージの<b>最初</b>の「バージョン」を使います．
				例えば次の宣言は，
			</p>
<pre>
Shlibs: &lt;&lt;
%p/lib/bar.1.dylib 2.1.0 bar1 (&gt;= 1.1-2)
&lt;&lt;
</pre>
			<p>
				<tt style="white-space: nowrap;">-install_name</tt> が %p/lib/bar.1.dylib で <tt style="white-space: nowrap;">-compatibility_version</tt> が 2.1.0 のライブラリが，
				Fink パッケージ <b>bar1</b> の「バージョン」1.1-2 以降でインストールされるようになることを示します．
				それに加え，この宣言は「この名前がついていて compatibility_version が少なくとも 2.1.0 のライブラリは，
				Fink パッケージ bar1 の今後のバージョンには必ず含まれている」というメインテナからの保証にも相当します．
			</p>
			<p>
				ライブラリの名称には %p を使用するよう注意して下さい．
				これによって，インストールディレクトリに関係なく Fink ユーザが正しい <tt style="white-space: nowrap;">-install_name</tt> を検索することができるようになります．
			</p>
			<p>
				パッケージが更新されたとき，
				普通は次の「バージョン」または「版」の finkinfo ファイルにフィールド <tt style="white-space: nowrap;">Shlibs</tt> をコピーするだけで構いません．
				例外は， <tt style="white-space: nowrap;">-compatibility_version</tt> が増加したときです．
				その場合，依存性情報の中の「バージョン」は新しい「バージョン」または「版」に従って更新されなければいけません．
				(新しい「バージョン」または「版」とは，
				新しい compatibility_version のライブラリを提供する最初の「バージョン」または「版」のことです．)
			</p>
			<p>
				<b>メジャーバージョン番号が変わるとき:</b>
			</p>
			<p>
				「メジャーバージョン」が N から M に変化したときは，2つの新しいパッケージ barM と barM-shlibs を作ることになります．
				パッケージ barM-shlibs と barN-shlibs に重複するファイルがあってはいけません．
				これは，多くのユーザにとって両方を同時にインストールする必要があるからです．
				パッケージ barM には以下の依存性情報を指定します．
			</p>
<pre>
Conflicts: barN
Replaces: barN
</pre>
			<p>
				同様に barN の方も次の依存性情報を含むように改訂します．
			</p>
<pre>
Conflicts: barM
Replaces: barM
</pre>
			<p>
				するとユーザは，問題の共有ライブラリの片方のバージョンに依存する他の様々なパッケージがビルドされるときに
				barN や barM が代わる代わる入ってくるのを目にするでしょうが，
				barN-shlibs と barM-shlibs はいつまでもインストールしたままでいられます．
			</p>
			<p>
				<b>既存の Fink パッケージをアップグレードする方法:</b>
			</p>
			<p>
				共有または静的ライブラリをインストールする既存のFinkパッケージについては，
				アップグレードの最良の方法は，問題のパッケージ foo の新しい「バージョン」を作り，
				上のポリシーを満たす新しいパッケージ foo-shlibs を付属させることです．
				共有ライブラリ (または foo-shlibs にも含まれる任意のファイル) が以前にもインストールされていたら，
				その新パッケージ foo で次のように指定します．
			</p>
<pre>
Replaces: foo (&lt;&lt; 同等な.旧式パッケージの.バージョン)
</pre>
			<p>
				これはアップグレードをユーザに意識させないためです．
				("Conflicts: foo" ではアップグレードが阻害されるので，<b>使用しないで下さい</b>．)
			</p>
			<p>
				アップグレード後，"Depends: foo" となっているパッケージは普通に機能し続けます．
				しかし，そのようなFinkパッケージのメインテナ全てに連絡し，
				できる限り早くそれらのパッケージで "Depends: foo-shlibs, BuildDepends: foo" とするよう要請しなければいけません．
				そのようなメインテナ全員がその措置を終えるまで，
				新しい「メジャーバージョン」の共有ライブラリを提供する新パッケージ fooM と fooM-shlibs を作ることはできません．
			</p>
			<p>
				既存のパッケージで， install_name の名称や，共有ライブラリの名称やシンボリックリンクの名称を正しく使っていない場合，
				注意してケースバイケースで対処することになります．
				パッケージを新ポリシーに従ってアップグレードする方法を決定することが困難であれば，メーリングリスト fink-devel で議論して下さい．
			</p>
			<p>
				<b>実行可能ファイルとライブラリの両方を含むパッケージ:</b>
			</p>
			<p>
				upstream パッケージが実行可能ファイルとライブラリの両方を含む場合，
				Fink パッケージを作成する際にいくつかの注意が必要です．
				唯一の実行可能ファイルが (恐らくビルド時のみに使われ，実行時には使われない) foo-config のようなものという場合もあります．
				その場合，実行可能ファイルはパッケージ <tt style="white-space: nowrap;">foo</tt> 内にヘッダファイルと同梱して構いません．
			</p>
			<p>
				そうでない場合，実行可能ファイルは実行時に他の Fink パッケージから必要とされることになりますが，
				それらは <tt style="white-space: nowrap;">foo-bin</tt>foo-bin 等という名前の個別の Fink パッケージに split off しなければいけません．
				パッケージ <tt style="white-space: nowrap;">foo-bin</tt> はパッケージ <tt style="white-space: nowrap;">foo-shlibs</tt> に依存するようにします．
				他のパッケージのメインテナは次のようにして，暗黙のうちに <tt style="white-space: nowrap;">foo-shlibs</tt> を考慮するべきです．
			</p>
<pre>
Depends: foo-bin
BuildDepends: foo
</pre>
			<p>
				しかしこの場合，アップグレードは問題を起こします．
				ユーザは <tt style="white-space: nowrap;">foo-bin</tt> をインストールするよう指示されないからです．
				この問題の回避のため， <tt style="white-space: nowrap;">foo</tt> に依存している全てのパッケージのメインテナがパッケージを上記のように改定するまで，
				あなたのパッケージ <tt style="white-space: nowrap;">foo</tt> で次のようにして構いません．
			</p>
<pre>
Depends: foo-shlibs (= 正確な.バージョン), foo-bin
</pre>
			<p>
				こうすると大半のユーザのシステムで，他のパッケージのメインテナが各々のパッケージを <tt style="white-space: nowrap;">foo</tt> に依存するように改訂するときまで，
				<tt style="white-space: nowrap;">foo-bin</tt> のインストールが要求されます．
			</p>

		

		<h3><a name="policy.perlmods">3.4 Perl モジュール</a></h3>
			
			<p>
				2003年5月以来，Finkには Perl モジュールに対する新しいポリシーがあります．
			</p>
			<p>
				伝統的に，perlモジュールのFinkパッケージには <tt style="white-space: nowrap;">-pm</tt> が後置され，
				ディレクティブ <tt style="white-space: nowrap;">Type: perl</tt> を使ってビルドされて来ました．
				このディレクティブは Perl モジュールのファイルを
				<tt style="white-space: nowrap;">/sw/lib/perl5</tt> 及び/または <tt style="white-space: nowrap;">/sw/lib/perl5/darwin</tt> に格納していました．
				新ポリシーでは，ここには，コンパイルに使われる Perl のバージョンに依存しない Perl モジュールのみを格納します．
			</p>
			<p>
				バージョンに依存する Perl モジュールは XS モジュールと呼ばれていて，
				純粋な Perl コードの他にしばしば C コードからコンパイルされたファイルを含みます．
				このことを区別する方法はいくつもありますが，例えば拡張子 <tt style="white-space: nowrap;">.bundle</tt> を持つファイルがあるか調べる方法があります．
			</p>
			<p>
				バージョンに依存する Perl モジュールは該当バージョンの付いた Perl の実行可能ファイル (perl5.6.0 など) でビルドされなければいけません．
				また，できたファイルは標準の Perl のディレクトリ内の，バージョンの付いたサブディレクトリ
				(例えば <tt style="white-space: nowrap;">/sw/lib/perl5/5.6.0</tt> や <tt style="white-space: nowrap;">/sw/lib/perl5/5.6.0/darwin</tt>) に格納しなければいけません．
				導入が進んでいる新しい命名規約は，バージョン 5.6.0 に依存する Perl モジュールに <tt style="white-space: nowrap;">-pm560</tt> を後置するというものです．
				格納場所と命名方法に関する同様の規約が他のバージョンの Perl に対しても有効で，間もなく perl 5.6.1 と perl 5.8.0 でもそうなります．
			</p>
			<p>
				新しいディレクティブ <tt style="white-space: nowrap;">Type: perl 5.6.0</tt> は自動的にバージョンの付いた Perl の実行可能ファイルを使い，
				できたファイルを適切なサブディレクトリに格納します．
				(このディレクティブは Fink 0.13.0 から導入されています．)
			</p>
			<p>
				この他に， <tt style="white-space: nowrap;">-pm</tt> の付くパッケージとして作成することもできます．
				これは本質的には「バンドル」パッケージで， <tt style="white-space: nowrap;">-pm560</tt> などの付く同等なパッケージ (他に変種があればそちらも) をロードします．
				アップグレードを簡単にするため，XSモジュールのための既存のFinkパッケージに対してはこの方式が推奨されます．
			</p>
			<p>
				Fink 0.13.0 から利用可能になったコマンド <tt style="white-space: nowrap;">fink validate</tt> は，.deb ファイルに適用されると，
				その Fink パッケージが XS モジュールで，バージョンの付かないディレクトリにインストールされるかチェックし，そうなら警告を発します．
			</p>

		
	<h2><a name="fslayout">4 ファイルシステムのレイアウト</a></h2>
		
		


		
			<p>
				以下はファイルシステムレイアウトのガイドラインで， Fink のパッケージ化ポリシーに含まれています．
			</p>
		


		<h3><a name="fslayout.fhs">4.1 ファイルシステム構造標準 (Filesystem Hierarchy Standard)</a></h3>
			
			<p>
				Fink は<a href="http://www.pathname.com/fhs/">ファイルシステム構造標準 (Filesystem Hierarchy Standard ，略して FHS )</a>
				の精神に従います．
				しかし従えるのは飽くまでも精神のみです．
				それはFHSが <tt style="white-space: nowrap;">/</tt> と <tt style="white-space: nowrap;">/</tt> 以下の階層を管理できるシステムベンダ向けに作られたからです．
				Fink はインストールディレクトリ (別名「プリフィクス」) 以下のみを管理するアドオン・ディストリビューションです．
				以降の例ではデフォルトの「プリフィクス」 <tt style="white-space: nowrap;">/sw</tt> を使います．
			</p>
		

		<h3><a name="fslayout.dirs">4.2 ディレクトリ</a></h3>
			
			<p>
				ファイルは以下のサブディレクトリに保存します:
			</p>

			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/bin</tt>
					</td><td>
						<p>
							一般的な実行可能プログラム用．
							サブディレクトリはなし．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/sbin</tt>
					</td><td>
						<p>
							管理者のみが使うことを意図した実行可能プログラム用．
							バックグラウンドで動くデーモンもここに入る．
							サブディレクトリはなし．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/include</tt>
					</td><td>
						<p>
							C と C++ のヘッダファイル用．
							必要に応じてサブディレクトリを作成してよい．
							標準の C ヘッダファイルと混同しそうなヘッダファイルをインストールする場合は<b>必ず</b>サブディレクトリに入れること．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/lib</tt>
					</td><td>
						<p>
							アーキテクチャ依存のデータファイルやライブラリ用．
							静的および共有ライブラリは，避ける理由が特にない限り， <tt style="white-space: nowrap;">/sw/lib</tt> 直下に置く．
							ユーザが直接起動することのない実行可能プログラム (普通なら libexec 下に置かれるはずのもの) もここに置く．
						</p>
						<p>
							パッケージは固有のデータやロード可能モジュールを保存するサブディレクトリを自由に作成できます．
							互換性を考慮したディレクトリ名を使うよう心がけて下さい．
							特にディレクトリ名や付加的な階層にパッケージの「メジャーバージョン」を使い，
							<tt style="white-space: nowrap;">/sw/lib/perl5</tt> や <tt style="white-space: nowrap;">/sw/lib/apache/1.3</tt> などとするのが賢明です．
							ディレクトリにホストの種類を使うときには注意して下さい．
							<tt style="white-space: nowrap;">powerpc-apple-darwin1.3.3</tt> は互換性の観点から問題があります．
							<tt style="white-space: nowrap;">powerpc-apple-darwin1.3</tt> または単に <tt style="white-space: nowrap;">powerpc-apple-darwin</tt> とすべきです．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/share</tt>
					</td><td>
						<p>
							アーキテクチャに依存しないデータファイル用で， <tt style="white-space: nowrap;">/sw/lib</tt> と同じルールが当てはまります．
							よく使われるサブディレクトリについては後述します．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/share/man</tt>
					</td><td>
						<p>
							マニュアルページ用．
							この中はmanのセクションに従って整理されます．
							ここには <tt style="white-space: nowrap;">/sw/bin</tt> と
							<tt style="white-space: nowrap;">/sw/sbin</tt> の中の全てのプログラムに対応したマニュアルページがなければいけません．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/share/info</tt>
					</td><td>
						<p>
							Texinfo ソースから生成される Info 形式のドキュメント用．
							索引ファイル <tt style="white-space: nowrap;">dir</tt> のメンテナンスは
							Debian 版の <tt style="white-space: nowrap;">install-info</tt> (パッケージ <tt style="white-space: nowrap;">dpkg</tt> の一部) で自動化される．
							フィールド <tt style="white-space: nowrap;">InfoDocs</tt> を使ってパッケージスクリプト <tt style="white-space: nowrap;">PostInst</tt> 及び
							<tt style="white-space: nowrap;">PreRm</tt> のための適切なコードを自動生成すること．
							Fink は，それぞれのパッケージが勝手に <tt style="white-space: nowrap;">dir</tt> ファイルを作成しないように確認をする．
							サブディレクトリはなし．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/share/doc</tt>
					</td><td>
						<p>
							man でも Info でもないドキュメント用．
							README, LICENSE, COPYING はここに保存する．
							全てのパッケージは，ここにパッケージの名前に対応したサブディレクトリを作らなければいけない．
							名前には (「パッケージ名」そのものの一部でない限り) 「バージョン」を含めてはいけません．
							ヒント: <tt style="white-space: nowrap;">%n</tt> を使うとよい．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/share/locale</tt>
					</td><td>
						<p>
							国際化で使うメッセージカタログ用．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/var</tt>
					</td><td>
						<p>
							ディレクトリ <tt style="white-space: nowrap;">var</tt> には変化し得るデータを保存する．
							(スプールディレクトリ，ロックファイル，状態のデータベース，ゲームのハイスコアやログファイルなど)
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/etc</tt>
					</td><td>
						<p>
							設定ファイル用．
							複数のファイルを使用するパッケージはサブディレクトリを作らなければいけない．
							区別のため，そのサブディレクトリにはパッケージまたはその中のプログラムの名前を付けなければいけない．
						</p>
					</td></tr><tr valign="top"><td>
						<tt style="white-space: nowrap;">/sw/src</tt>
					</td><td>
						<p>
							ソースコードを保存，ビルドするディレクトリ．
							パッケージはここに何もインストールしてはいけない．
						</p>
					</td></tr></table>
		


		<h3><a name="fslayout.avoid">4.3 避けるべきこと</a></h3>
			
			<p>
				<tt style="white-space: nowrap;">/sw</tt> 下には，上述のもの以外ディレクトリを作ってはいけない．
				特に以下のディレクトリを作らないこと:
				<tt style="white-space: nowrap;">/sw/man</tt>, <tt style="white-space: nowrap;">/sw/info</tt>,
				<tt style="white-space: nowrap;">/sw/doc</tt>, <tt style="white-space: nowrap;">/sw/libexec</tt>,
				<tt style="white-space: nowrap;">/sw/lib/locale</tt>
			</p>
		

	<h2><a name="reference">5 リファレンスマニュアル</a></h2>
		
		

		<h3><a name="reference.build">5.1 ビルドプロセス</a></h3>
			

			<p>
				各フィールドの意味を理解するには， Fink のビルドプロセスに関する知識が必要となります．
				このプロセスは５段階になっていて，それぞれ解凍段階，パッチ段階，コンパイル段階，インストール段階，ビルド段階 と呼ばれます．
				下記の例では <tt style="white-space: nowrap;">/sw</tt> にパッケージ gimp-1.2.1-1 をインストールするものとします．
			</p>
			<p>
				<b>解凍段階</b>では，ディレクトリ <tt style="white-space: nowrap;">/sw/src/gimp-1.2.1-1</tt> が作成されてソースの tar ボールがそこに解凍されます．
				大抵，解凍によりソースを含むディレクトリ <tt style="white-space: nowrap;">gimp-1.2.1</tt> が作られます．
				これ以降のステップはすべてこの中 (<tt style="white-space: nowrap;">/sw/src/gimp-1.2.1-1/gimp-1.2.1</tt> など) で行われます．
				詳細はフィールド SourceDirectory, NoSourceDirectory や Source<b>N</b>ExtractDir (Nは数字) で変更できます．
			</p>
			<p>
				<b>パッチ段階</b>では，Darwin でビルドするためのパッチがソースに当てられます．
				フィールド UpdateConfigGuess, UpdateLibtool, Patch や PatchScript で指定されたアクションを，この順で実行します．
			</p>
			<p>
				<b>コンパイル段階</b>では，ソースの configure とコンパイルが行われます．
				普通，ここではスクリプト <tt style="white-space: nowrap;">configure</tt> を適切な引数で起動し，コマンド <tt style="white-space: nowrap;">make</tt> を実行することになります．
				詳細はフィールド CompileScript を参照して下さい．
			</p>
			<p>
				<b>インストール段階</b>では，パッケージは仮ディレクトリ
				<tt style="white-space: nowrap;">/sw/src/root-gimp-1.2.1-1</tt> (%d と同じ) にインストールされます．
				("root-" が付いていることに注意．)
				ディレクトリ <tt style="white-space: nowrap;">/sw</tt> にインストールされる予定のファイルは全て，
				<tt style="white-space: nowrap;">/sw/src/root-gimp-1.2.1-1/sw</tt> (%i すなわち %d%p に同じ) にインストールされます．
				詳細はフィールド InstallScript を参照して下さい．
			</p>
			<p>
				(<b>Fink 0.9.9 で導入された機能:</b>
				フィールド <tt style="white-space: nowrap;">SplitOff</tt> を用いると，単一の finkinfo ファイルから複数のパッケージを生成できます．
				インストール段階の最後のあたりでパッケージそれぞれに対して個別のインストールディレクトリが作られ，
				ファイルを適当なディレクトリに振り分けていきます．)
			</p>
			<p>
				<b>ビルド段階</b>では，仮ディレクトリからバイナリパッケージ (.deb ファイル) が作られます．
				この段階を直接制御することはできません．
				代わりに， finkinfo ファイルからの様々な情報を使って dpkg 用の <tt style="white-space: nowrap;">control</tt> ファイルが作成できます．
			</p>
		

		<h3><a name="reference.fields">5.2 フィールド</a></h3>
			

			<p>
				フィールドを分類して解説します．
				以下の一覧は完全ではありません．
				<tt style="white-space: nowrap;">:-)</tt>
			</p>
			<p>
				<b>初期データ:</b>
			</p>

			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>Package</td><td>
						<p>
							「パッケージ名」．
							値には英小文字，数字及び ドット '.', プラス '+', ハイフン '-' が使える．
							下線 ('_') と英大文字は使えない．
							必須フィールド．
						</p>
						<p>
							Fink 0.9.9 以降では，パーセント記法の展開が有効です．
							パーセント記法は他にフィールド
							Depends, BuildDepends, Provides, Conflicts, Replaces, Recommends, Suggests, Enhances で使えます．
						</p>
					</td></tr><tr valign="top"><td>Version</td><td>
						<p>
							upstream のバージョン．
							値にはフィールド Package と同じ制限があります．
							必須フィールド．
						</p>
					</td></tr><tr valign="top"><td>Revision</td><td>
						<p>
							Finkパッケージとしての「版」．
							upstream のバージョンが同じパッケージの finkinfo を書き換えたら，ここを1ずつ増やすこと．
							最初は1で始まる．
							必須フィールド．
						</p>
					</td></tr><tr valign="top"><td>Epoch</td><td>
						<p>
							<b>Fink 0.12.0 で導入</b>
							パッケージの「エポック」を指定する (指定されていない場合，デフォルト値は0) ．
							詳細は <a href="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian Policy Manual</a>
							を参照．
							省略可能フィールド．
						</p>
					</td></tr><tr valign="top"><td>Description</td><td>
						<p>
							パッケージの短い説明．(それが何であるか)
							一覧表示に使われる1行紹介文なので，簡潔かつわかりやすく．
							(半角) 45文字以下が望ましい．
							60文字を超えないこと．
							ここで「パッケージ名」を繰りかえす必要はない．
							必ず一緒に表示されるからだ．
							必須フィールド．
						</p>
					</td></tr><tr valign="top"><td>Type</td><td>
						<p>
							値が <tt style="white-space: nowrap;">bundle</tt> の場合:
							バンドルパッケージは関連するパッケージをひとまとめにするために使われる．
							それらには依存関係こそありますが，ソースコードにも，インストールされるファイルにも関連はありません．
							フィールド Source, PatchScript, CompileScript, InstallScript とその関連フィールドは，
							バンドル・パッケージでは無視される．
						</p>
						<p>
							値が <tt style="white-space: nowrap;">nosource</tt> の場合:
							これは bundle と非常に似ている．
							これは，ソースの tar ボールがないことを示す．
							よって何のソースも取り寄せられず，解凍段階では空ディレクトリが作られるだけになる．
							しかしパッチ，コンパイル，インストールの各段階は通常通り実行される．
							このようにして全てのソースコードをパッチと共に配布したり，
							または InstallScript を使ってディレクトリを作るだけのことができる．
							Fink 0.18.0 以降では <tt style="white-space: nowrap;">Source: none</tt> と設定しても同じ挙動が実現できる．
							こちらを使用すると，フィールド <tt style="white-space: nowrap;">Type</tt> を他の目的に使える (<tt style="white-space: nowrap;">Type: perl</tt> など)．
						</p>
						<p>
							値が <tt style="white-space: nowrap;">perl</tt> の場合 (Fink 0.9.5 以降):
							こうするとコンパイル及びインストールのスクリプトのデフォルト値が違うものになります．
							Fink 0.13.0 からは，この値の変種として <tt style="white-space: nowrap;">perl $version</tt> が使えます．
							ここで "$version" はperlの特定のバージョンで，3つの数をピリオドで区切ったものです．
							(<tt style="white-space: nowrap;">perl 5.6.0</tt> など)
						</p>
					</td></tr><tr valign="top"><td>License</td><td>
						<p>
							パッケージ配布の際にパッケージの従うライセンスの性質を表す．
							値は <a href="#policy.licenses">パッケージのライセンス</a> で示した選択肢から選ばなければいけない．
							それに加え，パッケージが実際にパッケージング・ポリシーに従うとき，
							すなわちライセンスのコピーがパッケージの doc ディレクトリにインストールされるときでなければ
							このフィールドを指定してはいけない．
						</p>
					</td></tr><tr valign="top"><td>Maintainer</td><td>
						<p>
							パッケージに責任を負っている人物の名前とメールアドレス．
							必須フィールド．
							値は以下の形式で，名前とメールアドレスはそれぞれ一つだけとする．
						</p>
<pre>名前 名字 &lt;アカウント@ドメイン.example.com&gt;</pre>
					</td></tr></table>
			<p>
				<b>依存性関連</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>Depends</td><td>
						<p>
							そのパッケージがビルドできるようになる前にインストールされていなければいけないパッケージのリスト．
							普通，これは「パッケージ名」の単なるカンマ区切りのリストだが，
							現在のFinkは代替パッケージとバージョンを (dpkgと同じ形式で) 指定する形式に対応している．
							それらを全て盛りこんだ例:
						</p>
<pre>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</pre>
						<p>
							本当の意味で省略可能な依存性を表現する方法がないことに注意．
							あるパッケージが別のパッケージがあってもなくても動作するとき，
							もう片方のパッケージが (存在するときであっても) 確かに使われていないか確かめるか，
							またはフィールド Depends に加えるかのどちらかを行うこと．
							ユーザにどちらの使い方をも提供したいときは，2つの別々のパッケージ (例えば wget と wget-ttl) を作る．
						</p>
						<p>
							Finkのバージョン post-0.18.2 CVS 以降では，条件付き依存性を記述できる．
							それを指定するには「パッケージ名」の前に <tt style="white-space: nowrap;">(string1 op string2)</tt> を付ける．
							パーセント記法が普通に展開され，オペレータ <tt style="white-space: nowrap;">op</tt> によって2つの文字列が比較される．
							<tt style="white-space: nowrap;">op</tt> には以下のものが使える: &lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=．
							その直後に続くパッケージへの依存性は，比較が真を返したときのみ存在すると判断される．
						</p>
						<p>
							この機能は，複数の似通ったパッケージを管理する際に手間を省くためにも使える．
							例えば elinks と elinks-ssl は次のように列挙できますが，
						</p>
<pre>Depends: (%n = elinks-ssl) openssl097-shlibs, expat-shlibs</pre>
						<p>
							これは elinks の方で
						</p>
<pre>Depends: expat-shlibs</pre>
						<p>
							とし， elinks-ssl の方で
						</p>
<pre>Depends: openssl097-shlibs, expat-shlibs</pre>
						<p>
							とすることと同じです．
						</p>
					</td></tr><tr valign="top"><td>BuildDepends</td><td>
						<p>
							<b>Fink 0.9.0 で導入</b>
							ビルド時のみに適用される依存性のリスト．
							ビルド時には必要だが，実行時には使われないツール (flexなど) を列挙するのに使う．
							書式は Depends と同じ．
						</p>
					</td></tr><tr valign="top"><td>Provides</td><td>
						<p>
							そのパッケージが「提供」すると考えられる「パッケージ名」のカンマ区切りのリスト．
							パッケージ pine の finkinfo に <tt style="white-space: nowrap;">Provides: mailer</tt> とある場合，
							pine がインストールされると mailer についての全ての依存性は解決したものとされる．
							普通，そのようなパッケージは pine のフィールド Conflicts や Replaces にも入れるとよい．
						</p>
					</td></tr><tr valign="top"><td>Conflicts</td><td>
						<p>
							そのパッケージと同時にインストールしてはいけない「パッケージ名」のカンマ区切りのリスト．
							バーチャル・パッケージでは，そのパッケージが提供する「パッケージ名」をここに指定してもよい．
							それらは適切に扱われる．
							このフィールドはフィールド Depends のようにバージョン付きの依存性情報にも対応しているが，
							代替パッケージには対応していない (意味をなさない)．
							あるパッケージがそれ自身のフィールド Conflicts に入っていると， (暗黙のうちに) そこから取り除かれる．
							 (Fink のバージョン post-0.18.2 CVS で導入された．)
						</p>
						<p>
							<b>注意:</b> Fink自身はこのフィールドを無視する．
							しかしこれは dpkg に渡され，そこで適切に扱われる．
							要するにこのフィールドが影響するのはビルド時でなく実行時だ．
						</p>
					</td></tr><tr valign="top"><td>Replaces</td><td>
						<p>
							Conflicts と共に使われる．
							そのパッケ−ジが，衝突するパッケ−ジの機能の代わりになるだけでなく，共通するファイルを持つときに使われる．
							このフィールドがないと，dpkgはパッケージのインストール時にエラーを出すかも知れない．
							それはファイルが依然として元あった方のパッケージに属しているからだ．
							それら2つのパッケージが純粋な意味で互いに代替物であり，どちらかがあればもう片方は要らないようなときはこれを使うとよい．
							あるパッケージのフィールド Replaces 内にそのパッケージそのものが含まれていたら， (暗黙のうちに) 取り除かれる．
							 (Finkのバージョン post-0.18.2 CVS で導入された．)
						</p>
						<p>
							<b>注意:</b> Fink自身はこのフィールドを無視する．
							しかしこれは dpkg に渡され，そこで適切に扱われる．
							要するにこのフィールドが影響するのはビルド時でなく実行時だ．
						</p>
					</td></tr><tr valign="top"><td>Recommends, Suggests, Enhances</td><td>
						<p>
							これらのフィールドはパッケージ同士の付加的な関係情報を指定する．
							書式は他の依存情報フィールドと同じ．
							これら3つの関係情報は dpkg や apt-get によるインストール過程そのものには影響しない．
							しかしこれらの情報は，dselect や他のフロントエンドが，微妙な選択を行うユーザの判断を助けるのに使われます．
						</p>
					</td></tr><tr valign="top"><td>Pre-Depends</td><td>
						<p>
							フィールド Depends の特別なもので，意味の上で厳密さが必要になる．
							このフィールドを使うのは，開発者用メーリングリストで議論を行い，確かに使う必要があるとの同意が得られた場合に限る．
						</p>
					</td></tr><tr valign="top"><td>Essential</td><td>
						<p>
							必須パッケージを表すのに使われる真偽値フィールド．
							必須パッケージはブートストラップ・プロセスの一環としてインストールされる．
							必須パッケージでない全てのパッケージは，必須パッケージに暗黙のうちに依存して構わない．
							dpkg は，このフィールドの指示に優先する特別なフラグを使わない限り，必須パッケージをシステムから取り除くことを拒む．
						</p>
					</td></tr><tr valign="top"><td>BuildDependsOnly</td><td>
						<p>
							<b>Fink 0.9.9 で導入された．</b>
							真偽値フィールド．
							他のパッケージはそのパッケージを (フィールド BuildDepends に入れてもよいが) Depends に入れてはいけないことを示す．
						</p>
					</td></tr></table>
			<p>
				<b>解凍段階:</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>CustomMirror</td><td>
						<p>
							ミラーサイトのリスト．
							各ミラーサイトは <tt style="white-space: nowrap;">&lt;場所&gt;: &lt;url&gt;</tt> という書式に従って1行に1つずつ記述する．
							<b>場所</b> には大陸コード (例えば nam) や国コード (例えば nam-us) など (何でもよい) を使う．
							ミラーサイトはここに記述した順に試される．
							例:
						</p>
<pre>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&gt;&gt;</pre>
					</td></tr><tr valign="top"><td>Source</td><td>
						<p>
							ソースのtarボールのURL．
							HTTPまたはFTPでなければいけないが，Finkはそれを単にwgetに渡すだけなので，実際には問題にならない．
							このフィールドは，ミラーサイトのための特殊なURL記法に対応している．
							すなわち <tt style="white-space: nowrap;">mirror:&lt;ミラー名称&gt;:&lt;相対パス&gt;</tt> だ．
							こうするとFinkに &lt;ミラー名称&gt; として設定されたURLを探し，その後ろに &lt;相対パス&gt; を付け加え，それを実際のURLとして使う．
							Finkの認識する &lt;ミラー名称&gt; の一覧は /sw/lib/fink/mirror/_list  (パッケージ fink または fink-mirrors の一部) の中にある．
							または， &lt;ミラー名称&gt; に custom と書くことで，フィールド CustomMirror をFinkに使わせることもできる．
							URLが wget に渡される前に，パーセント記法の展開が行われる．
						</p>
						<p>
							Fink 0.18.0 以降では Source: none は特殊な意味を持ち，取り寄せるべきソースは存在しないことを表す．
							詳細についてはフィールド Type の説明を参照．
							<tt style="white-space: nowrap;">gnu</tt> という値は <tt style="white-space: nowrap;">mirror:gnu:%n/%n-%v.tar.gz</tt> の，
							<tt style="white-space: nowrap;">gnome</tt> という値は <tt style="white-space: nowrap;">mirror:gnome:stable/sources/%n/%n-%v.tar.gz</tt> の省略形．
							デフォルトでは <tt style="white-space: nowrap;">%n-%v.tar.gz</tt>  (すなわちマニュアル・ダウンロード) になっている．
						</p>
					</td></tr><tr valign="top"><td>Source<b>N</b>
					</td><td>
						<p>
							パッケージが複数のtarボールから形成されているときは，これらの (省略可能な) フィールドで指定を行う．
							Nは数で，2から始まる．
							つまり最初のtarボール (ある意味「メイン」になるもの) をフィールド <tt style="white-space: nowrap;">Source</tt> に，
							2番目のtarボールをフィールド <tt style="white-space: nowrap;">Source2</tt> に，という風になる．
							値の書式は <tt style="white-space: nowrap;">Source</tt> と共通だが， <tt style="white-space: nowrap;">gnu</tt> や <tt style="white-space: nowrap;">gnome</tt> という省略形は展開されない (結局，意味をなさない)．
						</p>
					</td></tr><tr valign="top"><td>SourceDirectory</td><td>
						<p>
							tar ボールが単一のディレクトリに展開されはするが，
							そのディレクトリ名が tar ボールのファイル名から拡張子を除いたものと異なるときに使う．
							つまり，普通なら "foo-1.0.tar.gz" という tar ボールは "foo-1.0" というディレクトリを生成する．
							しかし生成されるディレクトリ名がそれと異なる場合，そのディレクトリ名をこのフィールドで指定する．
							パーセント記法は展開される．
						</p>
					</td></tr><tr valign="top"><td>NoSourceDirectory</td><td>
						<p>
							真偽値フィールド．
							tar ボールが単一のディレクトリに展開されないときにこのフィールドを設定する．
							つまり，普通なら "foo-1.0.tar.gz" という tar ボールは "foo-1.0" というディレクトリを生成する．
							しかし tar ボールを展開したときにファイルがカレントディレクトリに撒き散らされる場合は，
							このフィールドの値を true に設定する．
						</p>
					</td></tr><tr valign="top"><td>Source<b>N</b>ExtractDir</td><td>
						<p>
							普通，補助的な tar ボールは「メイン」の tar ボールと同じディレクトリで展開される．
							それを特定のサブディレクトリ内で展開して欲しいときは，このフィールドで指定する．
							ご想像の通り， Source2ExtractDir は Source2 で指定した tar ボールに対応する．
							用例についてはパッケージ ghostscript, vim や tetex を参照．
						</p>
					</td></tr><tr valign="top"><td>SourceRename</td><td>
						<p>
							このフィールドを使うと，ビルド時にソースの tar ボールをリネームできる．
							これが便利なのは，例えば，ソースのバージョンがサーバのディレクトリ名には示されているが，
							tar ボールそのものはどのバージョンでも同じ名前のときだ．
							(例えば ://www.foobar.org/coolapp/1.2.3/source.tar.gz というとき)
							このことで起きる問題を回避するためには次のようにすればよい．
						</p>
<pre>SourceRename: %n-%v.tar.gz</pre>
						<p>
							この例では，ご想像の通り， tar ボールは <tt style="white-space: nowrap;">/sw/src/coolapp-1.2.3.tar.gz</tt> として格納されることになる．
						</p>
					</td></tr><tr valign="top"><td>Source<b>N</b>Rename</td><td>
						<p>
							これはフィールド <tt style="white-space: nowrap;">SourceRename</tt> と同じだが，
							<tt style="white-space: nowrap;">Source<b>N</b>
							</tt> で指定された N 番目の tar ボールのリネームに使う．
							用例についてはパッケージ context や hyperref を参照．
						</p>
					</td></tr><tr valign="top"><td>Source-MD5</td><td>
						<p>
							<b>Fink 0.10.0 で導入．</b>
							このフィールドではソースファイルの MD5 チェックサムを指定する．
							Fink はこの情報によりおかしなソースファイル，
							すなわち fink パッケージの作成者が指定したものではない tar ボールを見分けられる．
							この問題の原因は，大抵次のようなものだ:
							tar ボールのダウンロードに失敗した，upstreamのメインテナが知らないうちに tar ボールを更新した，トロイの木馬のような攻撃，等々．
						</p>
						<p>
							このフィールドの典型的な用例は次のようなものだ．
						</p>
<pre>Source-MD5: 4499443fa1d604243467afe64522abac</pre>
						<p>
							チェックサムの算出にはツール <tt style="white-space: nowrap;">md5sum</tt> が使われる．
							tar ボール <tt style="white-space: nowrap;">/sw/src/apache_1.3.23.tar.gz</tt> のチェックサムが知りたいときには，
							次のコマンドを実行する (出力も一緒に示した)．
						</p>
<pre>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</pre>
						<p>
							ご覧のように，左に表示された値がここで必要なものだ．
						</p>
					</td></tr><tr valign="top"><td>Source<b>N</b>-MD5</td><td>
						<p>
							<b>Fink 0.10.0 で導入．</b>
							フィールド <tt style="white-space: nowrap;">Source-MD5</tt> と同様だが，
							フィールド <tt style="white-space: nowrap;">Source<b>N</b>
							</tt> に対応する N 番目の tar ボールの MD5 チェックサムを指定する．
						</p>
					</td></tr><tr valign="top"><td>TarFilesRename</td><td>
						<p>
							<b>Fink 0.10.0 で導入．</b>
							このフィールドは tar 形式を使うソースファイルにのみ適用される．
						</p>
						<p>
							このフィールドを使うと，任意のソース tar ボールの中のファイルを， tar ボールの展開中にリネームできる．
							ファイルシステム HFS+ がケースインセンシティブだ (大文字と小文字を区別しない) という事実を回避するのためには，これは非常に便利だ．
							普通の Mac OS X システムでは，ファイル <tt style="white-space: nowrap;">install</tt> と <tt style="white-space: nowrap;">INSTALL</tt> は衝突してしまう．
							このフィールドを使うと， tar ボールをわざわざ再パッケージしなくとも (以前，そういう場合には行われていた)，
							そういった問題を回避できる．
						</p>
						<p>
							このフィールドでは，リネームされるファイルのリストを単に指定する．
							ワイルドカードも使える．
							デフォルトでは，任意のファイルは，元の名前に <tt style="white-space: nowrap;">_tmp</tt> を後置したファイル名にリネームされる．
							フィールド <tt style="white-space: nowrap;">Files</tt> や <tt style="white-space: nowrap;">DocFiles</tt> と同様の書式を使って，このデフォルト値より優先した指定ができる．
							すなわち，元のファイル名，コロン (:)，新ファイル名，という順だ．
							例:
						</p>
<pre>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: direcory/INSTALL:directory/INSTALL.txt</pre>
						<p>
							<b>注意:</b>
							このフィールドは， BSD tar の特殊機能を使って実装されている．
							GNU tar はこの機能に対応していない．
							デフォルトでは Fink は GNU tar を使うが (GNU tar でしか展開できない tar ボールがあるため)，
							パッケージに TarFilesRename が使われているときは，
							Fink は常に (<tt style="white-space: nowrap;">/usr/bin/tar</tt> という直接指定により) BSD tar を使う．
						</p>
					</td></tr><tr valign="top"><td>Tar<b>N</b>FilesRename</td><td>
						<p>
							<b>Fink 0.10.0 で導入．</b>
							フィールド <tt style="white-space: nowrap;">TarFilesRename</tt> と同様だが，
							フィールド <tt style="white-space: nowrap;">Source<b>N</b>
							</tt> に対応する N 番目の tar ボールに対して機能する．
						</p>
					</td></tr></table>

			
			<p>
				<b>パッチ段階:</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>UpdateConfigGuess</td><td>
						<p>
							真偽値フィールド．
							真にすると，ビルド用ディレクトリ内のファイル config.guess と config.sub が Darwin に対応したバージョンに取り換えられる．
							その動作は，パッチ段階で，PatchScript が実行される前に行われる．
							これが必要だと分かっているとき<b>のみ</b>使うこと．
							すなわち，スクリプト configure が "unknown host" というメッセージで失敗するとき．
						</p>
					</td></tr><tr valign="top"><td>UpdateConfigGuessInDirs</td><td>
						<p>
							<b>post-0.9.0 CVS バージョンで導入．</b>
							サブディレクトリのリストを指定する．
							これは UpdateConfigGuess と同じことを行うが，ソースツリー中の複数のディレクトリに古い config.guess が入っているパッケージで便利だ．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要があったが，この新フィールドではディレクトリを単に列挙するだけでよい．
							ビルド用ディレクトリ自身の中のファイルの更新には <tt style="white-space: nowrap;">.</tt> とする．
						</p>
					</td></tr><tr valign="top"><td>UpdateLibtool</td><td>
						<p>
							真偽値フィールド．
							真にすると，ビルド用ディレクトリ内のファイル ltconfig と ltmain.sh が Darwin に対応したバージョンに取り換えられる．
							その動作は，パッチ段階で，PatchScript が実行される前に行われる．
							これが必要だと分かっているとき<b>のみ</b>使うこと．
							libtool 関連のスクリプトをバージョンの合わないものに取り換えると壊れるパッケージもある．
							詳細については<a href="http://fink.sourceforge.net/doc/porting/libtool.php">libtool のページ</a>を参照．
						</p>
					</td></tr><tr valign="top"><td>UpdateLibtoolInDirs</td><td>
						<p>
							<b>post-0.9.0 CVS バージョンで導入</b>
							サブディレクトリのリストを指定する．
							これは UpdateLibtool と同じことを行うが，ソースツリー中の複数のディレクトリに古い libtool 1.3.x 系列のスクリプトが入っているパッケージで便利だ．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要があったが，この新フィールドではディレクトリを単に列挙するだけでよい．
							ビルド用ディレクトリ自身の中のファイルの更新には <tt style="white-space: nowrap;">.</tt> とする．
						</p>
					</td></tr><tr valign="top"><td>UpdatePoMakefile</td><td>
						<p>
							真偽値フィールド．
							真にすると，サブディレクトリ <tt style="white-space: nowrap;">po</tt> 内のファイル <tt style="white-space: nowrap;">Makefile.in.in</tt> が，パッチの当たったものと取り換えられる．
							その動作は，パッチ段階で，PatchScript が実行される前に行われる．
						</p>
						<p>
							パッチの当たった <tt style="white-space: nowrap;">Makefile.in.in</tt> は DESTDIR の指定を優先し，メッセージカタログを，
							<tt style="white-space: nowrap;">/sw/lib/locale</tt> ではなく，確実に <tt style="white-space: nowrap;">/sw/share/locale</tt> に格納する．
							このフィールドを利用する前に，入れ換えによってパッケージを破壊していないこと，また入れ換えが本当に必要かどうかを確認すること．
							<tt style="white-space: nowrap;">diff</tt> を実行すれば，パッケージ付属のものと Fink 向けのもの (<tt style="white-space: nowrap;">/sw/lib/fink/update</tt> 内にある) との違いが分かる．
						</p>
					</td></tr><tr valign="top"><td>Patch</td><td>
						<p>
							<tt style="white-space: nowrap;">patch -p1 &lt;<b>パッチファイル</b>
							</tt> として適用されるパッチのファイル名．
							これには単なるファイル名を指定する．
							適切なパスは自動的に前置される．
							このフィールドではパーセント記法が展開されるので，典型的な場合では，値は単に <tt style="white-space: nowrap;">%f.patch</tt> または <tt style="white-space: nowrap;">%n.patch</tt> となる．
							PatchScript が指定されているとき，パッチはその後に実行される．
						</p>
					</td></tr><tr valign="top"><td>PatchScript</td><td>
						<p>
							パッチ段階で実行されるコマンドのリスト．
							以下のスクリプトの注意書きを参照．
							ここには，パッチを当てるか，またはパッケージに変更を加えるコマンドを指定する．
							デフォルト値はない．
							コマンドが実行される前に，パーセント記法が展開される (前節を参照)．
						</p>
					</td></tr></table>
			<p>
				<b>コンパイル (Compile Phase):</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>Set<b>環境変数名</b>
					</td><td>
						<p>
							コンパイルおよびインストールの段階の間，環境変数を設定しておく．
							コンパイラ・フラグ等を configure スクリプトや Makefile に渡すために使われる．
							現在，対応している変数は次の通り: CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, LD, LDFLAGS, LIBS, MAKE, MFLAGS, MAKEFLAGS.
							指定した値では，前節で説明したパーセント記法が展開される．
							よく使われる例:
						</p>
<pre>SetCPPFLAGS: -no-cpp-precomp</pre>
						<p>
							変数 CPPFLAGS および LDFLAGS は特別で，それぞれ <tt style="white-space: nowrap;">-I%p/include</tt> および <tt style="white-space: nowrap;">-L%p/lib</tt> というデフォルト値を持つ．
							これらの環境変数に値を指定すると，指定した値はデフォルト値の前に加えられる (デフォルト値は常に含まれる)．
						</p>
					</td></tr><tr valign="top"><td>NoSet<b>ENVVAR</b>
					</td><td>
						<p>
							真偽値フィールド．
							真にすると，上述の CPPFLAGS および LDFLAGS に対するデフォルト値は無効になる．
							すなわち， LDFLAGS の値を空にしたいときには <tt style="white-space: nowrap;">NoSetLDFLAGS: true</tt> とする．
						</p>
					</td></tr><tr valign="top"><td>ConfigureParams</td><td>
						<p>
							configure スクリプトに渡す付加的なパラメータ．
							(詳細は CompileScript を参照．)

							0.13.7 より上のバージョンの Fink では，
							このパラメータは <tt style="white-space: nowrap;">Type: Perl</tt> となっている perl モジュールにも使える．
							その場合，デフォルトの perl Makefile.PL 文字列に後置される．
						</p>
					</td></tr><tr valign="top"><td>GCC</td><td>
						<p>
							コンパイルに使う gcc に要求されるバージョン．
							指定できる値は以下の通り:
							<tt style="white-space: nowrap;">2.95.2</tt> または <tt style="white-space: nowrap;">2.95</tt> (パッケージ・ツリー 10.1 でのみ利用可能)，
							<tt style="white-space: nowrap;">3.1</tt> (パッケージ・ツリー 10.1 でのみ利用可能)，
							<tt style="white-space: nowrap;">3.3</tt> (パッケージ・ツリー 10.2-gcc3.3 および 10.3 でのみ利用可能)．
						</p>
						<p>
							Fink 0.13.8 以降，このフラグが指定されると， gcc のバージョンは <tt style="white-space: nowrap;">gcc_select</tt> によって調べられ，
							誤ったバージョンのものが存在すると Fink はエラー終了する．
						</p>
						<p>
							このフィールドは gcc コンパイラ間の移行を助けるために Fink に加えられた．
							gcc では， C++ コードの関わるライブラリ間で，実行可能・ファイル同士の (バージョン名に反映されない) 非互換が生じることがある．
						</p>
					</td></tr><tr valign="top"><td>CompileScript</td><td>
						<p>
							コンパイル段階で実行されるコマンドのリスト．
							See the note on scripts below.
							パッケージの configure およびコンパイルを行うコマンドをここに指定する．
							普通，デフォルトは次のようなものだ．
						</p>
<pre>./configure %c
make</pre>
						<p>
							これは GNU autoconf を利用するパッケージには適切だ．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							デフォルト値は次のようになる．
						</p>
<pre>perl Makefile.PL PREFIX=%p \
INSTALLPRIVLIB=%p/lib/perl5 \
INSTALLARCHLIB=%p/lib/perl5/darwin \
INSTALLSITELIB=%p/lib/perl5 \
INSTALLSITEARCH=%p/lib/perl5/darwin \
INSTALLMAN1DIR=%p/share/man/man1 \
INSTALLMAN3DIR=%p/share/man/man3
make
make test</pre>
						<p>
							タイプが <tt style="white-space: nowrap;">perl $version</tt> となっていて，バージョンが指定されているものでは (例えば $version は 5.6.0 とする)，
							デフォルト値は次のようになる．
						</p>
<pre>perl$version Makefile.PL \
PERL=perl$version PREFIX=%p \
INSTALLPRIVLIB=%p/lib/perl5/$version \
INSTALLARCHLIB=%p/lib/perl5/$version/darwin \
INSTALLSITELIB=%p/lib/perl5/$version \
INSTALLSITEARCH=%p/lib/perl5/$version/darwin \
INSTALLMAN1DIR=%p/share/man/man1 \
INSTALLMAN3DIR=%p/share/man/man3
make
make test</pre>
						<p>
							コマンドの実行前に，パーセント記法が展開される (前節を参照)．
						</p>
					</td></tr><tr valign="top"><td>NoPerlTests</td><td>
						<p>
							<b>Fink &gt; 0.13.7 で導入．</b>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定する．
							真にすると， <tt style="white-space: nowrap;">CompileScript</tt> のうち <tt style="white-space: nowrap;">make test</tt> の部分が，その perl モジュールのパッケージでは無視される．
						</p>
					</td></tr></table>
			<p>
				<b>インストール段階:</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>UpdatePOD</td><td>
						<p>
							<b>Fink 0.9.5 で導入．</b>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定する．
							真にすると，スクリプト install, postrm および postinst に， perl パッケージの提供する .pod ファイルを管理するためのコードを追加する．
							このとき，中央のファイル <tt style="white-space: nowrap;">/sw/lib/perl5/darwin/perllocal.pod</tt> に .pod ファイルのデータを追加したり，そこから削除も行う．
							(タイプが， <tt style="white-space: nowrap;">perl $version</tt> のように，perl の特定のバージョン (例えば 5.6.0) と共に指定された場合は，
							それらのスクリプトが扱う中央 .pod ファイルは <tt style="white-space: nowrap;">/sw/lib/perl5/$version/perllocal.pod</tt> になる．)
						</p>
					</td></tr><tr valign="top"><td>InstallScript</td><td>
						<p>
							インストール段階で実行されるコマンドのリスト．
							See the note on scripts below.
							ここには必要な全てのファイルをパッケージの stow directory にコピーするコマンドを指定する．
							普通，デフォルト値は次のようになる．
						</p>
<pre>make install prefix=%i</pre>
						<p>
							これは GNU autoconf を利用するパッケージには適切だ．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							デフォルト値は次のようになる．
						</p>
<pre>make install INSTALLPRIVLIB=%i/lib/perl5 \
INSTALLARCHLIB=%i/lib/perl5/darwin \
INSTALLSITELIB=%i/lib/perl5 \
INSTALLSITEARCH=%i/lib/perl5/darwin \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3</pre>
						<p>
							タイプが <tt style="white-space: nowrap;">perl $version</tt> となっていて，バージョンが指定されているものでは (例えば $version は 5.6.0 とする)，
							デフォルト値は次のようになる．
						</p>
<pre>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
INSTALLARCHLIB=%i/lib/perl5/$version/darwin \
INSTALLSITELIB=%i/lib/perl5/$version \
INSTALLSITEARCH=%i/lib/perl5/$version/darwin \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3</pre>
						<p>
							パッケージが対応しているなら，代わりに <tt style="white-space: nowrap;">make install DESTDIR=%d</tt> を使うことが望ましい．
							コマンドの実行前に，パーセント記法が展開される (前節を参照)．
						</p>
					</td></tr><tr valign="top"><td>JarFiles</td><td>
						<p>
							<b>Fink-0.10.0で導入</b>
							このフィールドは DocFiles に似ている．
							ここで指定した jar ファイルは <tt style="white-space: nowrap;">%p/share/java/%n</tt> にインストールされる．
							例:
						</p>
<pre>JarFiles: lib/*.jar foo.jar:fooBar.jar</pre>
						<p>
							こうすると，ディレクトリ lib 内の全ての jar ファイルをインストールし，
							foo.jar を fooBar.jar としてインストールする．
						</p>
						<p>
							また，これらの jar ファイル (特にディレクトリ <tt style="white-space: nowrap;">%p/share/java/%n</tt> 内にある .jar で終わるファイル)
							は環境変数 CLASSPATH に確実に追加される．
							このフィールドにより， configure や ant といったツールが，インストールされる jar ファイルを適切に判別できるようになる．
						</p>
					</td></tr><tr valign="top"><td>DocFiles</td><td>
						<p>
							このフィールドにより，ファイル README や COPYING を，
							パッケージの doc ディレクトリ (<tt style="white-space: nowrap;">%p/share/doc/%n</tt>) に容易にインストールできる．
							値にはスペース区切りのファイルのリストを指定する．
							ビルド用ディレクトリのサブディレクトリからファイルをコピーすることはできるが，
							それらのファイルは doc ディレクトリそのものに入れなければいけない (そのサブディレクトリに入れてはいけない)．
							シェルのワイルドカードが利用できる．
							単一のファイルを，実行時にリネームすることもできる．
							新ファイル名はコロンで区切って後置する．
							例:
							<tt style="white-space: nowrap;">libgimp/COPYING:COPYING.libgimp</tt>.
							このフィールドは InstallScript に適切な <tt style="white-space: nowrap;">install</tt> コマンドを前置することで動作する．
						</p>
					</td></tr><tr valign="top"><td>Shlibs</td><td>
						<p>
							<b>Fink-0.11.0 バージョンで導入</b>
							このフィールドでは，そのパッケージでインストールされる共有ライブラリを指定する．
							各共有ライブラリ毎に1行ずつ，空白文字で区切った以下の3項目を記述する．
							1) ライブラリの <tt style="white-space: nowrap;">-install_name</tt> 2) ライブラリの<tt style="white-space: nowrap;">-compatibility_version</tt>
							3) バージョン付き依存性情報で，その -compatibility_version を持つこのライブラリを提供するFinkパッケージを指定するもの
							依存情報は <tt style="white-space: nowrap;">foo (&gt;= バージョン-版)</tt> という型式で指定しなければいけない．
							ここで <tt style="white-space: nowrap;">バージョン-版</tt> は， (互換性バージョンの同じ) そのライブラリを利用可能にしてくれる Fink パッケージの
							<b>一番古い</b>バージョンを指す．
							フィールド Shlibs の設定は「この名前がついていて compatibility_version がこれ以上のライブラリは，
							その Fink パッケージの今後のバージョンでも必ず含まれている」というメインテナからの保証に相当する．
						</p>
					</td></tr><tr valign="top"><td>RuntimeVars</td><td>
						<p>
							<b>Fink-0.10.0 バージョンで導入</b>
							このフィールドは，実行時に環境変数を何らかの固定された値に設定する簡便な方法を提供する．
							(柔軟性が必要なら <a href="#reference.profile.d">profile.d スクリプト section</a> を参照．)
							そのパッケージがインストールされる限り，
							ここに指定した環境変数はスクリプト <tt style="white-space: nowrap;">/sw/bin/init.[c]sh</tt> によって設定される．
						</p>
						<p>
							環境変数の値には空白文字が使える (値の末尾に来ると取り除かれるが)．
							またパーセント記法は展開される．
							例:
						</p>
<pre>RuntimeVars: &lt;&lt;
SomeVar: %p/Value
AnotherVar: foo bar
&lt;&lt;</pre>
						<p>
							これは2つの環境変数 'SomeVar' および 'AnotherVar' を，それぞれ '/sw/Value' (あなたの環境のプリフィクスの値による) および 'foo bar' に設定する．
						</p>
						<p>
							このフィールドは InstallScript に適切なコマンドを後置することで機能する．
							それらのコマンドは，各環境変数に対して setenv/export 行をパッケージの profile.d スクリプトに追加する．
							よってあなた独自の環境変数は上書きされないので，自由に追加できる．
							これらの行はスクリプトに前置されるので，これらの環境変数をスクリプト内で利用できる．
						</p>
					</td></tr><tr valign="top"><td>SplitOff</td><td>
						<p>
							<b>Fink-0.9.9 バージョンで導入</b>
							1回のコンパイル/インストール操作で第2のパッケージを生成する．
							これの動作の詳細については，個別に書かれた <a href="#splitoffs">splitoff の章</a> を参照．
						</p>
					</td></tr><tr valign="top"><td>SplitOff<b>N</b>
					</td><td>
						<p>
							<b>Fink-0.9.9 バージョンで導入</b>
							これはフィールド <tt style="white-space: nowrap;">SplitOff</tt> と同様だが，1回のコンパイル/インストール操作で第3，第4のパッケージを生成するために使われる．
						</p>
					</td></tr><tr valign="top"><td>Files</td><td>
						<p>
							<b>Fink-0.9.9 バージョンで導入</b>
							フィールド <tt style="white-space: nowrap;">SplitOff</tt> または <tt style="white-space: nowrap;">SplitOff<b>N</b>
							</tt> の内部<b>のみ</b>で使われる．
							ここでは，親パッケージのインストールディレクトリ %I から splitoff したパッケージのインストールディレクトリ %i に
							どのファイルやディレクトリを移動するべきかを指定する．
							これが実行されるタイミングは，親パッケージの InstallScript や DocFiles に指定したコマンドの実行後で，
							splitoff したパッケージの InstallScript や Docfiles の実行前であることに注意．
						</p>
					</td></tr></table>
			<p>
				<b>ビルド段階:</b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>PreInstScript, PostInstScript, PreRmScript, PostRmScript</td><td>
						<p>
							これらのフィールドには，パッケージがインストール，アップグレード，または削除されるときに実行されるシェルスクリプトの断片を記述する．
							Fink はシェルスクリプトのヘッダ <tt style="white-space: nowrap;">#!/bin/sh</tt> を自動的に追加し，また <tt style="white-space: nowrap;">set -e</tt> を実行してくれる．
							よってどのコマンドが実行に失敗しても，スクリプトはその時点で停止する．
							また Fink は末尾に <tt style="white-space: nowrap;">exit 0</tt> を追加する．
							エラーの発生を示すには，非ゼロの終了コードでスクリプトから exit する．
							第1実引数 (<tt style="white-space: nowrap;">$1</tt>) は，どのアクションが実行されているかを示す値に設定される．
							値としては <tt style="white-space: nowrap;">install</tt>, <tt style="white-space: nowrap;">upgrade</tt>, <tt style="white-space: nowrap;">remove</tt> および <tt style="white-space: nowrap;">purge</tt> が使われ得る．
							Note that there are more values,
							used during error rollback or when removing a package in favor of another one.
						</p>
						<p>
							このスクリプトは以下のタイミングで実行される．
						</p>
						<ul>
							<li>PreInstScript: パッケージが初めてインストールされたときと，パッケージをそのバージョンにアップグレードする前．</li>
							<li>PostInstScript: パッケージの解凍後で，パッケージを設定する前．</li>
							<li>PreRmScript: パッケージが削除される前，または新しいバージョンにアップグレードされる前．</li>
							<li>PostRmScript: パッケージが削除された後，または新しいバージョンにアップグレードされた後．</li>
						</ul>
						<p>
							補足説明: アップグレードは新バージョンの ...Inst スクリプトと，旧バージョンの ...Rm スクリプトを実行する．
							詳細については the Debian Policy Manual,
							<a href="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">第6章</a> を参照．
						</p>
						<p>
							スクリプト内ではパーセント記法は展開される．
							一般に，コマンドはフルパスを指定しなくても実行できる．
						</p>
					</td></tr><tr valign="top"><td>ConfFiles</td><td>
						<p>
							ユーザが修正し得る設定ファイルの空白区切りのリスト．
							ファイルは，次のように絶対パスで指定しなければいけない．
							<tt style="white-space: nowrap;">%p/etc/foo.conf</tt>.
							dpkg はここで指定されたファイルを特別扱いする．
							パッケージがアップグレードされたとき，新設定ファイルが提供され，しかもユーザが旧パッケージの設定ファイルが修正していた場合は，
							ユーザはどちらのバージョンを使うか尋ねられ，設定ファイルのバックアップが作られる．
							パッケージを "remove" しても，設定ファイルは削除されずにディスク上に残る．
							設定ファイルも削除されるのは "purge" を命じたときのみ．
						</p>
					</td></tr><tr valign="top"><td>InfoDocs</td><td>
						<p>
							パッケージが %p/share/info にインストールする Info 文書のリスト．
							この設定により，Info ディレクトリ・ファイル <tt style="white-space: nowrap;">dir</tt> を管理するための適切なコードがスクリプト postinst および prerm に追加される．
							この機能はまだ流動的で，将来，精密な管理のためにさらにフィールドが追加されるかも知れない．
						</p>
					</td></tr><tr valign="top"><td>DaemonicFile</td><td>
						<p>
							<tt style="white-space: nowrap;">daemonic</tt> のサービスの説明を記述する．
							Fink は <tt style="white-space: nowrap;">daemonic</tt> を使ってデーモン・プロセス (web サーバ等) のための StartupItems を生成したり削除する．
							The description will added to the package as a file named <tt style="white-space: nowrap;">%p/etc/daemons/<b>name</b>.xml</tt>,
							ここで <b>name</b> はフィールド DaemonicName で指定される (デフォルト値は「パッケージ名」)．
							このフィールドの値ではパーセント記法が展開される．
							パッケージが <tt style="white-space: nowrap;">daemonic</tt> を利用するなら，依存性リストに加えなければいけないことに注意．
						</p>
					</td></tr><tr valign="top"><td>DaemonicName</td><td>
						<p>
							<tt style="white-space: nowrap;">daemonic</tt> サービスの情報記述ファイルが使う名前．
							詳細についてはフィールド DaemonicFile の説明を参照．
						</p>
					</td></tr></table>
			<p>
				<b>付加的データ: </b>
			</p>
			<table border="0" cellpadding="0" cellspacing="10"><tr valign="bottom"><th align="left">Field</th><th align="left">Value</th></tr><tr valign="top"><td>Homepage</td><td>
						<p>
							upstreamパッケージのホームページの URL．
						</p>
					</td></tr><tr valign="top"><td>DescDetail</td><td>
						<p>
							フィールド <tt style="white-space: nowrap;">Description</tt> よりも詳しい説明．
							(それが何であるか，何のために使うものか？)
							複数行に渡ってよい．
							このフィールドはワードラップの恩恵に預らずに表示されるので， (可能ならば) 手動で改行を挿入して1行を79文字以内に収めること．
						</p>
					</td></tr><tr valign="top"><td>DescUsage</td><td>
						<p>
							パッケージを利用する上で必要になる情報を記述する．
							(そのパッケージはどのように使うものなのか？)
							例えば「 WindowMaker を使う前に wmaker.inst を起動．」等を (英語で) ここに記述する．
							複数行に渡ってよい．
							このフィールドはワードラップの恩恵に預らずに表示されるので， (可能ならば) 手動で改行を挿入して1行を79文字以内に収めること．
						</p>
					</td></tr><tr valign="top"><td>DescPackaging</td><td>
						<p>
							パッケージングに関する注意書き．
							「ファイルを適切な場所に置くために Makefile にパッチを当てる」等を (英語で) ここに記述する．
							複数行に渡ってよい．
						</p>
					</td></tr><tr valign="top"><td>DescPort</td><td>
						<p>
							パッケージを Darwin に移植する場合について特有の注意書き．
							「config.guess と libtool スクリプトはアップデートする． -no-cpp-precomp が必要」等を (英語で) ここに記述する．
							複数行に渡ってよい．
						</p>
					</td></tr></table>
		

		<h3><a name="reference.splitoffs">5.3 スプリットオフ (SplitOff)</a></h3>
			
			<p>
				Fink 0.9.9 に導入．
				ひとつの .info ファイルで複数のパッケージを作成できる．
				インストール段階は普通に始まり， <tt style="white-space: nowrap;">InstallScript</tt> と <tt style="white-space: nowrap;">DocFiles</tt> コマンドを実行する．
				<tt style="white-space: nowrap;">SplitOff</tt> フィールドが存在すれば，２つ目のインストールディレクトリを作成する．
				<tt style="white-space: nowrap;">SplitOff</tt> フィールドでは，新規インストールディレクトリは %I で参照され，元のインストールディレクトリは %i で参照される．
			</p>
			<p>
				<tt style="white-space: nowrap;">SplitOff</tt> フィールドには多くのフィールドを含み，実質上，完全なパッケージ記述情報とよく似ている．
				しかし <tt style="white-space: nowrap;">SplitOff</tt> フィールドにはないフィールドもある．
				以下は <tt style="white-space: nowrap;">SplitOff</tt> に含まれる副詳細 (分野別)．
			</p>
			<ul>
				<li>
					初期データ (Initial Data):
					<tt style="white-space: nowrap;">Package</tt> のみ特定する必要があります．
					その他は全て親パッケージから引き継がれます．
					<tt style="white-space: nowrap;">Type</tt> と <tt style="white-space: nowrap;">License</tt> は <tt style="white-space: nowrap;">SplitOff</tt> 内で宣言することで変更することができます．
					パーセント拡張も使うことができます．
					特に，親パッケージの名称を参照する %N は便利です．
				</li>
				<li>依存性 (Dependency): 全てのフィールドが対象です．</li>
				<li>
					解梱段階 (Unpack Phase), パッチ段階 (Patch Phase), コンパイル段階 (Compile Phase): このフィールドは関連がないため無視されます．
				</li>
				<li>
					インストール段階 (Install Phase), ビルド段階 (Build Phase): いずれも全てのフィールドを修正可能
					(<tt style="white-space: nowrap;">SplitOff</tt> は <tt style="white-space: nowrap;">SplitOff</tt> 内では使用できない)．
				</li>
				<li>
					追加データ: 親パッケージから引き継がれるが， <tt style="white-space: nowrap;">SplitOff</tt> 内で宣言して修正できる．
				</li>
			</ul>
			<p>
				インストール段階では，まず親パッケージの <tt style="white-space: nowrap;">InstallScript</tt> と <tt style="white-space: nowrap;">DocFiles</tt> が実行されます．
				次に， <tt style="white-space: nowrap;">SplitOff</tt> フィールド内の <tt style="white-space: nowrap;">Files</tt> が実行され，
				親インストールディレクトリ %I から 現在のインストールディレクトリ %i にファイルを移し，
				<tt style="white-space: nowrap;">SplitOff</tt> パッケージ内の <tt style="white-space: nowrap;">InstallScript</tt> や <tt style="white-space: nowrap;">DocFiles</tt> などが実行されます．
			</p>
			<p>
				<tt style="white-space: nowrap;">SplitOff2</tt>, <tt style="white-space: nowrap;">SplitOff3</tt> など，さらに副パッケージが存在する場合，
				同じ順序 (<tt style="white-space: nowrap;">Files</tt>, <tt style="white-space: nowrap;">InstallScript</tt>, <tt style="white-space: nowrap;">DocFiles</tt>) で順々に実行されていきます．
			</p>
			<p>
				ビルド段階中，各パッケージの pre/post install/remove スクリプトをビルド段階コマンドを使って作成します．
			</p>
			<p>
				それぞれのパッケージは，ビルド時に %i/share/doc/%n 内にあるライセンスの同意を得る必要があります
				(%n の値は当然パッケージごとに異なります)．
				<tt style="white-space: nowrap;">DocFiles</tt> はファイルを移動ではなくコピーします．
				これにより， <tt style="white-space: nowrap;">DocFiles</tt> を使ってそれぞれのパッケージに同一のドキュメントをインストールします．
			</p>

		

		<h3><a name="reference.scripts">5.4 スクリプト</a></h3>
			

			<p>
				フィールド PatchScript, CompileScript, InstallScript には，実行させたいシェルコマンドを記述します．
				形式は2種類あります．
			</p>
			<p>
				このフィールドはコマンド一覧です．
				これは一見シェルスクリプトのようですが， system() を通して実行されます．
				一行ごとに実行し，変数の設定やディレクトリの移動はその行内でのみ有効です．
				0.18.2 以降の CVS 版では通常のシェルスクリプトと同様に長い行をバックスラッシュ (<tt style="white-space: nowrap;">\</tt>) で改行できるようになりました．
			</p>
			<p>
				または，ここには，任意のスクリプト処理系の完全なスクリプトを記述することもできる．
				その場合，他の Unix のスクリプトファイルと同様，第1行目は <tt style="white-space: nowrap;">#!</tt> にインタプリタのフルパス名を続け，
				さらに必要なフラグを続けたものでなければいけない．
				(<tt style="white-space: nowrap;">#!/bin/csh</tt>, <tt style="white-space: nowrap;">#!/bin/bash -ev</tt> 等．)
				その場合，フィールド *Script の値全体が一時ファイルにダンプされ，実行される．
			</p>
		

		<h3><a name="reference.patches">5.5 パッチ</a></h3>
			

			<p>
				パッケージを Darwin でコンパイルするために (または Fink と協調して動作するようにするために) パッチが必要な場合，
				パッケージ情報記述ファイルの拡張子 ".info" を ".patch" に変えたファイル名を使い， .info ファイルと同じディレクトリに入れる．
				パッケージファイル名に full package を使っている場合は，次のどちらかを使う (どちらも同等)．
			</p>
<pre>Patch: %f.patch</pre>
			<pre>PatchScript: patch -p1 &lt;%a/%f.patch</pre>
			<p>
				新しく導入された方の簡潔なパッケージファイル命名規則を採用しているなら， %f でなく %n を使うこと．
				これら2つのフィールドは互いに排他的ではなく，両方指定してもよい (すると PatchScript, Patch の順に両方実行される)．
			</p>
			<p>
				パッチファイルを使ってユーザがプリフィクスを選択できるようにする方がよいので，
				<tt style="white-space: nowrap;">/sw</tt> という決め打ちではなく <tt style="white-space: nowrap;">@PREFIX@</tt> 等の変数を使った方がよい．
				そして次のようにする．
			</p>
<pre>PatchScript: sed 's|@PREFIX@|%p|g' &lt;%a/%f.patch | patch -p1</pre>
			<p>
				パッチの書式は unidiff (unified diff) でなければいけない．
				普通，次のようにして生成できる．
			</p>
<pre>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</pre>
			<p>
				エディタに Emacs を使っているなら，上記のコマンド diff の引数に <tt style="white-space: nowrap;">-x'*~'</tt> を加え，
				自動生成されたバックアップファイルを比較対象から除くとよい．
			</p>
			<p>
				巨大なファイルサイズのパッチを cvs に入れるのはまずいことにも注意．
				そういうパッチは web/ftp サーバに置き，フィールド <tt style="white-space: nowrap;">SourceN:</tt> に指定する．
				自分のウェブサイトを持っていなくても， Fink プロジェクトの管理者がそのファイルを Fink のサイトそのものからダウンロードできるようにしてくれる．
				パッチが 30KB より大きければ，独立にダウンロードする方法を考慮した方がよい．
			</p>
		

		<h3><a name="reference.profile.d">5.6 Profile.d スクリプト</a></h3>
			

			<p>
				パッケージが実行時に何らかの初期化 (環境変数の設定など) を必要とするなら， profile.d スクリプトを使えばよい．
				これらのスクリプト断片はスクリプト <tt style="white-space: nowrap;">/sw/bin/init.[c]sh</tt> に読み込まれる．
				普通，全ての Fink ユーザがシェルのスタートアップファイル (<tt style="white-space: nowrap;">.cshrc</tt> またはそれと互換なファイル) でそれを読み込むはずだ．
				パッケージでは，どのスクリプトにも2種類を用意しなければいけない:
				sh 互換シェル (sh, zsh, bash, ksh, ...) 用と， csh 互換シェル (csh, tcsh) 用だ．
				それらのスクリプトは <tt style="white-space: nowrap;">/sw/etc/profile.d/%n.[c]sh</tt> としてインストールされなければいけない．
				(ここで %n は，他と同様に「パッケージ名」を表す．)
				また，それらのパーミッションは実行，読み込みが共に可能でなければいけない．
				(すなわち，それらのインストールには引数 -m 755 を付ける．)
				そうでないと正しく読み込まれないからだ．
			</p>
			<p>
				いくつかの環境変数を単に設定したいだけなら (QTDIR を '/sw' にする，など)，フィールド RuntimeVars を使えばよい．
				このフィールドはまさにその作業を簡略化するために用意されたものだ．
			</p>
		

	<hr><h2>Copyright Notice</h2><p>Copyright (c) 2001 Christoph Pfisterer,
Copyright (c) 2001-2004 The Fink Project.
You may distribute this document in print for private purposes,
provided the document and this copyright notice remain complete and
unmodified. Any commercial reproduction and any online publication
requires the explicit consent of the author.</p><hr><p>Generated from <i>$Fink: packaging.ja.xml,v 1.3 2004/03/30 03:03:07 babayoshihiko Exp $</i></p></body></html>
