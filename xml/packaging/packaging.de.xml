<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="de" >
<title>Ein Fink-Paket erstellen</title>
<shorttitle>Paket erstellen</shorttitle>
<cvsid>$Id: packaging.de.xml,v 1.1 2015/03/10 22:52:23 k-m_schindler Exp $</cvsid>

<preface>
<p>
Diese Anleitung beschreibt, wie man eine Paketbeschreibung für den Paketmanager
Fink erstellt.
Es beschreibt ebenso die Richtlinien für die Fink-Distribution.
Sowohl das Format der Paketbeschreibung als auch die Distributionspolitik sind
in Entwicklung. Achten sie also auf "Last changed"-Informationen und CVS Tipps
zu dieser Seite, wenn es um Aktualisierungen geht.
Diese Beschreibung hier bezieht sich auf Formate und Richtlinien für Version
0.9.0 und höher des Paketmanagers <tt>fink</tt>.
</p>
<p>
Beabsichtigen sie Pakete für Fink zu erstellen, ist es sinnvoll die Mailing-Liste
<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>
zu abonnieren.
Wenn sie einfach bei Fink mithelfen wollen und sie sich fit fühlen, können sie
<link url="http://pdb.finkproject.org/pdb/nomaintainer.php">ein Paket aus dieser
Liste übernehmen</link>, das derzeit ohne Betreuer ist.
</p>
</preface>

<chapter filename="intro">
<title>Einführung</title>
<shorttitle>Intro</shorttitle>

<section name="def1"><title>Was ist ein Paket?</title>
<p>
Ein Paket besteht aus Software, die eine abgeschlossene Einheit bildet. Ein
typisches Paket enthält ein Program, dafür benötigte Dateien und Kataloge mit
Meldungen für die Internationalisierung und Dokumentation. In Fink können Pakete
in zwei Formen vorliegen: Die Paketbeschreibung und die binäre, direkt
installierbare Paket-Datei.
</p>
<p>
Die Paketbeschreibung ist eine lesbare Textdatei, die alles enthält, um das
Paket zu erstellen, d. h. die binäre Paket-Datei zu erzeugen.
Die Paketbeschreibung enthält Meta-Daten (Paketnamen und Beschreibungsprosa),
die URL des Quell-Codes und die Instruktionen für die Konfiguration, das
Compilieren und das "Einpacken" des Pakets. Zu der Paketbeschreibung kann auch
eine Patch-Datei gehören.
</p>
<p>
Die binäre Paket-Datei is ein Dateiarchiv, das die eigentlichen Dateien des
Pakets enthält, also das Binärprogram, Dateien, Kataloge mit Meldungen,
Bibliotheken, Include-Dateien, usw.
Die Paket-Datei enthält auch Meta-Daten über das Paket.
Installation eines binären Pakets bedeutet im wesentlichen Auspacken des
Inhalts, weil alles bereits vorbereitet ist.
Fink nutzt den Paketmanager dpkg. Deshalb haben die binären Paket-Datei das
Format dpkg und den Datei-Suffix .deb.
</p>

</section>

<section name="ident"><title>Identifikation eines Pakets</title>
<p>
Die Identifikation eines Pakets ergibt sich aus drei Zeichnfolgen: Paketname,
Version und Revision.
Alle können Kleinbuchstaben, Zahlen, Bindestriche (nicht in der Revision),
Pluszeichen und Punkte enthalten. Andere Zeichen sind nicht erlaubt.
Insbesondere Großbuchstaben und Unterstriche sind nicht erlaubt.
</p>
<p>
Der Paketname is einfach der Name der Software, z. B. openssh.
Die Version, auch Upstream-Version genannt, ist die Version des ursprünglichen
Software-Pakets.
Buchstaben sind in der Version erlaubt, z. B. 2.9p1.
Sowohl fink als auch dpkg wissen, wie man diese richtig sortiert.
Die Revision ist ein Zähler, der erhöht wird, wenn sich die Paketbeschreibung
ändert.
Sie beginnt mit 1 und sollte auf 1 zurückgesetzt werden, wenn sich die
Upstream-Version ändert.
Die Revision darf keine Bindestriche enthalten.
Der vollständige Name ergibt sich aus der Verkettung der drei mit Bindestrichen
dazwischen, z. B. openssh-2.9p1-2.
</p>

</section>

</chapter>

<chapter filename="format">
<title>Paketbeschreibungen</title>
<shorttitle>Paketbeschreibungen</shorttitle>

<section name="trees"><title>Baum Layout</title>
<p>
Paketbeschreibungen werden aus dem Verzeichnis <code>finkinfo</code> gelesen,
der sich im Verzeichnis <filename>/sw/fink/dists</filename> befindet. Die
Einstellung "Trees" in der Datei <filename>/sw/etc/fink.conf</filename>
bestimmt, welche Verzeichnisse gelesen werden.
Der Name der Paketbeschreibungsdatei besteht aus dem vollständigen Paketnamen
und dem Suffix ".info".
Ab fink 0.26.0 gibt es mehre Möglichkeiten für den Dateinamen: Empfohlen wird
der kürzeste Name, der konsistent mit anderen Paketen ist, die benötigt werden.
Der Dateiname hat folgende Form: der unveränderliche Paketname, optional die
Architektur, optional die Distribution, optional Version oder Version-Revision,
alle durch Bindestriche getrennt und abgeschlossen mit ".info".
Die Komponenten "Architektur" und "Distribution" sind nur erlaubt, wenn die
entsprechenden Felder auch in der Beschreibung vorkommen und exakt einen Wert
zugewiesen haben.
</p>
<p>
Der Baum der Paketveschreibungen ist in mehreren Ebenen von Verzeichnissen
organisiert. Die Verzeichnisse von oben nach unten:
</p>
<ul>
<li><code>dists</code> ist der Anfang. Das Verzeichnis <code>dists</code>
  wird für die Debian Tools benötigt. In neueren Version von fink ist dies ein
  Symlink zu einem Verzeichnis mit einem distributionsbezogenem Namen.</li>
<li>Die Distributionen. Es gibt <code>stable</code>, <code>unstable</code> und
  <code>local</code>. Das Verzeichnis <code>local</code> wird vom lokalen
  Administrator/Nutzer verwaltet. Die Verzeichnisse <code>stable</code> und
  <code>unstable</code> gehören Fink.</li>
<li>Der Baum. Der Baum enthält die meisten Pakete. Vor dem 1. Juli 2010 wurde
  cryptographische Software in einem separaten Baum namens <code>crypto</code>
  gehalten. Aber jetzt sind diese Pakete auch im Baum <code>main</code>.</li>
<li><code>finkinfo</code>vs. <code>binary-darwin-powerpc</code>.
  <code>finkinfo</code> enthält die Fink-Paketbeschreibungen und Patch-Dateien,
  während das Verzeichnis <code>binary-darwin-powerpc</code> die binären
  <code>.deb</code> Pakete enthält.</li>
<li>Sections. Das Verzeichnis <code>main</code> ist weiter thematisch
  unterteilt, damit es handhabbar bleibt.</li>
</ul>

</section>

<section name="format"><title>Datei-Format</title>
<p>
Die Paketbeschreibungsdateien sind einfache Listen von Schlüssel-Wert-Paaren,
auch Felder genannt.
Jede Zeile beginnt mit einem Schlüssel, der mit einem Doppelpunkt (:)
abgeschlossen wird. Darauf folgt direkt der Wert, also so:
</p>
<codeblock>Schlüssel: Wert</codeblock>
<p>
Es gibt zwei Schreibweisen für Felder, die sich über mehrere Zeilen
erstrecken.
</p>
<p>
Die bevorzugte Schreibweise is so wie die here-document-Syntax in
Shell-Skripten. Bei dieser Syntax beginnt die erste Zeile mit dem Schlüssel,
gefolgt von <code>&lt;&lt;</code> als Wert.
Alle nachfolgenden Zeilen werden als eigentlicher Wert behandelt bis eine Zeile
folgt, die nur <code>&lt;&lt;</code> enthält.
Das Beispiel von oben sieht nun so aus:
</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>
Einrückungen in diesem Format sind optional, können aber für eine erhöhte
Lesbarkeit verwendet werden.
</p>
<p>
Die here-document-Syntax kann verschachtelt sein. Dies wird oft in den Feldern
<code>SplitOff</code> oder <code>SplitOff<em>N</em></code> verwendet.
Diese Felder enthalten weitere Felder (mehrere Zeilen) und diese Syntax erlaubt,
dass auch diese Unterfelder ihrerseits mehrere Zeilen hat. Derselbe Abschluss
mit <code>&lt;&lt;</code> wird bei dem sub-here-document benutzt.
Hier ein Beispiel:
</p>
<codeblock>SplitOff: &lt;&lt;
  Package: %N-shlibs
  InstallScript: &lt;&lt;
    ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
  &lt;&lt;
&lt;&lt;</codeblock>
<p>
In diesem Format werden Leerzeilen und Zeilen mit einem Hash (#) am Zeilenanfang
ignoriert. Groß-und Kleinschreibung wird beim Schlüssel (Feldnamen) nicht
beachtet, d. h. man kann <code>InstallScript</code>, <code>installscript</code>
oder <code>INSTALLSCRIPT</code>schreiben, wie man will. Allerdings wird die
erste Form mit Großbuchstaben wegen Lesbarkeit empfohlen.
Einige Felder akzeptieren boolesche Werte. Hier werden "true", "yes", "on" und
"1" (auch in Großschreibung) als wahr interpretiert, alle anderen Werte als
falsch.
</p>

</section>

<section name="percent"><title>Prozent-Erweiterungen</title>
<p>
Zur Vereinfachung unterstützt Fink einen Satz an Erweiterungen, die in einigen
Feldern angewendet werden.
Mehrdeutigkeiten kann man verhinder, indem man mit geschweiften Klammern genau
anzeigt, welche Buchstaben für eine Prozent-Erweiterung genommen werden sollen.
<code>%{n}</code> hat zum Beispiel die gleiche Bedeutung wie <code>%n</code>.
Folgende Erweiterungen stehen zur Verfügung:
</p>
<itemtable labeld="" labelt="">
<item><itemt>%n</itemt>
<itemd>
<p>Der <em>n</em>ame des Pakets</p>
</itemd></item>

<item><itemt>%N</itemt>
<itemd>
<p>
Der <em>N</em>ame des Elternpakets (der selbe wie %n außer innerhalb eines
<code>SplitOff</code>)
</p>
<p>
Anmerkung: Wenn ein Eltern-<code>Paket</code>-Feld %type_*[] enthält, dann
<em>werden</em> die Werte der Prozent-Erweiterung in %N in einem
<code>SplitOff</code>-Block mit eingeschlossen. (Schließlich sind sie Teil von
%n bei den Eltern.)
</p>
</itemd></item>

<item><itemt>%e</itemt>
<itemd>
<p>Die <em>e</em>poche des Pakets</p>
</itemd></item>

<item><itemt>%v</itemt>
<itemd>
<p>
Die <em>v</em>ersion des Pakets. Beachten sie, dass die Epoche nicht zu
<code>%v</code> gehört.
</p>
</itemd></item>

<item><itemt>%V</itemt>
<itemd>
<p>
Die vollständige <em>V</em>ersion des Pakets, die automatisch die Epoche
enthält, wenn vorhanden. Beachten sie, dass diese Prozent-Erweiterung nur für
Pakete zur Verfügung steht, deren <code>InfoN</code>-Ebene mindestens 4 ist.
</p>
</itemd></item>

<item><itemt>%r</itemt>
<itemd>
<p>Die <em>r</em>evision des Pakets</p>
</itemd></item>

<item><itemt>%f</itemt>
<itemd>
<p>
Der vollständige (<em>f</em>ull) Paketname (%n-%v-%r). Beachten sie, dass die
Epoche nicht zu <code>%f</code> gehört.
</p>
</itemd></item>

<item><itemt>%p, %P</itemt>
<itemd>
<p>
Der <em>p</em>refix wo fink installiert ist, also <filename>/sw</filename>.
Sie dürfen nicht annehmen, dass alle Nutzer Fink in <filename>/sw</filename>
installiert haben, nutzen sie immer <code>%p</code> für den korrekten Pfad.
</p>
</itemd></item>

<item><itemt>%d</itemt>
<itemd>
<p>
Im Verzeichnis <em>d</em>estination wird der Baum für ein Paket erstellt, z. B.
in <filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename>. Dieses
temporäre Verzeichnis dient als Wurzelverzeichnis während der Installationsphase
beim Compilieren eines Pakets. Sie sollten nicht annehmen, dass
<filename>root-%f</filename> in <filename>%p/src</filename> ist, denn ein Nutzer
kann dieses Verzeichnis mit dem Feld <code>Buildpath</code> in der Datei
<filename>/sw/etc/fink.conf</filename> ändern.
</p>
</itemd></item>

<item><itemt>%D</itemt>
<itemd>
<p>
Das Verzeichnis <em>D</em>estination für das Elternpaket (das selbe wie %d außer
innerhalb eines <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%i</itemt>
<itemd>
<p>Der vollständige <em>i</em>nstall-phase-Präfix, äquivalent zu %d%p</p>
</itemd></item>

<item><itemt>%I</itemt>
<itemd>
<p>
Der <em>I</em>nstall-Präfix des Elternpakets, äquivalent zu %D%P (das selbe wie
%i außer innerhalb eines <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%a</itemt>
<itemd>
<p>
Der Pfad, wo sich die P<em>a</em>tches befinden. Ab fink-0.29.0 sollte diese
Variable nicht mehr benutzt werden. Nutzen sie <code>%{PatchFile}</code>, um auf
die <filename>.patch</filename>-Datei zuzugreifen. Die Unterstützung für
<code>%a</code> wird in der Zukunft entfernt werden.
</p>
</itemd></item>

<item><itemt>%b</itemt>
<itemd>
<p>
Das Verzeichnis <em>b</em>uild, also
<filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>.
Sie sollten nicht annehmen, dass sich <filename>%f</filename> in
<filename>%p/src</filename> befindent, denn ein Nutzer kann dieses Verzeichnis
über das Feld <code>Buildpath</code> in der Datei
<filename>/sw/etc/fink.conf</filename> ändern.
Das innerste Verzeichnis wird nach dem Dateinamen der
<code>Quelle</code> benannt oder dem Wert des Felds <code>SourceDirectory</code>
(falls vorhanden) oder wird nicht verwendet wenn das Feld
<code>NoSourceDirectory</code> auf <code>true</code> gesetzt ist.
</p>
<p>
Anmerkung: Nutzen sie dies nur, wenn es gar nicht anders geht. Das Verzeichnis
build ist das aktuelle Verzeichnis, wenn Skripte ausgeführt werden; sie sollten
in Kommandos relative Pfadnamen verwenden.
</p>
</itemd></item>

<item><itemt>%c</itemt>
<itemd>
<p>
Die <em>c</em>onfigure Parameter: <code>--prefix=%p</code> plus alles, was mit
ConfigureParams angegeben wurde. (Das Verhalten ist anders, wenn das Paket das
Feld <code>Type: perl</code> gesetzt hat. In diesem Fall werden die
Voreinstellungen für das Erstellen von Perl-Paketen anstatt von
<code>--prefix=%p</code> in der Definition von <code>%c</code> verwendet.)
</p>
</itemd></item>

<item><itemt>%m</itemt>
<itemd>
<p>
Die Zeichenfolge für die Architektur der <em>m</em>achine. Dies ist nicht länger
durch den Typ der Maschine bestimmt, sondern eine Wahl des Nutzers bei der
Installation zwischen den Architekturen, die auf der Hardware des Nutzers
laufen können. Mögliche Werte sind 'powerpc' für PowerPC-Macs und 'i386' oder
'x86_64' für Intel-Macs. Die Auswahl 'x86_64' steht auf Intel-Macs nur zur
Verfügung, wenn der Mac 64-bit Bibliotheken und Programme ausführen kann.
(Dieser Werf wurde etwa in fink-0.12 eingeführt, die aktuellen Beschreibung gilt
für fink-0.29.5 und später.)
</p>
</itemd></item>

<item><itemt>%%</itemt>
<itemd>
<p>
Das Zeichen Prozent (Ein Zeichen, das nicht erweitert wird, was auch immer
danach folgt). Die Erweiterung erfolgt streng von links nach rechts. Damit hat
%%n nichts mit dem Paketnamen zu tun, sondern bedeutet die Zeichenfolge %n. (In
fink-0.18.0 eingeführt)
</p>
</itemd></item>

<item><itemt>%type_raw[<em>type</em>], %type_pkg[<em>type</em>],
%type_num[<em>type</em>]</itemt>
<itemd>
<p>
pseudo-hashes, die den Subtyp für den angegebenen <em>type</em> zurückgeben.
Lesen sie die Dokumentation für das Feld <code>Type</code> weiter unten in
diesem Dokument. Die Form _raw ist die exakte Zeichenfolge des Subtyps, während
bei der Form _pkg alle Punkte entfernt wurden (entsprechend Finks Konventionen
für Paketnamen mit Sprachversionen und andere kluge Verwendungen). (Eingeführt
in einer post-0.19.2 CVS-Version von Fink.) Die Form -num wurde in fink-0.26.0
eingeführt und entfernt alle Zeichen außer Zahlen aus dem Feld <code>Type</code>.
</p>
<p>
Beachten sie, dass <code>(%type_pkg[type])</code> direkt als Bedingung verwendet
werden kann, wenn das Feld <code>Type</code> den <em>type</em> als "Boolean"
deklariert. (Der boolesche Wert ist wahr oder falsch, je nachdem wie der
Subtype ausgerechnet wird.)
</p>
</itemd></item>

<item><itemt>%{ni}, %{Ni}</itemt>
<itemd>
<p>
Der <em>i</em>nvariante Teil des Paket<em>n</em>amens. Sie sind wie %n and %N,
außer dass alle Teile von %type_pkg[] und %type_raw[] gelöscht sind.
(Eingeführt in einer post-0.19.2 CVS-Version von fink) Sie sollten %{ni} und
%{Ni} verwenden, um Verwechslungen mit den Erweiterungen %n und %N zu verhindern.
</p>
</itemd></item>

<item><itemt>%{default_script}</itemt>
<itemd>
<p>
Nur in den Feldern <code>PatchScript</code>, <code>CompileScript</code> und
<code>InstallScript</code> gültig. Es enthält den voreingestellten Inhalt dieser
Felder. Der Wert hängt oft vom Feld <code>Type</code> ab und ist immer definiert
(Er kann aber leer sein). Wird diese Erweiterung im <code>InstallScript</code>
eines <code>SplitOff</code> (oder <code>SplitOff<em>N</em></code>) verwendet,
gibt sie die Voreinstellung der Eltern zurück, selbst wenn die Voreinstellung
für das <code>InstallScript</code> in einem <code>SplitOff</code>-Paket leer
ist. (Eingeführt in fink-0.20.6)
</p>
</itemd></item>

<item><itemt>%{PatchFile}</itemt>
<itemd>
<p>
Der vollständige Pfad zu der Datei, die im Feld <code>PatchFile</code> angegeben
ist. (Eingeführt in fink-0.24.12)
</p>
</itemd></item>

<item><itemt>%{PatchFile<em>N</em>}</itemt>
<itemd>
<p>
Der vollständige Pfad zu der Datei, die im Feld <code>PatchFile<em>N</em></code>
angegeben ist. (Eingeführt in fink-0.30.0)
</p>
</itemd></item>

<item><itemt>%lib</itemt>
<itemd>
<p>
Ist der <code>Type: -64bit</code> als <code>-64bit</code> definiert, wird dies
unter der PowerPC-Architektur zu <em>lib/ppc64</em> erweitert und zu
<em>lib/x86_64</em> unter der i386-Architektur (Der korrekte Speicherort für
64-bit Bibliotheken auf einem 32-bit System); anderfalls wird es zu <em>lib</em>
erweitert. (Eingeführt in fink-0.26.0)
</p>
<p>
Beachten sie, dass <code>%lib</code> im Feld <code>ConfigureParams</code>
nicht erlaubt ist, außer wenn die <code>InfoN</code>-Ebene mindestens 4 ist.
</p>
</itemd></item>
</itemtable>

</section>

</chapter>

<chapter filename="policy">
<title>Richtlinien zur Estellung von Paketen</title>
<shorttitle>Richtlinien</shorttitle>

<section name="licenses"><title>Paket-Lizenzen</title>
<p>
Die Pakete in Fink stehen unter sehr verschiedenen Lizenzen.
Die meisten beinhalten Restriktionen im Hinblick auf Weiterverteilung der
kompletten Quellen und vor allem der Binärprogramme.
Einige Pakete können wegen solcher Restriktionen nicht Teil von Finks
Binär-Distribution sein.
Deshalb ist es sehr wichtig, dass man als Betreuer eines Pakets die Lizenzen
seines Pakets sorgfältig prüft.
</p>
<p>
Jedes Paket, das als Binärpaket verteilt werden soll, muss eine Kopie der Lizenz
enthalten.
Die Kopie muss im Verzeichnis doc installiert werden,
also in <filename>%p/share/doc/%n</filename>.
(Im InstallScript muss natürlich %i anstelle von %p verwendet werden.
Das Feld DocFiles erledigt dies automatisch.)
Gibt es keine explizite Lizenz in den originalen Quellen, fügen sie eine
kleine Textdatei bei, in der sie die Situation des pakets beschreiben.
Die meisten Lizenzen verlangen, dass jede Distribution die Lizenz enthält.
Finks Richtlinien ist, dies immer zu tun, auch wenn es nicht explizit verlangt
wird.
</p>
<p>
Für die automatische Verwaltung der binären Distributions ist es erforderlich,
dass jedes Paket, das damit verteilt werden soll, auch das Feld
<code>License</code> gesetzt hat.
Dieses Feld beschreibt die Art der Lizenz und entscheidet darüber, ob ein
Paket in die binäre Distribution aufgenommen wird oder zurück gehalten wird.
Das Feld soll auch nur präsent sein, wenn das binäre Paket auch den eigentlichen
Text der Lizenz enthält, wie oben beschrieben.
</p>
<p>
Das Feld <code>License</code> ist nur brauchbar, wenn einer der folgenden
vordefinierten Werte benutzt wird.
Erstellen sie ein Paket, das nicht in eine dieser Kategorien fällt, dann fragen
sie auf der developer Mailing-Liste um Hilfe.
</p>
<ul>
<li><code>GPL</code> - die GNU General Public Lizenz.
  Diese Lizenz verlangt, dass der Quell-Code am selben Ort wie das Programm
  zur Verfügung steht.</li>
<li><code>LGPL</code> - die GNU Lesser General Public Lizenz.
  Diese Lizenz verlangt, dass der Quell-Code am selben Ort wie das Programm
  zur Verfügung steht.</li>
<li><code>GPL/LGPL</code> - Dies ist ein Spezialfall für Pakete, bei denen ein
  Teil (z. B. das Programm) unter der GPL steht und ein anderer Teil (z. B. die
  Bibliothek) unter der LGPL steht.</li>
<li><code>BSD</code> - für Lizenzen im BSD-Stil.
  Sie umfasst die sogenannte "originale" BSD-Lizenz, die "modifizierte"
  BSD-Lizenz und die MIT-Lizenz. Auch die Apache-Lizenz zählt als BSD-Lizenz.
  Die Distribution der Quellen ist bei diesen Lizenzen optional.</li>
<li><code>Artistic</code> - für die Artistic-Lizenz und davon abgeleitete.</li>
<li><code>Artistic/GPL</code> - Duale Lizenz nach Artistic und GPL.</li>
<li><code>GNU Free Documentation Lizenz</code> und <code>Linux Documentation
  Project</code> - steht die Dokumentation zu einem Paket explizit unter einer
  dieser Lizenzen, dann hängen sie <code>/GFDL</code> oder <code>/LDP</code> an.
  Das ergibt eine der folgenden Kombinationen: "GFDL", "GPL/GFDL", "LGPL/GFDL",
  "GPL/LGPL/GFDL", "LDP" oder "GPL/LGPL/LDP".
</li>
<li><code>DFSG-Approved</code> - für Software, die folgende Richtlinien einhält:
  <link url="http://www.debian.org/social_contract">Debian Social
  Contract</link>.
</li>
<li><code>OSI-Approved</code> - für andere Open-Source-Lizenzen, die von
  folgender Initiative akzeptiert wurde:
  <link url="http://www.opensource.org/">Open Source Initiative</link>
  Eine der Bedingungen von OSI ist, dass die Verteilung von Binärprogrammen und
  Quellen frei erlaubt ist. Dieser Wert kann auch als Schirm für Pakete mit
  Doppellizenz verwendet werden.</li>
<li><code>Restrictive</code> - für einschränkende Lizenzen.
  Benutzen sie diese Lizenz für Pakete, die man von ihren Autoren als Quell-Code
  zur freien Benutzung erhalten kann, aber nicht frei verteilen darf.</li>
<li><code>Restrictive/Distributable</code> - für einschränkende Lizenzen, die
  aber die Verteilung von Quellen und Binärprogrammen erlauben.
  Benutzen sie diese Lizenz für Pakete, die man von ihren Autoren als Quell-Code
  zur freien Benutzung erhalten kann und auch die Verteilung von Quell-Code und
  Binärprogramm erlauben, aber sonstige Einschränkungen haben, die sie zu
  non-open-source-Lizenzen machen.</li>
<li><code>Commercial</code> - für einschränkende, kommerzielle Lizenzen.
  Benutzen sie diese Lizenz für kommerzielle Pakete (z. B. Freeware oder
  Shareware), die die freie Verteilung von Quell-Code oder BinärProgrammen
  nicht zulassen.</li>
<li><code>Public Domain</code> - für Pakete, die Gemeingut sind, d. h. deren
  Autoren ihr Urheberrecht an dem Code aufgegeben haben. Diese Pakete haben
  überhaupt keine Lizenz und jeder kann damit machen, was er will.</li>
</ul>

</section>

<section name="openssl"><title>Die GPL und OpenSSL</title>
<p>(Änderung der Richtlinien ab April 2005.)</p>
<p>
Wegen einer offensichtlichen Inkompatibilität zwischen der OpenSSL-Lizenz und
den GPL- und LGPL-Lizenzen werden Pakete, die OpenSSL-Bibliotheken linken aber
unter der GPL- oder LGPL-Lizenz stehen, als "Restrictive" klassiert. Als
Konsequenz davon wird das Fink-Projekt solche Pakete nicht als Binär-Pakete
anbieten, obwohl es Nutzern frei steht, die Pakete aus den Quellen zu erstellen.
</p>
<p>
Paket-Betreuer sind aufgefordert, die Original-Lizenz des Pakets im Feld
<code>DescPackaging</code> zu vermerken.
</p>

</section>

<section name="prefix"><title>Störungen des Basis-Systems</title>
<p>
Fink ist eine zusätzliche Distribution, die in einem extra Verzeichnis, getrennt
vom Basis-System (OS X) installiert wird.
Es ist von von entscheidender Bedeutung, dass ein Paket keine Dateien außerhalb
von Finks Verzeichnis installiert.
</p>
<p>
Ausnahmen können nur dann gemacht werden, wenn es wirklich nicht anders möglich
ist, z. B. bei XFree86.
In diesen Fällen muss das Paket vor der Installation überprüfen, ob Dateien
vorhanden sind und die Installation verweigern, wenn es vorhandene Dateien
überschreiben würde.
Das Paket muss auch sicher stellen, dass alle Dateien, die außerhalb von Finks
Verzeichnis installiert werden, auch wieder gelöscht werden, wenn das Paket
entfernt wird oder dass sie keinen Schaden verursachen, wenn sie verbleiben (d.
h., dass sie die Präsenz von Programmen überprüfen müssen, bevor sie sie
aufrufen und ähnliches).
</p>

</section>

<section name="sharedlibs"><title>Dynamische Bibliotheken</title>
<p>
Im Februar 2002 traten Finks Richtlinien zu dynamischen Bibliotheken in Kraft.
Dieser Abschnitt der Dokumentation beschreibt die Version 4 dieser Richtlinien
(die mit der Veröffentlichung von Finks 0.5.0 Distribution zusammen fällt.), wie
im Dezember 2006 modifiziert um 64-bit Bibliotheken und im Januar 2008 um
private Bibliotheken zu behandeln. (Außerdem wurde die Diskussion im Juni 2008
aktualisiert, um veraltete Referenzen zu löschen, die aus einer Übergangszeit
stammte, in der die Richtlinien zu dynamischen Bibliotheken implementiert
wurde.) Wir beginnen mit einer kurzen Zusammenfassung und werden die Details
danach diskutieren.
</p>
<p>
Jedes Paket, das dynamische Bibliotheken erstellt, sollte Finks Richtlinien dazu
einhalten. Das bedeutet:
</p>
<ul>
<li>Überprüfen sie mit <code>otool -L</code> (oder <code>otool64 -L</code> für
    64-bit Bibliotheken auf 10.4) dass der install_name jeder Bibliothek und die
    aktuelle Versionsnummer korrekt sind.</li>
<li>Verschieben sie alle öffentlichen dynamischen Bibliotheken gehören in ein
  extra Paket (außer den Links von der libfoo.dylib auf den install_name) und
  fügen sie in diesem Paket das Feld <code>Shlibs</code> hinzu.</li>
<li>Verschieben die Header-Dateien und die finalen Links von der libfoo.dylib in
  ein Paket, das als <code>BuildDependsOnly: True</code> klassifiziert ist und
  planen sie, dass kein anderes Paket von diesem abhängt.</li>
</ul>
<p>
Beachten sie bitte, dass ein Paket auch private dynamische Bibliotheken
installieren kann, die nicht von andern Paketen verlinkt werden sollen. In
diesem Fall müssen die Bibliotheken in ein extra Paket, das aver ebenfalls
das Feld <code>Shlibs</code> haben muss. Außerdem sollte man vermeiden, einen
finalen Link von der libfoo.dylib in das Haupt-Bibliotheksverszeichnis
<filename>%i/lib</filename> (oder seinem 64-bit Äquivalenz) zu legen. So soll
verhindert werden, dass diese Bibliothek unabsichtlich verlinkt wird.
</p>
<p>
Sollte ein Paketbetreuer gute Gründe haben, von dieser Richtlinie abzuweichen,
sollten diese im Feld <code>DescPackaging:</code> eingetragen werden.
</p>
<p>
Für einige Pakete kann alles mit einem Hauptpaket und einem -shlibs-Paket gelöst
werden. In anderen Fällen braucht man noch mindestens ein drittes Paket. Mit dem
neuen Feld <code>SplitOff</code> geht das recht leicht.
</p>
<p>
Werden drei Pakete benötigt, kann man sie auf zwei Arten benennen, je nachdem ob
die Bibliotheken (Option 1) oder die Binärprogramme (Option 2) das wichtigste am
Paket sind. Bei Option 1 sieht das Layout so aus:
</p>
<itemtable labeld="Contents" labelt="Package">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Dynamische Bibliotheken</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>Header-Dateien</p></itemd></item>
<item><itemt><code>foo-bin</code></itemt>
<itemd><p>Binärprogramme, usw.</p></itemd></item>
</itemtable>

<p>während bei Option 2 das Layout so aussieht:</p>
<itemtable labeld="Contents" labelt="Package">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Dynamische Bibliotheken</p></itemd></item>
<item><itemt><code>foo-dev</code></itemt>
<itemd><p>Header-Dateien</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>Binärprogramme, usw.</p></itemd></item>
</itemtable>

<p><em>Die Richtlinien im Detail</em></p>
<p>
Wir werden nun die Dinge im Detail diskutieren. Als Beispiel können sie sich
die Pakete libpng, libjpeg und libtiff anschauen.
</p>
<p>
Software, die nach Darwin oder OS X portiert wird, sollte wenn immer auch
möglich dynamische Bibliotheken erstellen. (Paketbetreuern steht es frei, auch
statische Bibliotheken zu erstellen, wenn das für ihr Paket angemessen ist oder
auch ein Paket zu erstellen, das nur statische Bibliotheken enthält.)
Immer wenn dynamische Bibliotheken erzeugt werden, von denen man erwartet, dass
sie von anderen Paketen benutzt werden, sollten <em>zwei</em> Pakete mit den
Namen foo und foo-shlibs erstellt werden. Die dynamische Bibliotheke gehört in
foo-shlibs und die Header-Dateien in foo. Beide Pakete können in einer Datei
foo.info mit Hilfe des Felds <code>SplitOff</code> erzeugt werden, wie weiter
unten beschrieben.
(Tatsächlich müssen oft mehr als zwei Pakete aus den Quellen erzeugt werden. Das
kann leicht über die Felder <code>SplitOff2</code>, <code>SplitOff3</code> usw.
erreicht werden.)
</p>
<p>
Jedes Softwarepaket mit dynamischen Bibliotheken braucht eine
<em>Hauptversionsnummer</em> N, die in den Namen der Bibliothek eingefügt wird
(z. B. <filename>libbar.N.dylib</filename>).
Diese Hauptversionsnummer soll sich nur ändern, wenn sich die API der
Bibliothek so ändert, dass sie nicht mehr rückwärts-kompatibel ist. Fink benutzt
folgende Konvention für die Namensgebung: Ist der Upstream-Name bar, erhalten
die Fink-Pakete die namen barN und barN-shlibs. (Diese Regel gilt streng nur für
neue Pakete und Pakete, bei denen sich die Hauptversionsnummer ändert.) Ist z.
B. die Hauptversionsnummer des vorliegenden Pakets libpng eine 2 und die Nummer
der neuen Version eine 3, dann macht man daraus folgende vier Pakete: libpng,
libpng-shlibs, libpng3 und libpng3-shlibs.
Nur jeweils eines der Pakete libpng oder libpng3 kann installiert sein.
(Beachte, dass nur zwei2 .info-Dateien für die vier Pakete benötigt werden.)
</p>
<p>
Die eigentliche dynamische Bibliothek und einige dazu gehörige Dateien kommen
in das Paket barN-shlibs. Die "include" und andere Dateien kommen in das Paket
barN. Diese beiden Paketen haben keine gemeinsamen Dateien und alle Dateien in
barN-shlibs müssen die Hauptversionsnummer in Namen ihres Pfades haben. In
vielen Fällen braucht das Paket zur Laufzeit Dateien, die typischerweise in
<filename>%i/lib/bar/</filename> oder <filename>%i/share/bar/</filename>
installiert sind. Sie sollten deshalb die Installationspfade auf
<filename>%i/lib/bar/N/</filename> oder <filename>%i/share/bar/N/</filename>
einstellen.
</p>
<p>
Alle anderen Pakete, die von bar mit der Hauptversionsnummer N abhängen,
brauchen folgende Felder:
</p>
<codeblock>  Depends: barN-shlibs
  BuildDepends: barN</codeblock>
<p>
Es ist für andere Pakete nicht erlaubt, direkt von barN abzuhängen. (Auch wenn
es noch einige Pakete mit solchen Abhängigkeiten aus der Zeit vor Februar 2002
geben kann). Dies wird in der Paketbeschreibung von barN mit dem boolschen Feld
BuildDependsOnly an die Betreuer anderer Pakete signalisiert:
</p>
<codeblock>  BuildDependsOnly: True</codeblock>
<p>
Enthält ihr Paket sowohl dynamische Bibliotheken und Binärdateien und die
Binärdateien werden zur Laufzeit benötigt und nicht nur bei der Erzeugung des
Pakets, dann müssen die Binärdateien zusätzlich zum Paket barN-shlibs in ein
drittes Paket mit dem Namen barN-bin gepackt werden.
</p>
<p>
Erstellt man eine dynamische Bibliothek mit der Hauptversionsnummer N, ist es
wichtig, dass der "install_name" der Bibliothek
<filename>%p/lib/libbar.N.dylib</filename> ist. (Sie können den "install_name"
mit dem Befehl <code>otool -L</code> oder <code>otool64 -L</code> für 64-bit
Bibliotheken auf 10.4 heraus finden.) Die tatsächliche Bibliothek kann an einer
anderen Stelle installiert sein.
</p>
<codeblock>  %i/lib/libbar.N.x.y.dylib</codeblock>
<p>und ihr Paket erzeugt symbolische Links:</p>
<codeblock>  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib</codeblock>
<p>
aus dem install_name-Pfad und vom linking-Pfad zu der tatsächlichen
Bibliothek. (Das erste wird nicht benötigt, wenn die Bibliotheke tatsächlich
beim install_name-Pfad installiert ist, was zunehmend der Fall ist.)
</p>
<p>Wird auch eine statische Bibliothek erzeugt, wird sie hier installiert:</p>
<codeblock>  %i/lib/libbar.a</codeblock>
<p>
Verwendet das Paket libtool, wird dies alles automatisch erledigt, aber man
sollte auf jeden Fall überprüfen, dass dies auch korrekt gemacht wurde. Sie
sollten auch überprüfen, ob die current_version und die compatibility_version
für ihre dynamischen Bibliotheken richtig definiert wurden. (Diese werden
ebenso mit den Abfragen <code>otool -L</code> oder <code>otool64 -L</code> für
64-bit Bibliotheken angezeigt.)
</p>
<p>Die Dateien wird wie folgt zwischen den beiden Paketen aufgeteilt:</p>
<ul>
<li>im Paket barN-shlibs:
<codeblock>  %i/lib/libbar.N.x.y.dylib
  %i/lib/libbar.N.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/bar/N/*
  %i/share/bar/N/*
  %i/share/doc/barN-shlibs/*</codeblock></li>
<li>im Paket barN:
<codeblock>  %i/include/*
  %i/lib/libbar.dylib -> %p/lib/libbar.N.x.y.dylib
  %i/lib/libbar.a
  %i/share/doc/barN/*
  andere Dateien, falls vorhanden</codeblock></li>
</ul>
<p>
Beachten sie, dass beide Pakete die Dokumentation zu ihren Lizenzen benötigen,
die Verzeichnisse mit den DocFiles aber unterschiedlich sind.
</p>
<p>
Das macht man in der Praxis am einfachsten mit dem Feld <code>SplitOff</code>.
Das folgende Beispiel zeigt die wichtigsten Teile:
</p>
<codeblock>Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/libbar.N.x.y.dylib lib/libbar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;</codeblock>
<p>
Bei der Bearbeitung des Felds <code>SplitOff</code> werden die angegebenen
Dateien und Verzeichnisse aus dem Installationsverzeichnis %I des Hauptpakets in
das Installationsverzeichnis %i des SplitOff-Pakets verschoben. (Die Konvention
für Namen ist ähnlich: %N ist der Name des Hauptpakets und %n der Name des
aktuellen Pakets.)
Das Feld/Kommando <code>DocFiles</code> kopiert die Dokumentationsdateien in das
Verzeichnis <filename>%i/share/doc/barN-shlibs</filename>.
</p>
<p>
Beachten sie, dass die exakte Version von barN-shlibs als Abhängigkeit im
Hauptpaket barN steht (das mit %N-shlibs (= %v-%r) abgekürzt werden kann).
Damit wird sicher gestellt, dass die Versionen passen und dass das Paket barN
automatisch alle Abhängigkeiten von barN-shlibs "erbt".
</p>
<p><em>Das Feld BuildDependsOnly</em></p>
<p>
Werden Bibliotheken im Laufe der Zeit aktualisiert, ist es oft notwendig, zwei
Versionen der Header-Dateien während der Übergangsphase zur Verfügung zu haben.
Eine Version für das Übersetzen von dem einen und eine für das Übersetzen von
etwas anderem. Deshalb muss man bei der Erstellung der Pakete etwas aufpassen.
Enthalten die Pakete foo-dev und bar-dev überlappende Header, dann muss in
foo-dev folgendes deklariert werden:
</p>
<codeblock>  Conflicts: bar-dev
  Replaces: bar-dev</codeblock>
<p>und genau so, aber umgekehrt, in bar-dev.</p>
<p>Darüber hinaus sollten beide Pakete das Feld BuildDependsOnly gesetzt haben</p>
<codeblock>  BuildDependsOnly: True</codeblock>
<p>
Dies verhindert, dass man Pakete erstellt, die von foo-dev oder bar-dev
abhängen, denn so etwas würde das problemlose Funktionieren des Methode
Conflicts/Replaces verhindern.
</p>
<p>
Es gibt manche Pakete mit Header-Dateien, für die es nicht in Ordnung ist,
BuildDependsOnly als wahr zu setzen. In diesen Fällen sollten sie das Feld
explizit auf falsch setzen:
</p>
<codeblock>  BuildDependsOnly: False</codeblock>
<p>und den Grund dafür im Feld DescPackaging angeben.</p>
<p>
Das Feld BuildDependsOnly sollte nur bei solchen Paketen stehen, die
Header-Dateien in <filename>%i/include</filename> (oder einem Unterverzeichnis)
installieren.
</p>
<p>
Ab fink 0.20.5 erzeugt der Befehl "fink validate" eine Warnung für jede
.deb-Datei, die Header-Dateien und mindestens eine dynamische Bibliothek
enthält und das Feld BuildDependsOnly weder auf wahr noch falsch setzt.
(Es ist durchaus möglich, dass fink in Zukunft dies auf Fälle von
.deb-Dateien ausdehnt, die Header-Dateien und statische Bibliotheken
enthält.)
</p>
<p>
Das Ziel der Reichtlinien über dynamische Bibiliotheken ist, dass die
Kompatibilität zwischen den Bibliotheken un dProgrammen in verschiedenen
Paketen gewährleistet ist.  Manche Pakete können Bibliotheken enthalten,
die gar nicht dafür gedacht sind, von anderne Programmen benutzt zu
werden.  Ein häufige Situation ist, dass eine Gruppe von Programmen eine
Backend-Bibliothek mit Hilfsprogrammen haben oder ein Programm, das mehrere
Plugins für bestimmte Features hat.  Da diese Bibliotheken quasi privat
für das Paket sind, braucht man dafür kein extra SplitOff -shlibs und auch
kein <code>BuildDependsOnly</code>.
</p>
<p><em>Das Feld Shlibs</em></p>
<p>
Zusätzlich dazu, dass dynamische Bibliotheken in ein extra Paket gehören,
müssen ab Version 4 dieser Richtlinien alle dynamische Bibliotheken im
Feld <code>Shlibs</code> eingetragen werden. Dieses Feld hat für jede dynamische
Bibliothek nur eine Zeile mit dem <code>-install_name</code> der Bibliothek.
Ist die Bibliothek öffentlich, steht in der Zeile auch die
<code>-compatibility_version</code>, Informationen zur Abhängigkeit mit Version
darüber welches Fink-Paket die Bibliothek mit dieser
<code>-compatibility_version</code> enthält und die Architektur der Bibliothek.
(Die Architektur der Bibliothek kann "32", "64" oder "32-64" sein oder ganz
fehlen. Ist sie nicht explizit angegeben, wird die Voreinstellung genommen, d.h.
"32" für PowerPC und i386 und "64" für x86_64.) Die Abhängigkeit sollte in der
Form <code>foo (>= version-revision)</code> angegeben sein, wobei sich
<code>foo (>= version-revision)</code> auf die <em>erste</em> Version des
Finkpakets bezieht, das diese Bibliothek (mit der compatibility version) zur
Verfügung stellte. Das folgende Beispiel
</p>
<codeblock>  Shlibs: &lt;&lt;
  %p/lib/libbar.1.dylib 2.1.0 bar1 (>= 1.1-2) 32
  &lt;&lt;</codeblock>
<p>
ist eine (32-bit) Bibliothek mit dem <code>-install_name</code>
%p/lib/libbar.1.dylib und der <code>-compatibility_version</code> 2.1.0, die
in der Version 1.1-2 des Pakets <em>bar1</em> zum ersten Mal angeboten wurde.
Außerdem impliziert die Deklaration, dass der Betreuer versichert, dass auch in
späteren Versionen des Pakets <em>bar1</em> eine 32-bit Bibliothek mit diesem
Namen und einer Kompatibilitätsversion von mindestens 2.1.0 angeboten wird.
</p>
<p>
Beachten sie die Verwendung von %p im Pfad der Bibliothek. Dadurch wird der
richtige <code>-install_name</code> von allen Finknutzern gefunden, egal ob sie
/sw oder einen anderen Präfix für Fink ausgewählt haben.
</p>
<p>
Wird ein Paket aktualisiert, kann meistens das Feld <code>Shlibs</code> einfach
in die nächste Version/Revision des Pakets kopiert werden. Nur wenn sich die
Kompatibilitätsversion erhöht, muss die Versionsnummer in der Abhängigkeit
auf die aktuelle Version/Revision geändert werden, denn hier muss die
Version/Revision stehen, in der die neue Kompatibilitätsversion der Bibliothek
zum ersten Mal angeboten wird.
</p>
<p>
Für private Bibliotheken ist die Syntax für den Eintrag im Feld
<code>Shlibs</code> eine andere:
</p>
<codeblock>  Shlibs: &lt;&lt;
    !%p/lib/%N/libbar.1.dylib
  &lt;&lt;</codeblock>
<p>
Das Ausrufungszeichen am Anfang steht für private Bibliothek. Weitere
Informationen über die Bibliothek sind nicht relevant und werden deshalb weg
gelassen.
</p>
<p>
Beachten sie, dass in diesem Beispiel die private Bibliothek in ein eigenes
Unterverzeichnis <filename>%N</filename> (das nach dem Namen des Pakets benannt
wurde) des Verzeichnisses <filename>%i/lib</filename> verschoben wird. Dies ist
unsere Empfehlung als zusätzlicher Schutzmechanismus, der verhindert, dass
andere Pakete diese Bibliothek aus Versehen verlinken.
</p>
<p><em>Was muss ich machen, wenn siech die Nummer der Hauptversion ändert?</em></p>
<p>
Ändert sich die Nummer der Hauptversion von N auf M, muss man zwei neue Pakete
barM und barM-shlibs erstellen. Das Paket barM-shlibs darf keine gemeinsamen
Dateien mit dem Paket barN-shlibs haben, weil viele Nutzer die beiden Pakete
gleichzeitig installieren werden. Im Paket barM sollte man folgende
Abhängigkeiten deklarieren:
</p>
<codeblock>  Conflicts: barN
  Replaces: barN</codeblock>
<p>
Im Paket barN muss man in entsprechender Weise, also umgekehrt, folgendes
einfügen
</p>
<codeblock>  Conflicts: barM
  Replaces: barM</codeblock>
<p>
Bei der Erstellung von anderen Paketen werden die Pakete barN und barM
ausgetauscht, je nachdem, welches von den beiden benötigt wird. Die Pakete
barN-shlibs und barM-shlibs bleiben hingegen die ganze Zeit installiert.
</p>
<p><em>Pakete mit Bibliotheken und Binärdateien:</em></p>
<p>
Enthält eine Upstream-Paket gleichzeitig Binärdateien und öffentliche
Bibliotheken, muss man bei der Erstellung der Finkpakete aufpassen. Manchmal
sind die Binärdateien lediglich <code>foo-config</code>, die nur in der
Build-Phase des Pakets benötigt werden und nie zur Laufzeit. In solchen Fällen
können diese Dateien zusammen mit den Header-Dateien in das Paket
<code>foo</code>.
</p>
<p>
In anderen Fällen werden die Binärdateien von anderen Paketen auch zur Laufzeit
benutzt. Dann müssen sie in ein separates Finkpaket abgetrennt werden, das man
z. B. <code>foo-bin</code> nennen kann. Das Paket <code>foo-bin</code> sollte
vom Paket <code>foo-shlibs</code> abhängen. Betreuer anderer Pakete sollten
aufgefordert werden, die Abhängigkeit von <code>foo-bin</code> in ihrem Paket
zu deklarieren:
</p>
<codeblock>  Depends: foo-bin
  BuildDepends: foo</codeblock>
<p>Damit ist die Abhängigkeit von foo-shlibs implizit enthalten.</p>
<p>
Allerdings ist die Aktualisierung in dieser Situation ein Problem, denn ein
Nutzer wird nicht aufgefordert werden, das Paket <code>foo-bin</code> zu
installieren. Eine Lösung, bis alle anderen Paketbetreuer ihre Pakete
wie oben beschrieben aktualisiert haben, können sie folgende Abhängigkeit in
ihrem Paket <code>foo</code> deklarieren:
</p>
<codeblock>  Depends: foo-shlibs (= exact.version), foo-bin</codeblock>
<p>
Dies erzwingt die Installation des Paket <code>foo-bin</code> auf den meisten
Systemen, solange bis die anderen Paketbetreuer ihre Pakete, die von
<code>foo</code> abhängen, aktualisiert haben.
</p>
<p>
Ab fink 0.28.0 (veröffentlich im Januar 2008) hat sich das Format für einen
Eintrag im Feld <code>Shlibs</code> für private dynamische Bibliotheken geändert.
(Beachten sie bitte die obigen Erläuterungen zu den Unterschieden zwischen
privaten und öffentlichn dynamischen Bibliotheken.) Die Richtlinien für
dynamische Bibliotheken war schon immer so, dass alle dynamische Bibliotheken
aufgezählt werden müssen. Die Änderung betrifft nur das Feld
<code>Shlibs</code>. Da private Bibliotheken nicht von anderen Paketen benutzt
werden, ist es auch nicht notwendig, die Kompatibilitätsversion oder andere
Versionsinformationen anzugeben. Statt dessen wird ein Ausrufungszeichen
verwendet. Ist z. B. <filename>libquux.3.dylib</filename> der
<code>install_name</code> einer privaten dynamischen Bibliothek, würde sie so
aufgelistet werden:
</p>
<codeblock>  Shlibs: &lt;&lt;
    !%p/lib/libquux.3.dylib
  &lt;&lt;</codeblock>

</section>

<section name="perlmods"><title>Perl-Module</title>
<p>
Die erste Version von Finks Richtlinien zu Perl-Modulen wurde im Mai 2003
implementiert und erhielt im April 2004 die erste Revision.
</p>
<p>
Ursprünglich hatten Fink-Pakete für Perl-Module den Suffix <code>-pm</code> und
wurden mit der Direktive <code>Type: perl</code> erstellt. Damit wurden die
Dateien der Module in <filename>/sw/lib/perl5</filename> und/oder
<filename>/sw/lib/perl5/darwin</filename> abgespeichert.
Nach den aktuellen Richtlinien gilt dies nur noch für Module, die unabhängig von
der Perlversion übersetzt wurden und die auch nicht von anderen
versionsabhängigen Modulen abhängen.
</p>
<p>
Versionsabhängige Perl-Module sind die sogenannten XS-Module, die oft
übersetzten C Code und Perl-Routinen enthalten. Man kann sie auf verschiedene
Weisen erkennen, z. B. daran, die sie eine datei mit dem Suffix
<code>.bundle</code> enthalten.
</p>
<p>
Ein versionsabhängiges Perl-Modul muss mit einer bestimmten binären Version von
Perl erstellt werden, z. B. <code>perl5.12.3</code>. Die erzeugten Dateien
müssen dann in einem versionierten Unterverzeichnis des
Standard-Perlverzeichnisses abgespeichert werden, z. B.
<filename>/sw/lib/perl5/5.12.3</filename> und
<filename>/sw/lib/perl5/5.12.3/darwin</filename>. Es ist Konvention, die Pakete
mit dem Suffix <code>-pm5123</code> zu benennen, wenn sie für die Version 5.12.3
von Perl erstellt wurden. Entsprechende Konventionen für das Abspeichern und
die Namen von Modulen sind perl 5.10.0 (nur für 10.6), perl 5.12.4 (but für
10.7) und perl 5.16.2 (nur für 10.7).
</p>
<p>
Die Direktive <code>Type: perl 5.12.3</code> führt automatisch dazu, dass
das versionierte binäre Perl verwendet wird und speichert die Dateien in den
richtigen Unterverzeichnissen ab. (Diese Direktive steht in Fink ab der Version
0.13.0 zur Verfügung.)
</p>
<p>
Die Richtlinien vom Mai 2003 erlaubten es, ein Paket <code>-pm</code> zu
erstellen, das eigentlich ein Paket-"Bündel" ist, das die Variante
<code>-pm560</code> oder je nach Verfügbarkeit eine andere lädt. Die Richtlinien
vom April 2004 raten davon ab und nach einer Übergangsphase wurde diese
Möglichkeit komplett verboten.
</p>
<p>
Ab der Version 0.20.2 von Fink stellt das Paket system-perl automatisch
bestimmte Perl-Module zur Verfügung, je nach Version von system-perl. Der Code,
mit der die Liste erstellt wird, steht in der Datei <code>VirtPackage.pm</code>,
die Bestandteil des Pakets <code>fink</code> ist.
</p>
<p>
Da verschiedene system-perl unterschiedliche Module zur Verfügung stellen, wird
Paketbetreuern empfohlen, dass sie die Liste überprüfen, wenn sie eines der
Perl-Module verwerden.
</p>
<p>
Ab der Version 0.13.0 von Fink überprüft das Kommando
<code>fink validate</code> bei einer <code>.deb</code>-Datei, ob das Finkpaket
ein XS-Module ist, das in einem nichtversionierten Verzeichnis abgespeichert ist
und gibt eine entsprechende Warnung aus.
</p>
<p>
Nutzer können mehrere Versionen von Perl gleichzeitig installiert haben. Deshalb
müssen versionsabhängige Modulpakete so geschireben sein, dass mehrere Versionen
des Pakets installiert sein können. Besondere aufpassen muss man bei der
Installation von man-Pages und binären oder anderen Programmen, damit wegen
Namenskollissionen keine Installationskonflikte auftreten.
Man darf in einem Paket, dessen Namen auf -pm<em>XYZ</em> endet, keine Dateien
haben, die für verschiedene <em>XYZ</em> die gleichen Pfadnamen haben. Auch ein
<code>Replaces</code> für das einfache Überschreiben der Dateien wird nicht mehr
akzeptiert. Ab März 2005 definiert Fink als einfache Lösung zusätzliche Plätze
im MANPATH: <filename>%p/lib/perl5/X.Y.Z/man</filename> für jedes perl-X.Y.Z.
Deshalb muss man keine extra SplitOff-Pakete -man oder -doc mehr erstellen, die
sich jeweils gegenseitig ausschließen. Die Konflikte zwischen uri-pm5124 und
uri-pm5162 werden z. B. so aufgelöst, dass die gleich man-Page
<filename>URI.3pm</filename> jeweils unter
<filename>%p/lib/perl5/5.12.4/man/man3/URI.3pm</filename> oder
<filename>%p/lib/perl5/5.16.2/man/man3/URI.3pm</filename> abgespeichert wird.
Beachten sie bitte, dass sich die Standard-Skripte für
<code>Type: perl X.Y.Z</code> nicht geändert haben und man deshalb die man-Pages
selbst im <code>InstallScript</code> suchen muss. Ist das Skript nicht
hochgradig kompliziert, dann kann man das Standard-Skript verwenden und die
Dateien einfach mit mv verschieben:
</p>
<codeblock>%{default_script}
mv %i/share/man %i/lib/perl5/5.12.4</codeblock>
<p>
Dies verschiebt alle man-Pages. Will man nur einen Abschnitt der man-Pages
verschieben (z. B. nur Abschnitt 3, die man-Pages für die Module und nicht die
man-Pages für Skripte in Abschnitt 1), funktioniert folgendes:
</p>
<codeblock>%{default_script}
mkdir -p %i/lib/perl5/5.12.4/man
mv %i/share/man/man3 %i/lib/perl5/5.12.4/man</codeblock>
<p>
Hat man Programme, z. B.Demo- und Hilfs-Skripte, in <filename>%p/bin</filename>,
gibt es mehrere Optionen. Eine ist, die Dateien zusammen mit den dazugehörigen
man-Pages und so weiter in ein SplitOff-Paket %N-bin zu packen. Mit den Feldern
<code>Conflicts</code> und <code>Replaces</code> muss man für den gegenseitigen
Austausch bei der Installation der Dateien für verschiedene Perlversionen
sorgen. Der Nutzer kann viele verschiedene Perlversionen der Laufzeit-Module
installieren und dann zu einer bestimmten Zeit die gewünschte Perlversion des
Skripts auswählen. Das Paket Tk.pm kommt z. B. mit dem Programm
<filename>ptksh</filename>. Der Satz an tk-pm* Paketen kann man wie folgt
erzeugen:
</p>
<codeblock>Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
&lt;&lt;
SplitOff: &lt;&lt;
  Package: %N-bin
  Depends: %N
  Conflicts: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
  Replaces: %{Ni}5.12.3, %{Ni}5.12.4, %{Ni}5.16.2
  Files: bin share/man/man1
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Die andere Option ist die Skripte und ihre man-Pages so umzubenennen, dass
die Namen die Perlversion enthalten. Bei dieser Optione kommt es erst gar nicht
zu einem Namenskonflikt, so dass die %N-bin SplitOffs sich nicht gegenseitig
ausschließen müssen:
</p>
<codeblock>Info2: &lt;&lt;
Package: tk-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4 5.16.2)
InstallScript: &lt;&lt;
  %{default_script}
  mkdir -p %i/lib/perl5/%type_raw[perl]/man
  mv %i/share/man/man3 %i/lib/perl5/%type_raw[perl]/man
  mv %i/bin/ptksh %i/bin/ptksh%type_raw[perl]
  mv %i/share/man/man1/ptksh.1 %i/share/man/man1/ptksh%type_raw[perl].1
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Der Nutzer kann jederzeit das ptksh für ein bestimmtes Perl benutzen. Besonders
komfortabel für die Nutzer ist es, mit <code>update-alternatives</code> den
Aufruf auch mit dem allgemeinen Namen ohne Perlversion zu ermöglichen.
</p>
<p>
Ab März 2005 wurde auch der Platz für die man-Pages und die Module, die vom
fink-Paket für Perl selbst (also die Pakete perlXYZ und perlXYZ-core mit
Versionen, die vom der von Apple abweichen) geändert. Deshalb sollten andere
Finkpakete die aktualisierte Versionen von core-Perl-Modulen anbieten, die
Pakete perlXYZ oder perlXYZ-core nicht in ihrem Feld <code>Replaces</code>
auflisten.
</p>

</section>

<section name="emacs"><title>Emacs-Richtlinien</title>
<p>
Das Finkprojekt hat entschieden, den Richtlinien des Debianprojekts zu Emacs zu
folgen mit wenigen kleinen Unterschieden.
(Das Dokument zu den Debian-Richtlinien gibt es hier:
<link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">
http://www.debian.org/doc/packaging-manuals/debian-emacs-policy</link>.)
Es gibt zwei Unterschiede bei den Richtlinien von Fink. Erstens gelten die
Richtlinien derzeit nur für die Pakete <filename>emacs21</filename>,
<filename>emacs22</filename> und <filename>emacs23</filename> und nicht für das
Paket xemacs. (Dies kann sich eines Tages ändern.) Zweitens dürfen Finkpakete im
Gegensatz zu den Debian-Richtlinien Dateien direkt im Verzeichnis
/sw/share/emacs/site-lisp installieren
</p>

</section>

<section name="sources"><title>Quelldateien-Richtlinien</title>
<p>
Quelldateien sollen normalerweise von da herunter geladen werden, wo
Upstream-Entwickler sie anbieten. Jegliche Modifikation für das Finkpaket sollte
mit Patch-Dateien und/oder Patch-Skripten erfolgen. Man sollte also nicht die
Quelldateien abändern und im Finkpaket ein Archiv mit den geänderten Dateien
als <code>Source</code> verwenden.
</p>
<p>
Wird ein vcs Checkout verwendet (z. B. <em>git</em> oder <em>svn</em>), weil
z. B. das Projekt keine formalen Releases veröffentlicht oder eine wichtige
Problemlösung zwischen den Releases eingepflegt wurde, kann eine akzeptable
Quelle auf folgende Art und Weise erzeugt werden:
</p>
<ol>
<li>Führen sie ein Checkout des Pakets durch, vorzugsweise zu einer dezidierten
  Revision des VCS.</li>
<li>Erstellen sie ein Archiv aus dem VCS-Checkout (z. B. ein <em>zip</em>,
  <em>tar</em>, <em>tar.gz</em> oder <em>tar.bz2</em>).
  <p>Geben sie dem Tarball eine eindeutige Version. Sie können die
    VCS-Revision verwenden, wenn es überhaupt keine Releases des Pakets gibt,
    z. B. <filename>foo-0svn1234.tar.gz</filename> oder
    <filename>bar-1.2.3+svn4567.tar.bz2</filename> für eine Version zwischen
    zwei Releases.</p></li>
<li>Nutzen sie die gleiche <code>Version</code> in ihrer
  <filename>.info</filename>-Datei.</li>
<li>Es ist äußerst hilfreich, die Kommandos für die Erzeugung des
  Quelldatei-Tarballs im Feld <code>DescPackaging</code> zu dokumnetieren.</li>
<li>Laden sie den Tarball auf eine öffentliche Download-Seite hoch, wo Nutzer
  sie mit <code>fink</code> herunter laden können. Haben sie keinen
  entsprechenden Zugang, fragen sie in der
  <link url="mailto:fink-devel@lists.sourceforge.net">Fink developers
  Mailing-Liste</link> oder im
  <link url="http://webchat.freenode.net">IRC channel #fink</link>.
  nach und ihnen wird sicher geholfen werden.</li>
</ol>

</section>

<section name="downloading"><title>Datei-Download-Richtlinien</title>
<p>
Pakete dürfen in den Phasen unpack, patch, compile, install oder den build
Phasen während des <xref chapter="reference"
section="build">build-Prozess</xref> keinerlei Dateien herunter laden. Alle
größeren Patches (also alles, was man nicht in einer üblichen Patchdatei
unterbringen kann) sollten als zusätzliche Quelldateien entsprechend den
<xref chapter="policy" section="sources">Quelldatei-Richtlinien</xref>
aufgesetzt werden.
</p>
<p>
Unter bestimmten, eng umrissenen Umständen dürfen Pakete im PostInstScript
Dateien herunter laden, nachdem sie installiert sind:
</p>
<ul>
<li>Aktualisierungen der Pakete sind verboten.</li>
<li>Die Daten/Dateien sind so, dass sie nicht leicht in ein Finkpaket zu packen
  sind, z. B. Virusdefinitionen für <filename>clamav</filename> können im
  PostInstScript herunter geladen werden, weil sie sich laufend ändern.</li>
</ul>
<p>
Sind sie sich nicht sicher, dann schicken sie eine Email an das
<link url="mailto:fink-core@lists.sourceforge.net">Fink Core Team</link>.
</p>

</section>

</chapter>

<chapter filename="fslayout">
<title>Filesystem Layout</title>
<shorttitle>FS Layout</shorttitle>

<preface>
<p>
The following file system layout guidelines are part of the Fink
packaging policy.
</p>
</preface>

<section name="fhs"><title>The Filesystem Hierarchy Standard</title>
<p>
Fink follows the spirit of the
<link url="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</link>
, or FHS for short.
It can only follow it in spirit because the FHS was created for system
vendors that have control over the <filename>/</filename> and
<filename>/usr</filename> hierarchies.
Fink is an add-on distribution that controls only its install
directory (or prefix).
The examples use the default prefix of <filename>/sw</filename>.
</p>

</section>

<section name="dirs"><title>The Directories</title>
<p>
Files should go into the following subdirectories of the hierarchy:
</p>

<itemtable>

<item><itemt><filename>/sw/bin</filename></itemt>
<itemd>
<p>
This directory is for general executable programs.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><filename>/sw/sbin</filename></itemt>
<itemd>
<p>
This directory is for executable programs that are intended to be used
by administrators only.
Background daemons go here.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><filename>/sw/include</filename></itemt>
<itemd>
<p>
This directory is for C and C++ header files.
Subdirectories can be created as necessary.
If a package installs header files that can be confused with standard
C headers, those headers <em>must</em> go to a subdirectory.
</p>
</itemd></item>

<item><itemt><filename>/sw/lib</filename></itemt>
<itemd>
<p>
This directory is for architecture-dependent data files and
libraries.
Static and shared libraries should be placed directly in
<filename>/sw/lib</filename> unless there is a good reason not to.
This is also the place for executables that should not be executed
directly by the user (which would otherwise be placed in libexec).
</p>
<p>
A package is free to create a subdirectory to store private data or
loadable modules.
Make sure to use directory names that make sense for compatibility.
It is wise to use the package major version in the directory name or
as an additional hierarchy level, e.g. <filename>/sw/lib/perl5</filename>
or <filename>/sw/lib/apache/1.3</filename>.
Care should be taken when the host type is used to create
directories.
A <code>powerpc-apple-darwin1.3.3</code> directory is bad for
compatibility, <code>powerpc-apple-darwin1.3</code> or just
<code>powerpc-apple-darwin</code> are better choices.
</p>
</itemd></item>

<item><itemt><filename>/sw/lib/ppc64</filename>
<filename>/sw/lib/x86_64</filename></itemt>
<itemd>
<p>
This directory is for 64-bit libraries on 32-bit systems, 
with <filename>/sw/lib/ppc64</filename>
being used under powerpc architecture, and
<filename>/sw/lib/x86_64</filename> being used under i386 architecture.
Libraries which have been built 'fat' should be stored in
<filename>/sw/lib</filename> instead, and should be so indicated by
using '32-64' in the corresponding Shlibs entry.  Note that under
the x86_64 architecture, 64-bit
libraries are to be stored in <filename>/sw/lib</filename>.
</p>
</itemd></item>

<item><itemt><filename>/sw/share</filename></itemt>
<itemd>
<p>
This directory is for architecture-independent data files.
The same rules as for <filename>/sw/lib</filename> apply.
Some common subdirectories are described below.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/man</filename></itemt>
<itemd>
<p>
This directory contains manual pages.
It is organized into the usual section tree.
Every program in <filename>/sw/bin</filename> and
<filename>/sw/sbin</filename> should have an associated manual page here.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/info</filename></itemt>
<itemd>
<p>
This directory contains documentation in the Info format (produced
from Texinfo sources).
Maintenance of the <code>dir</code> file is automated through Debian's
version of <code>install-info</code> (part of the <code>dpkg</code>
package).
Use the <code>InfoDocs</code> description field to automatically
generate appropriate code for the <code>postinst</code> and
<code>prerm</code> package scripts.
Fink makes sure that no package installs a <code>dir</code> file of
its own.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/doc</filename></itemt>
<itemd>
<p>
This directory contains documentation that is neither a man page nor
an Info document.
README, LICENSE and COPYING files go here.
Every package must create a subdirectory here, named after the
package.
The subdirectory name must not contain any version numbers (unless
they are a part of the package name proper).
Hint: Just use <code>%n</code>.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/locale</filename></itemt>
<itemd>
<p>
This directory contains message catalogs for internationalization.
</p>
</itemd></item>

<item><itemt><filename>/sw/opt</filename></itemt>
<itemd>
<p>
The <filename>opt</filename> directory stores "add-on" software packages,
which for some reason cannot use the standard <filename>/sw/bin</filename>,
<filename>/sw/lib</filename>, <filename>/sw/include</filename>, etc. 
directories.
A package to be installed in <filename>/sw/opt</filename>
 must locate its static files in a separate 
<filename>/sw/opt/&lt;package&gt;</filename>
 directory tree, where <filename>&lt;package&gt;</filename> 
is a name that describes the software package.
(Available in fink 0.29.7 or later.)
</p>
</itemd></item>

<item><itemt><filename>/sw/var</filename></itemt>
<itemd>
<p>
The <filename>var</filename> directory stores variable data.
This includes spool directories, lock files, state databases, game
high scores and log files.
</p>
</itemd></item>

<item><itemt><filename>/sw/etc</filename></itemt>
<itemd>
<p>
This directory holds configuration files.
For packages that have more than one or two files here a subdirectory
should be made.
The subdirectory must have the name of the package or program in it so
that it is identifiable.
</p>
</itemd></item>

<item><itemt><filename>/sw/src</filename></itemt>
<itemd>
<p>
This directory is for storing and building source code.
Nothing should be installed here by a package.
</p>
</itemd></item>

<item><itemt><filename>/sw/Applications</filename></itemt>
<itemd>
<p>
This directory is for storing OS X-style applications which are
launched by double-clicking rather than from the command line.
</p>
</itemd></item>

<item><itemt><filename>/sw/Library/Frameworks</filename></itemt>
<itemd>
<p>
This directory is for storing OS X-style frameworks, sometimes
used by OS X-style applications.
</p>
</itemd></item>

</itemtable>

</section>

<section name="avoid"><title>Things to Avoid</title>
<p>
No other directories than the ones mentioned above should exist in
<filename>/sw</filename>.
In particular, the following should not be used:
<filename>/sw/man</filename>, <filename>/sw/info</filename>,
<filename>/sw/doc</filename>, <filename>/sw/libexec</filename>,
<filename>/sw/lib/locale</filename>.
</p>

</section>

</chapter>

<chapter filename="compilers">
<title>Compilers</title>
<shorttitle>Compilers</shorttitle>

<preface>
<p>
Fink uses the gcc family of compilers, as provided by Apple computer
through the Apple Developer Connection. Different versions of gcc exist,
and usually more than one is available on a Mac OS X system.
</p>
<p>
This section explains some of the ways Fink deals with these different versions
of gcc. An email to the Fink mailing list has
<link
url="http://www.mail-archive.com/fink-devel@lists.sourceforge.net/msg11877.html"
>more explanation</link>.
</p>
</preface>

<section name="versions"><title>Compiler Versions</title>
<p>
As GCC has evolved,
there have been different fink "distributions" to cope with the changes.
</p>
<p>
Each Fink distribution has had certain default values for the gcc and g++
compilers, which any user compiling from source is expected to have
installed.  You can expect that direct calls to "gcc" and "g++" from
within your package will use these default values.  If you need to use
a different value (for example, during a transition to a new distribution,
your packages .info file must specify this using the versioned binaries
provided by Apple.  Exactly how you will do this depends on the build
system of your software, but for many packages, the <code>SetCC</code>
and <code>SetCXX</code> fink fields can be used for this purpose.
For example, you might change the g++ compiler to version 3.3 by the setting
<code>SetCXX: g++-3.3</code>.  Examine the output when building your
package to make sure that the correct compiler is being used.
</p>
<p>
The 10.1 distribution assumes that the compiler version is 2.95; the
10.2 distribution assumes that the compiler version is 3.1; the 10.2-gcc3.3
and 10.3 distributions assume that the compiler version is 3.3.   The compiler
for the 10.4-transitional distribution is complicated: g++-3.3 is being
used along with gcc-4.0.  The 10.4 and 10.5 distributions use both gcc-4.0 
and g++-4.0.  The 10.6 distribution uses gcc-4.2, while the 10.7 through 10.9 
distributions use clang and clang++ as the default compilers.  The 10.9 
distribution has a further change in that it has migrated from libstdc++ to 
libc++.
</p>
<p>
A new method for ensuring the correct g++ compiler was introduced with the
10.4-transitional distribution.  During compilation, a directory
<code>/sw/var/lib/fink/path-prefix-g++-XXX</code> (where XXX is the version
number) is added to the PATH during compilation.  This directory contains
shell scripts which ensure that the correct compiler and version of g++ is used.
</p>

</section>

<section name="abi"><title>The g++ ABI</title>
<p>
The g++ ABI has changed 3 times during the lifetime of OS X: the ABI is
different for versions 2.95, 3.1, 3.3 and 4.0.  These different ABIs
are not compatible with each other, and any libraries which use C++
code and are linked to by your project must be compiled with the same
ABI as the one currently being used.
</p>
<p>
Fink keeps track of the g++ ABI by means of the GCC field.  This field
should be defined for any package which invokes the g++ or c++ compilers.
(It should NOT be defined for packages which don't invoke those compilers.)
Whenever an ABI upgrade occurs, all the dependencies of the packages must
be checked for their own GCC field.  When all of the dependencies have
been upgraded, the package itself may be upgraded.  The versions of the
dependencies must be changed to guarantee that users will have the correct,
updated, dependencies in place before they attempt to build the new version
of your package.
</p>
<p>
A small group of packages which depend only on each other can be left 
at the previous version of the ABI when the distribution changes, if they
are not ready to be upgraded.  When the upgrade is eventually done, they
must be all upgraded together with the correct versioning on all the
packages.  For this reason, it is best to upgrade most packages at
the time the distribution changes.
</p>
<p>
Fink uses the GCC field to ensure that users have the correct version of
the g++ compiler installed.  If the GCC field is defined by the package,
fink checks to see if the value matches that expected for the OS X version.
The correct value is 3.3 for the 10.2 and 10.3 versions of OS X, and 4.0 
for OS X 10.4 through OS X 10.9.
</p>

</section>

</chapter>

<chapter filename="reference">
<title>Reference</title>
<shorttitle>Reference</shorttitle>

<section name="build"><title>The Build Process</title>
<p>
To understand some of the fields, you need some knowledge of the
build process Fink uses. It consists of five phases: unpack, patch,
compile, install and build. The example paths below are for an
installation in <filename>/sw</filename> and the package gimp-1.2.1-1.
</p>
<p>
In the <em>unpack phase</em> the directory
  <filename>/sw/src/fink.build/gimp-1.2.1-1</filename> is created
and the source tarball(s) are unpacked there. In most cases, this will
create a directory gimp-1.2.1 with the source in it; all following
steps will be executed in that directory
(i.e. <filename>/sw/src/fink.build/gimp-1.2.1-1/gimp-1.2.1</filename>). Details
can be controlled with the SourceDirectory, NoSourceDirectory and
Source<em>N</em>ExtractDir fields.
</p>
<p>
In the <em>patch phase</em> the source is patched so that it will
build on Darwin. The actions specified by the UpdateConfigGuess,
UpdateLibtool, Patch and PatchScript fields will be executed, in that
order.
</p>
<p>
In the <em>compile phase</em> the source is configured and
compiled. Usually this means calling the <code>configure</code> script
with some parameters and then issuing a <code>make</code> command. See the
CompileScript field description for details.  If test suites are enabled
for the build (a new feature in fink 0.25, currently achieved by building in
maintainer mode), the TestScript will be run immediately after the
CompileScript.
</p>
<p>
In the <em>install phase</em> the package is installed to a temporary
directory, <filename>/sw/src/fink.build/root-gimp-1.2.1-1</filename> (= %d).
(Note the "root-" part.) All files that would normally be installed to
<filename>/sw</filename> are installed in
<filename>/sw/src/fink.build/root-gimp-1.2.1-1/sw</filename> (= %i = %d%p)
instead. See the InstallScript field description for details.
</p>
<p>
(<em>Introduced in fink 0.9.9.</em> It is possible to generate several
packages from a single package description using the <code>SplitOff</code>
field.  Towards the end of the install phase, separate install directories
are created for each package being created, and files are moved to
the appropriate directory.)
</p>
<p>
In the <em>build phase</em> a binary package file (.deb) is built
from the temporary directory. You can't influence this step directly,
but various information from the package description is used to
generate a <filename>control</filename> file for dpkg.
</p>

</section>

<section name="fields"><title>Fields</title>
<p>
We have divided the list of fields into several categories.
The list of fields is not necessarily complete. <code>:-)</code>
</p>
<p><em>Initial Data:</em></p>
<itemtable>
<item><itemt>Package</itemt>
<itemd>
<p>
The package name.
May contain lowercase letters, numbers and the special characters '.',
'+' and '-'.
No underscores ('_'), no capital letters.
Required field.
</p>
<p>
Percent expansion is applied to this field for %N, %{Ni}, %type_raw[],
and %type_pkg[] only.
</p>
<p>
As per Fink packaging policy, a given package must always
compile with the same options enabled. If you have multiple variants
for a package (see documentation for the <code>Type</code> field), you
must encode the specific variant info into the <code>Package</code>
field (see documentation for the %type_pkg[] percent expansion). That
way each variant has a unique name the package name indicates which
variant option(s) are included. Note that use of the %type_pkg[] and
%type_raw[] percent expansions in the <code>Package</code> field is
new and severely incompatible with older versions of fink, so such
package descriptions must be embedded in a <code>InfoN</code> field
with N>=2.
</p>
</itemd></item>

<item><itemt>Version</itemt>
<itemd>
<p>
The upstream version number.
Same limitations as the Package field.
Required field.
</p>
<p>
  Note that some programs use nonstandard version numbering schemes
  that may cause sorting confusion or that contain characters that are
  not allowed in this field. In these situations, when writing the
  Fink package, you must convert the upstream value to one that is
  acceptable and that allows the versions to be arranged in the
  correct order. When in doubt about how version strings will be
  sorted, you can use the <code>dpkg</code> command at a shell
  prompt. For example,
</p>
<codeblock>  dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo "true"</codeblock>
<p>
  will print &quot;true&quot; because version string &quot;1.2.1&quot;
  is less than &quot;1.3&quot;. See the <code>dpkg</code> manpage for
  more details.
</p>
</itemd></item>

<item><itemt>Revision</itemt>
<itemd>
<p>
The package revision.
Increase this when you make a new description for the same upstream
version.
Revision numbers start at 1.
Required field.
</p>
<p>
Fink's policy is that <em>any</em> time you make a change to the
<filename>.info</filename> file that results in changes to the
binary (compiled) form of a package (the <filename>.deb</filename>
file), you <em>must</em> increase <code>Revision</code>. This
includes changing the <code>Depends</code> or other package lists,
and adding,
removing, or renaming splitoff packages or shifting files among
them. When migrating a package to a new tree (from 10.2 to 10.3, for
example) involves such changes, you should
increase <code>Revision</code> by 10 (or some other large number) in the newer
tree in order to leave space for future updates to the package in the older
tree.
</p>
</itemd></item>

<item><itemt>Architecture</itemt>
<itemd>
<p>
A comma-separated list of fink architecture(s) for which the package
(and any splitoff packages) are intended.
As of fink-0.29.5, the valid values for architecture are <code>powerpc</code>,
<code>i386</code>, and <code>x86_64</code>. 
If this field is present and not blank after
conditional handling, fink will ignore the package description(s) if
the local fink architecture is not listed. If the field is omitted
or the value is blank, all architectures are assumed.
</p>
<p>
One common use of this field will be for packages which
require a compiler earlier than gcc-4.0 (or packages which depend on such
packages), which should be declared to have architecture 
<code>powerpc</code>.
</p>
<p>
This field supports the standard conditional syntax for any value in
the value list and percent-expansions can be used (see
the <code>Depends</code> field for more information). In this manner,
certain variants can be restricted to certain architectures. For
example:
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0)
  Architecture: (%type_pkg[perl] = 5100) x86_64</codeblock>
<p>
will result in the field for the foo-pm5100 variant
being <code>x86_64</code> and the field being blank for the foo-pm588
variant. Remember that when the field is blank, all architectures
are permitted.
</p>
<p>
The example above gives a very common use of this field: since
some modules for system-perl 5.10.0 on 10.6 do not build as 32-bit (i386), 
this field allows limiting multiple-type perl packages to specific
systems.
</p>
</itemd></item>

<item><itemt>Distribution</itemt>
<itemd>
<p>
A comma-separated list of distribution(s) for which the package
(and any splitoff packages) are intended.
At present, the only valid values for distribution are
<code>10.4</code>,
<code>10.5</code>,
<code>10.6</code>,
<code>10.7</code>,
<code>10.8</code>,
and <code>10.9</code>
. If this field is present and not blank after
conditional handling, fink will ignore the package description(s) if
the local machine distribution is not listed. If the field is omitted
or the value is blank, all distributions are assumed.
(Introduced in fink 0.26.0.)
</p>
<p>
Since Fink's <code>10.7</code>, <code>10.8</code>, and <code>10.9</code>
distributions share a common set of finkinfo files, the most common use of this
field will be for packages which are suitable for one of those distributions
but not the other.
</p>
<p>
This field supports the standard conditional syntax for any value in
the value list and percent-expansions can be used (see
the <code>Depends</code> field for more information). In this manner,
certain variants can be restricted to certain distributions. For
example:
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.12.3 5.12.4)
  Distribution: (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8</codeblock>
<p>
will result in the <code>Distribution</code> field for the foo-pm5123 variant
being <code>10.7, 10.8</code> and the field being blank for the 
foo-pm5124 variant.
</p>
<p>Since python 2.5 is not available in the 10.7+ distributions, and the
available perl versions vary by distribution, these package types provide
a common use of this field.  For reference, we note the availabilty of
various perl versions in the 10.3 through 10.9 distributions
(<em>bolded</em> systems indicate system-perl at that version):
</p>
<codeblock>    perl 5.6.0:  10.3
    perl 5.8.0:  10.3
    perl 5.8.1:  <em>10.3</em>, 10.4
    perl 5.8.4:  10.3, 10.4
    perl 5.8.6:  10.3, <em>10.4</em>, 10.5
    perl 5.8.8:        10.4, <em>10.5</em>, 10.6
    perl 5.10.0:             10.5, <em>10.6</em>
    perl 5.12.3:                         <em>10.7</em>, 10.8, 10.9
    perl 5.12.4:                         10.7, <em>10.8</em>, 10.9
    perl 5.16.2:                         10.7, 10.8, <em>10.9</em>, 10.10
    perl 5.18.2:                         10.7, 10.8, 10.9, <em>10.10</em></codeblock>
<p>
A way to include all supported variants in a single finkinfo file is as follows.
</p>
<codeblock>  Package: foo-pm%type_pkg[perl]
  Type: perl (5.8.8 5.10.0 5.12.3 5.12.4 5.16.2)
  Distribution: &lt;&lt;
   (%type_pkg[perl] = 588) 10.6,
   (%type_pkg[perl] = 5100) 10.6,
   (%type_pkg[perl] = 5123) 10.7, (%type_pkg[perl] = 5123) 10.8, (%type_pkg[perl] = 5123) 10.9,
   (%type_pkg[perl] = 5124) 10.7, (%type_pkg[perl] = 5124) 10.8, (%type_pkg[perl] = 5124) 10.9,
   (%type_pkg[perl] = 5162) 10.7, (%type_pkg[perl] = 5162) 10.8, (%type_pkg[perl] = 5162) 10.9
  &lt;&lt;</codeblock>
<p>Note that we do not include old
distributions, such as 10.2 or 10.4-transitional, since the versions of
fink which are relevant for them do not recognize this field.
</p>
</itemd></item>

<item><itemt>Epoch</itemt>
<itemd>
<p>
<em>Introduced in fink 0.12.0.</em>
This optional field can be used to specify the epoch of the package
(which defaults to 0 if not specified). For more information refer to
the
<link
url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian
Policy Manual</link>.
Because Fink and some of the underlying Debian tools use
name-version-revision as the unique identifier of a package, you must
not create a package that differs from another solely by its epoch.
</p>
<p>
When used in a version string, the Epoch appears before the Version
value, separated by a colon (1:3.14-2). Note that the Epoch is not part 
of <code>%v</code> (or (<code>%f</code>). If you add an Epoch field to
a package description file, you may have to adjust versioned
dependencies on the packages in it. For example, if you
add <code>Epoch: 1</code> and foo-dev declares <code>Depends:
foo-shlibs (= %v-%r)</code>, you will need to rewrite that
as <code>Depends: foo-shlibs (= %e:%v-%r)</code>.
</p>
</itemd></item>

<item><itemt>Description</itemt>
<itemd>
<p>
A short description of the package (what is it?). This is a one-line
description that will be displayed in lists, so it must be short and
informative. It should be less than 45 chars and must be less than
60. It is not necessary to repeat the package name in this field - it
will always be displayed in proper context. Required field.
</p>
</itemd></item>

<item><itemt>Type</itemt>
<itemd>
<p>
This can be set to <code>bundle</code>.
Bundle packages are used to group a set of related packages together.
They only have dependencies, but no code and no installed files.
The fields Source, PatchScript, CompileScript, InstallScript and
related ones are ignored for bundle packages.
</p>
<p>
<code>nosource</code> is a very similar type.
It indicates that there is no source tarball, so nothing is fetched
and the unpack phase creates just an empty directory.
However, the patch, compile and install phases are executed normally.
This way you can bring in all the code with a patch, or just create
some directories in the InstallScript.
Since fink 0.18.0, you can get the same behavior by setting
<code>Source: none</code>. This allows you to use "Type" for other
purposes (<code>Type: perl</code>, etc.)
</p>
<p>
Since fink 0.9.5 there is type <code>perl</code> which causes
alternate default values for the compile and install scripts to be used. 
Beginning in fink 0.13.0, there is a new variant of this type,
<code>perl $version</code>, where $version is a specific version of perl 
consisting of three numbers separated by periods, e.g., 
<code>perl 5.6.0</code>.
</p>
<p>
Beginning in a CVS version of fink after fink-0.19.2, the
language/language-version use has
been generalized to allow any Maintainer-defined types and associated
subtypes and more than a single type for a given package. The type and
subtype are each arbitrary strings of non-whitespace characters (but
parentheses, commas, braces, and percent signs should not be used); no
percent-expansion is performed, and the type (not subtype) values
are converted to all-lowercase.  Multiple type values (each with an
optional whitespace-separated subtype) are specified in a
comma-separated list.
</p>
<p>
In addition, the concept of &quot;variants&quot; exists, where a
single .info file describes a family of related packages with various
options enabled. The key to this whole process is the use of a list of
subtypes. Instead of a single string, one uses a space-separated list
of strings in parentheses. Fink clones the package description file
for each subtype in the list and replaces this list with that single
subtype. For example:
</p>
<codeblock>Type: perl (5.12.3 5.12.4)</codeblock>
<p>
yields two package descriptions, one that behaves as if <code>Type:
perl 5.12.3</code> and the other <code>Type: perl 5.12.4</code>. The special
subtype list &quot;(boolean)&quot; stands for a list containing the
type itself and a period, so the following two forms are identical:
</p>
<codeblock>Type: -x11 (boolean)
Type: -x11 (-x11 .)</codeblock>
<p>
Subtype list expansion/package cloning is recursive; if there are
multiple types with subtype lists, you will get all combinations:
</p>
<codeblock>Type: -ssl (boolean), perl (5.12.3 5.12.4)</codeblock>
<p>
One can access the specific variant subtype in other fields using the
%type_raw[] and %type_pkg[] pseudo-hashes. Here are two example .info
fragments:
</p>
<codeblock>Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;</codeblock>
<codeblock>Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Starting in fink 0.26.0, there is a special <code>Type: -64bit</code>
which controls a new percent expansion <code>%lib</code> and also
changes the default value of <code>LDFLAGS</code>.  When combined
with the new construction %type_num[], this allows a single .info file
to build both a 32-bit version of a library and a 64-bit version.
Here's some sample code:
</p>
<codeblock>Info2: &lt;&lt;
Package: foo%type_pkg[-64bit]
Type: -64bit (boolean)
Depends: (%type_raw[-64bit] = -64bit) 64bit-cpu
ConfigureParams: --libdir='${prefix}/%lib'
SplitOff: &lt;&lt;
 Package: %N-shlibs
 Files: %lib/libfoo.*.dylib
 Shlibs: &lt;&lt;
    %p/%lib/libfoo.1.dylib 1.0.0 %n (>= 1.0-1) %type_num[-64bit]
  &lt;&lt;
&lt;&lt;
&lt;&lt;</codeblock>
<p>
Note that <code>Type: -64bit</code> is generally not appropriate for
the x86_64 architecture, since in that case
libraries are being built 64-bit by default
and stored in <filename>%i/lib</filename>.
</p>

</itemd></item>

<item><itemt>License</itemt>
<itemd>
<p>
This field gives the nature of the license under which the package is
distributed.
The value must be one of the values described in <xref
chapter="policy" section="licenses">Package Licenses</xref> earlier in
this document.
Additionally, this field must only be given if the package actually
complies to the packaging policy in these respects, i.e. a copy of the
license is installed in the doc directory for the package.
</p>
</itemd></item>

<item><itemt>Maintainer</itemt>
<itemd>
<p>
The name and e-mail address of the person responsible for the package.
This field is required, and there must be exactly one name and address
in the following format:
</p>
<codeblock>Firstname Lastname &lt;user@host.domain.com&gt;</codeblock>
</itemd></item>

<item><itemt>InfoN</itemt>
<itemd>
<p>
This field allows fink to implement backward-incompatible syntax
changes in package description files. A given version of fink is
configured with the maximum integer "N" that it can handle. Any
package in a higher InfoN field will be ignored, so this mechanism
should only be used when necessary, lest people with older versions of
fink be needlessly alienated. To use this mechanism, embed
the entire package description in the desired InfoN field. See the
"File Format" section earlier in this document for a description of
the syntax for multiline fields.
Here are the features added for each InfoN level, along with the
earliest version of fink that supports it:
</p>
<ul>
<li><code>Info2</code> (fink>=0.20.0): Ability to use percent-expansions
  in the main <code>Package</code> field of the .info file and the
  ability to use the <code>%type_*</code> percent-expansions in
  the <code>Package</code> field of <code>SplitOff</code>
  (and <code>SplitOff<em>N</em></code>) packages.</li>
<li><code>Info3</code> (fink>=0.25.0): Can indent nicely in .info files,
  no more support for RFC-822 multi-lines, and can put comments in
  pkglist fields.</li>
<li><code>Info4</code> (fink>=0.26.2): adds %V expansion, and permits
  <code>%lib</code> in <code>ConfigureParams</code> field.</li>
</ul>
</itemd></item>

</itemtable>
<p><em>Dependencies:</em></p>
<itemtable>

<item><itemt>Depends</itemt>
<itemd>
<p>
A list of packages which must be installed before this package can be
built. Percent expansion is performed on this field (as well as the
other package list fields in this section: BuildDepends, RuntimeDepends, 
Provides, Conflicts, Replaces, Recommends, Suggests, and Enhances.
Usually, this is just a comma-separated list for plain package names,
but Fink now supports alternatives and version clauses with the same
syntax as dpkg.
A fully featured example:
</p>
<codeblock>Depends: &lt;&lt;
	daemonic (&gt;= 20010902-1),
	emacs | xemacs
&lt;&lt;</codeblock>
<p>
The layout above is the preferred format for the <code>Depends</code>
and similar fields. The field uses the multi-line field declarators
<code>&lt;&lt;</code> and each package is placed in alphabetical order
on its own indented line. If the field only has a single entry, the
simplified <code>Field: value</code> format may be used.
</p>
<p>
Note that there is no way to express real optional dependencies.
If a package works both with and without another package, you must
either make sure that the other package is not used even when it is
present or add it to the Depends field.
If you want to offer the user both options, make two separate
packages, e.g. wget and wget-ssl.
</p>
<p>
Order of operations: logical &quot;OR&quot; (list of alternatives) has
a higher precedence (binds more tightly) than the logical
&quot;AND&quot; between each package (or set of alternatives) in the
comma-separated list. Unlike the use of parentheses in arithmetic,
there is no way to specify alternative groups of packages or otherwise
change the order of operations in <code>Depends</code> and related
fields.
</p>
<p>
Starting with a post-0.18.2 CVS version of fink, you can have
conditional dependencies. These are specified by placing
<code>(string1 op string2)</code> before a package name. Percent
expansion is performed as usual and then the two strings
(neither of which can be null) are compared
according to the <code>op</code> operator: &lt;&lt;, &lt;=, =, !=,
&gt;&gt;, &gt;=. The immediately-following package is only considered
as a dependency if the comparison is true.
</p>
<p>
You can use this format to simplify maintaining several similar
packages. For example, the packages elinks and elinks-ssl could both list:
</p>
<codeblock>Depends: &lt;&lt;
	expat-shlibs,
	(%n = elinks-ssl) openssl097-shlibs
&lt;&lt;</codeblock>
<p>would have the same effect as having elinks list:</p>
<codeblock>Depends: expat-shlibs</codeblock>
<p>and elinks-ssl list:</p>
<codeblock>Depends: expat-shlibs, openssl097-shlibs</codeblock>
<p>
As an alternative syntax, you can also specify <code>(string)</code>,
which is &quot;true&quot; if <code>string</code> is non-null. For example:
</p>
<codeblock>Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11</codeblock>
<p>
would set the package x11 as a dependency for the nethack-x11 variant
but not for the nethack variant.
</p>
<p>
Note that when using Depends/BuildDepends for shared library packages
for which more than one major-version is available, you must
<em>not</em> do the following:
</p>
<codeblock>  Package: foo
  Depends: id3lib3.7-shlibs | id3lib4-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev</codeblock>
<p>
even if your package could work with either library. Pick one
(preferably the highest version that can be used successfully) and
use it consistently in your package.
</p>
<p>
As explained in the <xref chapter="policy"
section="sharedlibs">Shared Library Policy</xref>, only one of the
-dev packages can be installed at a time, and each has links of the
same name that could point to different filenames in the associated
-shlibs package. When compiling package foo, the actual filename (in
the -shlibs package) gets hard-coded into the foo binary. That means
the resulting package needs the specific -shlibs package associated
with the -dev that was installed at compile-time. As a result, one
cannot have a <code>Depends</code> that indicates that either one
will suffice.
</p>
<p>
In the past, non-essential packages implicitly depended on the
essential ones; this is no longer true.
</p>
</itemd></item>

<item><itemt>BuildDepends</itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.0.</em>
A list of dependencies that is applied at build time only.
This can be used to list tools (e.g. flex) that must be present to
build the package, but which are not used at run time.
Supports the same syntax as Depends.  If a build is being done
with test suites enabled, the dependencies in the <code>TestDepends</code>
field will be added to this list.
</p>
</itemd></item>

<item><itemt>RuntimeDepends</itemt>
<itemd>
<p>
<em>Introduced in fink 0.32.0.</em>
A list of dependencies that is applied at run time only,
that is, when the package is being installed.
This can be used to list packages that must be present to
run the package, but which are not used at build time.
Supports the same syntax as Depends.
</p>
</itemd></item>

<item><itemt>Provides</itemt>
<itemd>
<p>
A comma-separated list of package names that this package is
considered to "provide".
If a package named "pine" specifies <code>Provides: mailer</code>,
then any dependency on "mailer" is considered satisfied when "pine" is
installed.
You'll usually also want to name these packages in the "Conflicts" and
the "Replaces" field.
</p>
<p>
Note that there is no versioning data associated with Provides
items. They do not inherit from the parent package that contains the
Provides list nor is there a syntax for specifying an arbitrary version
in the Provides field itself. Further, a dependency that contains a
version specification is not satisfied by a package that Provides that
needed package name. As a result, having many variants provide a common
surrogate package may be harmful, because it precludes the use of versioned
dependencies. For example, if foo-gnome and foo-nognome both have "Provides:
foo", another package with "Depends: foo (> 1.1)" will not work.
</p>
</itemd></item>

<item><itemt>Conflicts</itemt>
<itemd>
<p>
A comma-separated list of package names that must not be installed at
the same time as this package.
For virtual packages it is allowed to list the names of the provided
packages here; they will be handled appropriately.
This fields also supports versioned dependencies like the Depends
field, but not alternatives (wouldn't make sense).
If a package is listed in its own Conflicts, it will be (silently)
removed from that list. (Introduced in a post-0.18.2 CVS version of
fink.)
</p>
<p>
<em>Note:</em> Fink itself currently ignores this field.
However, it is passed on to dpkg and will be handled accordingly.
In summary, it only effects run-time, not build-time.
</p>
</itemd></item>

<item><itemt>BuildConflicts</itemt>
<itemd>
<p>
A list of packages that must not be installed while this package is
being compiled. This can be used to prevent <code>./configure</code>
or the compiler from seeing undesired library headers or to avoid use
of a version of a tool that is known to be broken (for example, a bug
in a certain version of sed).  If a build is being done
with test suites enabled, the packages in the <code>TestConflicts</code>
field will be added to this list.
</p>
</itemd></item>

<item><itemt>Replaces</itemt>
<itemd>
<p>
This is used together with "Conflicts", when this package not only
takes over the function of the conflicting package, but also has some
common files.
Without this field, dpkg may generate errors when installing the
package because files are still owned by the other package.
It is also a hint that the two packages involved are genuine
alternatives and one can be removed in favor of the other.
If a package is listed in its own Replaces, it will be (silently)
removed from that list. (Introduced in a post-0.18.2 CVS version of
fink.)
</p>
<p>
<em>Note:</em> Fink itself currently ignores this field.
However, it is passed on to dpkg and will be handled accordingly.
In summary, it only effects run-time, not build-time.
</p>
</itemd></item>

<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>
These fields specify additional package relations in the same style as
the other dependency fields.
These three relations don't affect actual installation via
<code>dpkg</code> or <code>apt-get</code>.
However, they are used by <code>dselect</code> and other frontends to
help the user make sensible choices.
</p>
</itemd></item>

<item><itemt>Pre-Depends</itemt>
<itemd>
<p>
A special variation of the Depends field with more strict semantics.
This field must only be used after the case has been discussed on the
developer mailing list and a consensus has been reached that it is
necessary.
</p>
</itemd></item>

<item><itemt>Essential</itemt>
<itemd>
<p>
A boolean value that denotes essential packages. Essential
packages are installed as part of the bootstrap process. <code>dpkg</code>
will refuse to remove essential packages from the system unless
special flags are used to override this.
In the past, non-essential packages implicitly depended on the
essential ones; this is no longer true.
</p>
</itemd></item>

<item><itemt>BuildDependsOnly</itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.9.</em>
A boolean value which indicates that no other packages should Depend on
this one, they should only BuildDepend.
Unlike usual boolean fields, <code>BuildDependsOnly</code> is
tri-state: leaving it undefined (not specifying it at all) is
different than defining it as logically false. See the <xref
chapter="policy" section="sharedlibs">Shared Library Policy</xref> for
more information.
</p>
<p>As of fink 0.20.5, the presence or absence of this field, and its value
if present, are recorded into the .deb
file when the package is built.  Therefore, <em>if you change the value of
BuildDependsOnly or if you add or remove it,
you must increase the revision number</em> of the package.
</p>
</itemd></item>

</itemtable>
<p><em>Unpack Phase:</em></p>
<itemtable>

<item><itemt>CustomMirror</itemt>
<itemd>
<p>
A list of mirror sites. Each mirror site appears on a separate line,
in the following format: <code>&lt;location&gt;: &lt;url&gt;</code>.
<em>location</em> can be a continent code (e.g. <code>nam</code>), a
country code (e.g. <code>nam-us</code>), or anything else;
mirrors are tried in that order.
Example:
</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
<p>
The standard continent and country codes are listed in
<filename>/sw/lib/fink/mirror/_keys</filename>, which is part of the
fink or fink-mirrors package.
</p>
</itemd></item>

<item><itemt>Source</itemt>
<itemd>
<p>
An URL to the source tarball. It should be a HTTP or FTP URL, but
Fink doesn't really care - it just passes the URL to wget. This field
supports a special URL scheme for mirrors:
<code>mirror:&lt;mirror-name&gt;:&lt;relative-path&gt;</code>. This will
look up the mirror setting for <em>mirror-name</em> in Fink's
configuration, append the <em>relative-path</em> part and use that as
the actual URL. The known <em>mirror-name</em>s are listed in
<filename>/sw/lib/fink/mirror/_list</filename>, which is part of the fink or
fink-mirrors package. Alternatively, using <code>custom</code> as the
<em>mirror-name</em> will cause Fink to use the <code>CustomMirror</code>
field.
Before the URL is used, percent expansion takes place. Remember that
%n includes all %type_ variant data, so you may want to use %{ni} here
(perhaps with some specific %type_ expansions).
</p>
<p>
Since fink 0.18.0, <code>Source: none</code> has the special meaning
that there is no source to fetch. See the description of the
<code>Type</code> field for more information.
The value <code>gnu</code> is a shorthand for
<code>mirror:gnu:%n/%n-%v.tar.gz</code>; <code>gnome</code> is a shorthand for
<code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>. The
default is <code>%n-%v.tar.gz</code> (i.e. a manual
download).
This implicitly-defined <code>Source</code> form is deprecated
(explicitly-stated simple filename/manual download is still okay).
</p>
<p>
Sources that are only needed in order to run test suites should
use <code>TestSource</code> and related fields, inside the
<code>InfoTest</code> block.
</p>
</itemd></item>

<item><itemt>Source<em>N</em></itemt>
<itemd>
<p>
If a package consists of several tarballs, name them with these
additional fields, starting with N = 2. So, the first tarball (which
should be some kind of "main" tarball) goes into <code>Source</code>, the
second tarball in <code>Source2</code> and so on. The rules are the same
as for Source, only that the "gnu" and "gnome" shortcuts are not
expanded - that would be useless anyway. Starting with a CVS version
of fink after 0.19.2, you may use arbitrary (not necessarily
consecutive) integer values of N >= 2. However, you still may not have
duplicates.
</p>
</itemd></item>

<item><itemt>SourceDirectory</itemt>
<itemd>
<p>
Must be used when the tarball expands to a single directory, but
the directory's name is different from the basename of the tarball.
Usually, a tarball named "foo-1.0.tar.gz" will produce a directory
named "foo-1.0". If it produces a directory with a different name,
specify it with this parameter. Percent expansion is performed on this
field.
</p>
</itemd></item>

<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>
Set this boolean parameter to a true value if the tarball does not
expand to a single directory. Usually, a tarball named "foo-1.0.tar.gz"
will produce a directory named "foo-1.0". If it just unpacks the files
to the current directory, use this parameter and set it to a boolean
true value.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>ExtractDir</itemt>
<itemd>
<p>
Normally, an auxiliary tarball will be extracted in the same
directory as the main tarball. If you need to extract it in a
specific subdirectory instead, use this field to specify
it. Source2ExtractDir corresponds to the Source2 tarball, as one would
expect. See ghostscript, vim and tetex for examples of usage.
</p>
</itemd></item>

<item><itemt>SourceRename</itemt>
<itemd>
<p>
This field can rename a source tarball on the fly. This is useful
if for example the version of the source is encoded in the directory name on
the server, but the tarball itself has the same name for all versions, e.g.
<filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename>. To
circumvent the problems caused by this, you would then use something like
</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>
In the above example this would result in the tarball being stored under
<filename>/sw/src/coolapp-1.2.3.tar.gz</filename> as one would expect.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>Rename</itemt>
<itemd>
<p>
This is just the same as the <code>SourceRename</code> field, except that it is
used to rename the tarball specified by the corresponding
<code>Source<em>N</em></code> field. See context or hyperref for examples of
usage.
</p>
</itemd></item>

<item><itemt>Source-MD5</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
With this field you can specify the MD5 checksum of the source file. This
information is then used by Fink to detect incorrect source files, that is,
tarballs not matching the one the package creator used. Common causes for this
problem include: incompletely downloaded tarballs; upstream maintainers silently
replaced a tarball; a trojan or similar attacks; and so on.
</p>
<p>A typical usage example looks like this:</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
<p>
To compute the checksum, the <code>md5sum</code> tool is used. If you want to
determine the checksum of the tarball
<filename>/sw/src/apache_1.3.23.tar.gz</filename>,
you run the following command (displayed with output here):
</p>
<codeblock>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz 
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</codeblock>
<p>As you can see, the value to the left is exactly the value you need.</p>
</itemd></item>

<item><itemt>Source<em>N</em>-MD5</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
This is just the same as the <code>Source-MD5</code> field, except that it
is used to specify the MD5 checksum of the tarball specified by the
corresponding <code>Source<em>N</em></code> field.
</p>
</itemd></item>

<item><itemt>TarFilesRename</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
This field only applies to source files that are using the tar format
</p>
<p>
With this field you can rename files in the given source tarball during
the extraction of the tarball. This is very useful to work around
the fact that the HFS+ file system is not case sensitive, as files like
<filename>install</filename> and <filename>INSTALL</filename> will
collide on a standard Mac OS X system. With this field you can avoid
these issues without having to repackage the tarball (as was done in
the past in such cases).
</p>
<p>
In this field you simply specify a list of files that are to be renamed. You
can make use of wildcards. By default any given file will be renamed to its
current name with <code>_tmp</code> appended. You can override this default
by using the same syntax as in the <code>Files</code> and <code>DocFiles</code>
fields, namely by writing the old filename followed by a : and then followed by
the new filename.
Example:
</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: directory/INSTALL:directory/INSTALL.txt</codeblock>
</itemd></item>

<item><itemt>Tar<em>N</em>FilesRename</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
This is just the same as the <code>TarFilesRename</code> field, except that it
is used for the tarball specified by the corresponding
<code>Source<em>N</em></code> field.
</p>
</itemd></item>

</itemtable>

<!-- Patch Phase -->
<p><em>Patch Phase:</em></p>
<itemtable>

<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>
A boolean value. If true, the files config.guess and config.sub
in the build directory will be replaced with versions that know about
Darwin. This happens in the patch phase and before the PatchScript
is run. <em>Only</em> use this when you know it is necessary,
i.e. when the configure script fails with a "unknown host"
message.
</p>
</itemd></item>

<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p>
<em>Introduced in a post-0.9.0 CVS version.</em>
A list of subdirectories.
This does the same as UpdateConfigGuess, but is useful for packages
that have outdated config.guess files in several directories
throughout the source tree.
Previously you had to copy/move the files there manually in the
PatchScript.
With this new field you can just list the directories.
Use <code>.</code> to update files in the build directory itself.
</p>
</itemd></item>

<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>
A boolean value. If true, the files ltconfig and ltmain.sh in the
build directory will be replaced with versions that know about
Darwin. This happens in the patch phase and before the PatchScript
is run. <em>Only</em> use this when you know that the package needs
it. Some packages can be broken by overwriting the libtool scripts
with mismatching versions. See the
<link url="/doc/porting/libtool.php">libtool page</link>
for further information.
</p>
</itemd></item>

<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p>
<em>Introduced in a post-0.9.0 CVS version.</em>
A list of subdirectories.
This does the same as UpdateLibtool, but is useful for packages
that have outdated libtool 1.3.x scripts in several directories
throughout the source tree.
Previously you had to copy/move the files there manually in the
PatchScript.
With this new field you can just list the directories.
Use <code>.</code> to update files in the build directory itself.
</p>
</itemd></item>

<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>
A boolean value.
If true, the file <filename>Makefile.in.in</filename> in the
subdirectory <filename>po</filename> is replaced with a patched version.
This happens in the patch phase and before the PatchScript is run.
</p>
<p>
The patched version respects DESTDIR and makes sure that message
catalogs end up in <filename>/sw/share/locale</filename>, not
<filename>/sw/lib/locale</filename>.
Before using this field, make sure that you won't break the package
and that it's really required.
You can run <code>diff</code> to find the differences between the
package's version and Fink's version (in
<filename>/sw/lib/fink/update</filename>).
</p>
</itemd></item>

<item><itemt>Patch</itemt>
<itemd>
<p>
The filename of a patch to be applied with <code>patch -p1
&lt;<em>patch-file</em></code>. This should be just a filename; the
appropriate path (the same directory where the <code>.info</code> file
is located) will be prepended automatically. Percent expansion is
performed on this field, so a typical value is simply
<code>%f.patch</code> or <code>%n.patch</code>. The patch is applied
in a separate step before the PatchScript is run (if any).
</p>
<p>
Remember that %n includes all %type_ variant data, so you may want to
use %{ni} here (perhaps with some specific %type_ expansions). It's
easier to maintain a single patchfile and then make variant-specific
changes in <code>PatchScript</code> than to have a separate patchfile
for each variant.
</p>
<p>
As of fink-0.29.0, this field should not be used.
Use <code>PatchFile</code> instead. Support for <code>Patch</code>
will be removed in the future.
</p>

</itemd></item>

<item><itemt>PatchFile</itemt>
<itemd>
<p>
The same syntax as the <code>Patch</code> field. The full path to this
file is available using the <code>%{PatchFile}</code> percent
expansion--do not use <code>%a</code> to access this file.
Unlike <code>Patch</code>, <code>PatchFile</code> is applied as part
of <code>PatchScript</code>. Fink checks that the listed file exists,
is readable, and that its checksum matches
the <code>PatchFile-MD5</code> field.
</p>
<p>
You may not use both <code>Patch</code> and <code>PatchFile</code> in
the same package description. Any package that
uses <code>PatchFile</code> must declare at least
<code>BuildDepends: fink (>= 0.24.12)</code>. Giving a higher version
requirement is allowed if it is necessary for other reasons.
</p>
</itemd></item>

<item><itemt>PatchFile<em>N</em></itemt>
<itemd>
<p>
If a package has several patch files, name them with these additional 
fields, starting with N = 2. So, the first patch file goes into 
<code>PatchFile</code>, the second patch file in <code>PatchFile2</code> 
and so on.  Any package that uses <code>PatchFile<em>N</em></code> must 
declare at least <code>BuildDepends: fink (&gt;= 0.30.0)</code>. Giving 
a higher version requirement is allowed if it is necessary for other 
reasons.
</p>
</itemd></item>

<item><itemt>PatchFile-MD5</itemt>
<itemd>
<p>
The MD5 checksum of the file given in the <code>PatchFile</code>
field. This field is required if <code>PatchFile</code> is used.
(Introduced in fink-0.24.12)
</p>
</itemd></item>

<item><itemt>PatchFile<em>N</em>-MD5</itemt>
<itemd>
<p>
The MD5 checksum of the file given in the <code>PatchFile<em>N</em></code>
field. This field is required if <code>PatchFile<em>N</em></code> is used.
(Introduced in fink-0.30.0)
</p>
</itemd></item>

<item><itemt>PatchScript</itemt>
<itemd>
<p>
A list of commands that are run in the patch phase. This is the place
to put commands that patch or otherwise modify the package source. See
the <xref chapter="reference" section="scripts">note on scripts</xref>
below. Before the commands are executed, <xref chapter="format"
section="percent">percent expansion</xref> takes place. If
a <code>PatchFile</code> field exists, the
default <code>PatchScript</code> is:
</p>
<codeblock>patch -p1 &lt; %{PatchFile}</codeblock>
<p>
If one or more <code>PatchFile<em>N</em></code> fields are used, the 
following is appended as needed to the default script:
</p>
<codeblock>patch -p1 &lt; %{PatchFile<em>N</em>}</codeblock>
<p>
If there is no <code>PatchFile</code>, the default is blank. If you
have an explicit <code>PatchScript</code>, you must apply
the <code>PatchFile(s)</code> explicitly.
</p>
</itemd></item>

</itemtable>
<p><em>Compile Phase:</em></p>
<!--
insert DefaultScript here ?
-->

<itemtable>

<item><itemt>Set<em>ENVVAR</em></itemt>
<itemd>
<p>
Causes certain environment variables to be set in the
compile and install phases. This can be used to pass compiler flags
etc. to configure scripts and Makefiles. Currently supported variables
are:
CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME,
LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, 
MFLAGS, MAKEFLAGS.
The value you specify is subject to the
percent expansion described in the last section. A common example:
</p>
<codeblock>SetLDFLAGS: -Wl,-strip_dead_dylibs</codeblock>
<p>
Some environment variables have default preset values.
If you specify a value for one of these, it will be
prepended to the default value.
The preset variables (and their default values) are:
</p>
<codeblock>CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib</codeblock>
<p>
Starting in fink 0.26.0, there is one exception to these defaults:
if <code>Type: -64bit</code> is set to <code>-64bit</code>, then the
default value of <code>LDFLAGS</code> is <code>-L%p/%lib -L%p/lib</code> 
instead.
</p>
<p>
Finally, MACOSX_DEPLOYMENT_TARGET is set to a default value depending
on which version of OSX is being run, but setting a value for it for 
a package will override (rather than prepend to) the default value.
</p>

</itemd></item>

<item><itemt>NoSet<em>ENVVAR</em></itemt>
<itemd>
<p>
When set to a true value, deactivates the default values for the preset
variables (such as
CPPFLAGS, LDFLAGS, CXXFLAGS  mentioned above). For 
example, if you want LDFLAGS to
remain unset, specify <code>NoSetLDFLAGS: true</code> .
</p>
</itemd></item>
<item><itemt>UseMaxBuildJobs</itemt>
<itemd>
<p>
When set to a true value, appends <code>-j<em>N</em></code>, where <em>N</em> 
is the value from the <filename>fink.conf</filename> field MaxBuildJobs, 
to the environment variable MAKEFLAGS during CompileScript and TestScript. 
This value is added to MAKEFLAGS even if the field <code>NoSetMAKEFLAGS: 
true</code> is used. As of fink > 0.31.2, if the field is not present or 
blank, the default is <code>True</code>.
</p>
</itemd></item>

<item><itemt>BuildAsNobody</itemt>
<itemd>
<p>
In fink &gt;= 0.33.0, when set to a <code>false</code> value, causes fink
to build as <code>root</code> rather than as the underprivileged
<code>fink-bld</code> user.
If this field is not present, its value defaults to <code>true</code>, indicating
that the package should be built as <code>fink-bld</code>.
</p>
<p>In earlier fink versions, this field does nothing.</p>
</itemd></item>

<item><itemt>ConfigureParams</itemt>
<itemd>
<p>
Additional parameters to pass to the configure script. (See
CompileScript for details.)  
For packages not of <code>Type: Perl</code>, the parameter
<code>--prefix=%p</code> is prepended to this value.
As of fink > 0.13.7, this field will also work with perl modules
<code>Type: Perl</code>; the default perl Makefile.PL
string is prepended to the value supplied for <code>ConfigureParams</code>.
</p>
<p>
If a build is being done
with test suites enabled, the value of the <code>TestConfigureParams</code>
field will be appended to the normal <code>ConfigureParams</code> value.
</p>
<p>
Starting in fink-0.22.0, this field supports conditionals. The
syntax is the same as that used in the <code>Depends</code> and
other package-list fields. The conditional expression only applies
to the whitespace-delimited &quot;word&quot; immediately following
it. For example
</p>
<codeblock>Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared</codeblock>
<p>
will always pass the <code>--mandir</code> and <code>--disable-shared</code>
flags, but only pass <code>--with-x11</code> in the -x11 variant.
</p>
<p>
This field supports placing parameters into multiple lines using multi-line
field declarators. The field is handled as a shell command line and uses
<code>\</code> to separate lines:
</p>
<codeblock>ConfigureParams: &lt;&lt;
	--mandir=%p/share/man \
	(%type_pkg[-x11]) --with-x11 \
	--disable-shared
&lt;&lt;</codeblock>
<p>
Note: do not place conditional parameters as the last line when using the
multi-line field format. In instances when the conditional evaluates as false,
the parameter immediately following is not evaluated and this breaks the shell.
</p>
</itemd></item>

<item><itemt>GCC</itemt>
<itemd>
<p>
This field specifies the GCC-ABI used by C++ code in this package.
(It is needed because that ABI has changed twice, and any libraries
which you link to containing C++ code must be compiled with the same ABI
you are currently using.)
</p>
<p>
The allowed values are:
<code>2.95.2</code> (or <code>2.95</code>), <code>3.1</code>, <code>3.3</code>,
and <code>4.0</code>.
Our understanding is that the GCC authors intend to stabilize the GCC-ABI
at some point; we can hope that it won't change again.
</p>
<p>
The GCC field does not have a default value, per se, since it is ignored
if it is not set.  However, for each tree, there is an expected value
for GCC corresponding to the default g++ compiler for that tree.
The expected values for the various package trees are:
<code>2.95</code> in the 10.1 tree, <code>3.1</code> in the 10.2 tree,
 <code>3.3</code> in the 10.2-gcc3.3, 10.3, and 10.4-transitional
trees, and <code>4.0</code> in the 10.4 and 10.7 trees.
</p>
<p>
Note that when the GCC value is different from the expected value, the compiler
must be specified within the package (typically by setting the CC or CXX
flags), and a dependency on one of the (virtual) gcc packages should be
specified.
</p>
<p>
As of fink 0.13.8, when this flag is present, the version of gcc
is tested using <code>gcc_select</code>, and fink exits with an error
if the wrong version is present.
</p>
<p>
This field was added to fink to aid maintainers
in tracking the transition between the gcc
compilers, which introduced a binary incompatibility between libraries
that involve C++ code which is not reflected in the versioning
scheme.
</p>
</itemd></item>

<item><itemt>CompileScript</itemt>
<itemd>
<p>
A list of commands that are run in the compile phase. This is the
place to put commands that configure and compile the package. See
the <xref chapter="reference" section="scripts">note on scripts</xref>
below. Before the commands are executed, <xref chapter="format"
section="percent">percent expansion</xref> takes place. Normally the
default is:
</p>
<codeblock>./configure %c
make</codeblock>
<p>
This is appropriate for packages that use GNU autoconf.
For packages with of type perl (as specified via the Type field)
with the perl version not specified,
the default instead (as of fink 0.13.4) is:
</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
If the type is <code>perl $version</code> with the version specified
(e.g., <code>$version</code> might be 5.6.0),
then the default becomes:
</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
where <code>$perlarchdir</code> is "darwin" for versions 5.8.0 and
earlier, and is 
"darwin-thread-multi-2level" for versions 5.8.1 and later.
</p>
</itemd></item>

<item><itemt>NoPerlTests</itemt>
<itemd> 
<p>
<em>Introduced in fink > 0.13.7.</em>
A boolean value, specific for perl module packages.
If true, the <code>make test</code> portion
of the <code>CompileScript</code> will be ignored
for that specific perl module package.
</p>
</itemd></item>

</itemtable>
<p><em>Test Suites:</em></p>
<itemtable>

<item><itemt>InfoTest</itemt>
<itemd>
<p>
<em>Introduced in fink 0.25.</em>
This field encapsulates information that will only be used when performing
a build with test suites enabled.  It contains other fields.
If present, this field <em>must</em> contain a <code>TestScript</code>.
All other fields are optional.  The following fields are allowed inside
<code>InfoTest</code>:
</p>
<ul>
<li><code>TestScript</code>: A script which runs the test suite.  This script
  should exit
    with status 0 if the suite passes, 1 to indicate warnings, or any other
    value to indicate failures serious enough to be considered fatal.
    Because of this tri-state logic, you should explicitly set an exit value in
    this script.  For instance, <code>make check</code> is a bad script,
    since it will exit with status 1 if the check target doesn't exist.
    <code>make check || exit 2</code> would be a better script.</li>
<li><code>TestConfigureParams</code>: A value which will be appended to
  <code>ConfigureParams</code>.</li>
<li><code>TestDepends</code> and <code>TestConflicts</code>: Lists of packages
  that will be added to the <code>BuildDepends</code> or
  <code>BuildConflicts</code> lists.</li>
<li><code>TestSource</code>: Extra sources necessary to run the test suite.
  All of the
    affiliated fields are also supported, so you <em>must</em> also specify
    <code>TestSource-MD5</code>, and you may also have
    <code>TestSourceN</code> and corresponding <code>TestSourceN-MD5</code>,
    <code>TestTarFilesRename</code>, etc.</li>
<li><code>TestSuiteSize</code>: Describes approximately how long the test suite
  takes to
    run.  Valid values are <code>small</code>, <code>medium</code>, and
    <code>large</code>.
    This field is currently ignored.</li>
<li>Any other standard field.  If a field is specified both inside and outside
<code>InfoTest</code>, the value inside <code>InfoTest</code> will replace
the other value when test suites are active.</li>
</ul><p>Here's an example:</p>
<codeblock>InfoTest: &lt;&lt;
    TestScript: make check || exit 2
    TestConfigureParams: --enable-tests
&lt;&lt;</codeblock>
</itemd></item>
</itemtable>
<p><em>Install Phase:</em></p>
<itemtable>

<item><itemt>UpdatePOD</itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.5.</em>
A boolean value, specific for perl module packages.
If true, this will add code to the install, postrm and postinst
scripts that maintains the .pod files provided by perl packages.
This includes adding and removing the .pod date from the central
<filename>/sw/lib/perl5/darwin/perllocal.pod</filename> file.
(If the type has been given as <code>perl $version</code> with a
specific version of perl such as 5.6.0,
then these scripts are adapted to deal with the central .pod file
<filename>/sw/lib/perl5/$version/perllocal.pod</filename>.)
</p>
</itemd></item>

<item><itemt>InstallScript</itemt>
<itemd>
<p>
A list of commands that are run in the install phase. This is the
place to put commands that copy all the necessary files into the
temporary dpkg directory for the package. See the <xref
chapter="reference" section="scripts">note on scripts</xref>
below. Before the commands are executed, <xref chapter="format"
section="percent">percent expansion</xref> takes place. Normally the
default is:
</p>
<codeblock>make install prefix=%i</codeblock>
<p>
The default is appropriate for packages that use GNU autoconf.
For packages with of type perl (as specified via the Type field)
with the perl version not specified,
the default instead (as of fink 0.13.4) is:
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
 INSTALLARCHLIB=%i/lib/perl5/darwin \
 INSTALLSITELIB=%i/lib/perl5 \
 INSTALLSITEARCH=%i/lib/perl5/darwin \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>
If the type is <code>perl $version</code> with the version specified
(e.g., <code>$version</code> might be 5.6.0),
then the default becomes:
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
 INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%i/lib/perl5/$version \
 INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>
where <code>$perlarchdir</code> is "darwin" for versions 5.8.0 and
earlier, and is 
"darwin-thread-multi-2level" for versions 5.8.1 and later.
</p>
<p>
If the package supports it, it is preferably to use <code>make install
DESTDIR=%d</code> instead.
</p>
</itemd></item>

<item><itemt>AppBundles</itemt>
<itemd>
<p>
<em>Introduced in a post-0.23.1 version.</em>
This field installs the specified application bundle(s) into
<filename>%p/Applications</filename>.  It will also create a
symlink to the <filename>/Applications/Fink</filename> directory.
Example:
</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
</itemd></item>

<item><itemt>JarFiles</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
This field is somewhat similar to DocFiles. It installs the specified jar
files into <filename>%p/share/java/%n</filename>.
Example:
</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
<p>
This will install all the jars that were in the lib directory and will install
foo.jar as fooBar.jar.
</p>
<p>
It also ensures that these jar files (specifically: all files in
<filename>%p/share/java/%n</filename> that end in .jar)
are added to the CLASSPATH environment variable. This allows tools like
configure or ant to properly detect the installed jar files.
</p>
</itemd></item>

<item><itemt>DocFiles</itemt>
<itemd>
<p>
This field provides a convenient way to install README or COPYING
files in the doc directory for the package,
<filename>%p/share/doc/%n</filename>.
The value is a space-separated list of files.
You can copy files from subdirectories of the build directory, but
they will end up in the doc directory itself, not in a subdirectory.
Shell wildcards are allowed.
It is also possible to rename single files on the fly by appending the
new name separated by a colon (:),
e.g. <code>libgimp/COPYING:COPYING.libgimp</code>.
This field works by appending appropriate <code>install</code>
commands to the InstallScript.
</p>
</itemd></item>

<item><itemt>Shlibs</itemt>
<itemd>
<p>
<em>Introduced in fink 0.11.0.</em>
This field declares the shared libraries which are installed in the
package.  There is one line for each
shared library, which contains the <code>-install_name</code> of the
library and information about its binary compatibility. Shared
libraries that are "public" (i.e., provided for use by other packages)
have, separated by whitespace after the filename,
the <code>-compatibility_version</code>, versioned package
dependency information specifying the Fink package which provides
this library at this compatibility version, and the
library architecture.  (The library architecture may either be "32", "64", or
"32-64", and may be absent; if absent, 
the value defaults to "32" under the powerpc and i386 machine architectures,
and to "64" under the x86_64 machine architecture.)  
The dependency should
be stated in the form <code> foo (>= version-revision)</code> where 
<code>version-revision</code> refers to
the <em>first</em> version of a Fink package which made
this library (with this compatibility version) available.
The Shlibs declaration amounts to a promise
from the maintainer that a library with this name and a 
<code>-compatibility_version</code>
of at least this number will always be found in later versions of this
Fink package.
Shared libraries that are "private" are denoted by an exclamation mark
preceeding the filename, and no compatilibity or versioning
information is given. See the <xref chapter="policy"
section="sharedlibs">Shared Library Policy</xref> for more
information.
</p>
</itemd></item>

<item><itemt>RuntimeVars</itemt>
<itemd>
<p>
<em>Introduced in fink 0.10.0.</em>
This field provides a convenient way to set environment variables to some static
value at runtime (if you need more flexibility, refer to the
<xref section="profile.d">profile.d scripts section</xref>). As long as your
package is installed, these variables will be set via the
<filename>/sw/bin/init.[c]sh</filename> scripts.
</p>
<p>
The value of your variable can contain spaces (trailing ones are trimmed); also,
percent expansion takes place. For example:
</p>
<codeblock>RuntimeVars: &lt;&lt;
 SomeVar: %p/Value
 AnotherVar: foo bar
&lt;&lt;</codeblock>
<p>
will set two environment variables 'SomeVar' and 'AnotherVar' and their values
will be respectively '/sw/Value' (or whatever your prefix is) and 'foo bar'.
</p>
<p>
This field works by appending appropriate commands to the InstallScript.
These commands add a setenv/export line for each variable to the package
profile.d scripts, so you can provide your own ones, they won't be overwritten.
The lines are prepended to the scripts, you can thus use these variables in your
scripts.
</p>
</itemd></item>

<item><itemt>SplitOff</itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.9.</em>
Generate a second package from the same compile/install run.
For details about how this works, see the separate
<link url="#splitoffs">splitoff section</link>
below.
</p>
</itemd></item>

<item><itemt>SplitOff<em>N</em></itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.9.</em>
This is the same as <code>SplitOff</code>, used to generate a third,
fourth, etc. package from the same compile/install run. Starting with a
CVS version of fink after 0.19.2, you may use arbitrary (not
necessarily consecutive) integer values of N >= 2. However, you still
may not have duplicates.
</p>
</itemd></item>

<item><itemt>Files</itemt>
<itemd>
<p>
<em>Introduced in fink 0.9.9.</em>
Used <em>only</em>
within a <code>SplitOff</code> or <code>SplitOff<em>N</em></code> field,
this designates which files and directories
should be moved from the parent package's  installation
directory %I to the current installation directory %i.  Note that this
is executed after the InstallScript and the DocFiles of the parent package,
but before the InstallScript and Docfiles of the current package.
</p>
</itemd></item>

</itemtable>
<p><em>Build Phase:</em></p>
<itemtable>

<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>
These fields specify pieces of shell scripts that will be called when
the package is installed, upgraded or removed.
Fink automatically adds the shell script header
<code>#!/bin/sh</code>, and calls <code>set -e</code> so any command
that fails will result in instant termination of the script.
Fink also adds an <code>exit 0</code> at the end.
To indicate an error, exit from the script with a non-zero exit code.
The first parameter (<code>$1</code>) is set to a value indicating
what action is being performed.
Some possible values are <code>install</code>, <code>upgrade</code>,
<code>remove</code> and <code>purge</code>.
Note that there are more values, used during error rollback or when
removing a package in favor of another one.
</p>
<p>The scripts are called at the following times:</p>
<ul>
<li>PreInstScript: When the package is installed for the first time
  and before upgrading the package to this version.</li>
<li>PostInstScript: After unpacking and setting up the package.</li>
<li>PreRmScript: Before the package is removed or upgraded to a later
  version.</li>
<li>PostRmScript: After the package was removed or upgraded to a later
  version.</li>
</ul>
<p>
To make it more clear, an upgrade invokes both the ...Inst scripts of
the new version and the ...Rm scripts of the old version.
Details can be found in the Debian Policy Manual,
<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">Chapter 6</link>.
</p>
<p>
Percent expansion is performed on the scripts.
Commands can generally be called without giving a full path.
</p>
</itemd></item>

<item><itemt>ConfFiles</itemt>
<itemd>
<p>
A space-separated list of files that are user-modifiable configuration
files.
Percent expansion  is performed on this field.
The files must be specified with an absolute path,
e.g. <filename>%p/etc/%n.conf</filename>. 
The named files will receive special treatment by dpkg.
When a package is upgraded and the file has changed both on disk and
in the package, the user is asked which version to use and backups
of the file will be made.
When a package is "remove"d, the configuration files will remain on
disk.
Only a "purge" also removes the configuration files.
</p>
</itemd></item>

<item><itemt>InfoDocs</itemt>
<itemd>
<p>
Lists the names of Info documents that the package installs in
%p/share/info.
This will add appropriate code to the postinst and prerm scripts to
maintain the Info directory file, <code>dir</code>.
</p>
<p>
<em>Note:</em>  Only use the un-numbered file in the case of split Info
documents. E.g. if a package has:
</p>
<codeblock>foo.info
foo.info-1
foo.info-2</codeblock>
<p>you should only use:</p>
<codeblock>InfoDocs:  foo.info</codeblock>
<p>
This feature is still in flux, more fields for finer control may be
added in the future.
</p>
</itemd></item>

<item><itemt>DaemonicFile</itemt>
<itemd>
<p>
Gives a service description for <code>daemonic</code>.
<code>daemonic</code> is used by Fink to create and remove
StartupItems for daemon processes (e.g. web servers).
The description will be added to the package as a file named
<code>%p/etc/daemons/<em>name</em>.xml</code>, where <em>name</em> is
specified by the DaemonicName field and defaults to the package
name.
Percent expansion is performed on the contents of this field.
Note that you must add <code>daemonic</code> to the dependency list if
your package uses it.
</p>
</itemd></item>

<item><itemt>DaemonicName</itemt>
<itemd>
<p>
A name for the <code>daemonic</code> service description file.
See the description of DaemonicFile for details.
</p>
</itemd></item>

</itemtable>
<p><em>Additional Data:</em></p>
<itemtable>

<item><itemt>Homepage</itemt>
<itemd>
<p>The URL of the upstream home page of the package.</p>
</itemd></item>

<item><itemt>DescDetail</itemt>
<itemd>
<p>
A more detailed description than the one in the <code>Description</code>
field (what is it, what can I use it for?).
Multiple lines allowed. Because this field will be displayed without
the benefit of word-wrap, you should manually insert line breaks in
order to keep lines less than 79 chars (if possible).
</p>
</itemd></item>

<item><itemt>DescUsage</itemt>
<itemd>
<p>
This is for information that is needed to use the package (how do
I use it?). As in "run wmaker.inst once before using WindowMaker".
Multiple lines allowed. Because this field will be displayed without
the benefit of word-wrap, you should manually insert line breaks in
order to keep lines less than 79 chars (if possible).
</p>
</itemd></item>

<item><itemt>DescPackaging</itemt>
<itemd>
<p>
Notes about the packaging. Stuff like "patches the Makefile to put
everything in place" goes here. Multiple lines allowed.
</p>
</itemd></item>

<item><itemt>DescPort</itemt>
<itemd>
<p>
Notes that are specific to porting the package to Darwin. Stuff
like "config.guess and libtool scripts are updated, -no-cpp-precomp
is necessary" goes here. Multiple lines allowed.
</p>
</itemd></item>

</itemtable>

</section>

<section name="splitoffs"><title>SplitOffs</title>
<p>
Beginning with fink 0.9.9, a single .info file can be used to build
multiple packages.  
The install phase begins as usual, with the execution of the 
<code>InstallScript</code> and <code>DocFiles</code> commands.
A <code>SplitOff</code> or <code>SplitOff<em>N</em></code> field, if present,
then triggers the creation of an
additional install directory.  Within the 
<code>SplitOff</code> or <code>SplitOff<em>N</em></code> field, the new install
directory is referred to as %i,
while the original install directory of the parent 
package is referred to as %I.
</p>
<p>
Each <code>SplitOff</code> and <code>SplitOff<em>N</em></code> field must
contain a number of fields of its
own.  In fact, it resembles a complete package description, but with
certain fields missing.  Here is what belongs in the sub-description
(by category):
</p>
<ul>
<li>Initial Data: Only the <code>Package</code> needs to be specified,
  everything else is inherited from the parent package.  You may modify
  <code>Type</code> and <code>License</code> by declaring the field
  within the <code>SplitOff</code> or <code>SplitOff<em>N</em></code>.  Percent
  expansion can be used, and
  it is often convenient to refer to the name %N of the parent
  package.</li>
<li>Dependencies: All of these are allowed.</li>
<li>Unpack Phase, Patch Phase, Compile Phase: These fields are irrelevant
  and will be ignored.</li>
<li>Install Phase, Build Phase: Any of these fields are allowed (except
  that SplitOffs cannot themselves contain additional SplitOffs).</li>
<li>Additional Data: These are inherited from the parent package but may
  be modified by declaring the field within the <code>SplitOff</code> or
  <code>SplitOff<em>N</em></code>.</li>
</ul>
<p>
Because %n-%v-%r is treated as the unique identifier of a package, you
must not have the same <code>Package</code> (at the
same <code>Version</code> and <code>Revision</code>) listed as
a <code>SplitOff</code> (or <code>SplitOff<em>N</em></code>) of
multiple packages. If you use variants, remember that each variant is
considered an independent package, so the following package layout is
forbidden:
</p>
<codeblock>Package: mime-base64-pm%type_pkg[perl]
Type: perl (5.12.3 5.12.4)
SplitOff: &lt;&lt;
  Package: mime-base64-pm-bin
&lt;&lt;</codeblock>
<p>
During the install phase, the <code>InstallScript</code> and 
<code>DocFiles</code> of the parent package are executed first.
Next comes processing of the <code>SplitOff</code> and
<code>SplitOff<em>N</em></code> fields. For each such field in turn,
the <code>InstallScript</code> of that field is run, and then the
<code>Files</code> command causes the listed files and directories
to be moved from the parent's installation directory %I to the
current installation directory %i.  Then the <code>DocFiles</code>
and other Installation Phase fields of the given <code>SplitOff</code>
or <code>SplitOff<em>N</em></code> package are
executed.  
</p>
<p>
At this time, the <code>SplitOff</code> is processed first (if
present), followed by each <code>SplitOff<em>N</em></code> in
numerical order by N. However, this may change in the future, so, for
example, instead of:
</p>
<codeblock>SplitOff: &lt;&lt;
  Description: Some header files
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: All other header files
  Files: include/*
&lt;&lt;</codeblock>
<p>
which only works correctly if <code>SplitOff</code> is processed
before <code>SplitOff2</code> it's safer to list explicitly the files
for each (or use more specific filename globs).
</p>
<p>
During the build phase, the pre/post install/remove scripts for each of
the packages is constructed by using the build phase commands which
were specified for that package.
</p>
<p>
Each package being built is required
to document the licensing arrangement in %i/share/doc/%n (and of course
%n takes a different value for each package).  Note that
<code>DocFiles</code> copies files rather than moving them, so it is
possible to install identical copies of the documentation into each 
of the packages by using <code>DocFiles</code> several times.
</p>

</section>

<section name="scripts"><title>Scripts</title>
<p>
The PatchScript, CompileScript and InstallScript fields allow you
to specify shell commands to be executed. The build directory
(<filename>%b</filename>) is the current directory when scripts are
executed. You should always use relative pathnames or
percent-expansions for files and directories in the fink hierarchy,
not complete absolute pathnames. Two forms are supported.
</p>
<p>
This field can be a simple list of commands. This is sort of like a
shell script. However, the commands are executed via system(), one
line at a time, so setting variables or changing the directory only
affects commands on that same line. Starting in a CVS version of fink
after 0.18.2, you can wrap long lines similar to normal shell scripts:
a backslash (<code>\</code>) at the end of a line indicates that the
next line is a continuation.
</p>
<p>
Alternately, you can embed a complete script here, using the
interpreter of your choice. As with any Unix script, the first line
must begin with <code>#!</code> followed by the full pathname of to
the interpreter and any needed flags (e.g., <code>#!/bin/csh</code>,
<code>#!/bin/bash -ev</code>, etc.). In this situation, the whole
*Script field is dumped into a temporary file that is then executed.
</p>

</section>

<section name="patches"><title>Patches</title>
<p>
If your package needs a patch to compile on Darwin (or to work with
fink), name the patch with the same name as the package description,
using the extension ".patch" instead of ".info" and put it in the same
directory as the .info file. 
Specify the filename of the patchfile with a line such as:
</p>
<codeblock>PatchFile: %n.patch</codeblock>
<p>
(For packages with variants, it may be better to use
<code>%{ni}.patch</code> .)
You must also give the MD5 sum of the patchfile in the 
<code>PatchFile-MD5</code> field, and specify 
<code>BuildDepends: fink (&gt;= 0.24.12)</code> (or a later version of fink).
</p>
<p>
When a <code>PatchFile<em>N</em></code> field is used, general custom
is to name the file <filename>%n-purpose-of-patch.patch</filename> to make it
easy to keep
track of. You must also use the field <code>PatchFile<em>N</em>-MD5</code> 
and specify <code>BuildDepends: fink (&gt;= 0.30.0)</code> (or a later 
version of fink).
</p>
<p>
When a <code>PatchFile</code> declaration is present, there is a
default <code>PatchScript</code> equivalent to:
</p>
<codeblock>PatchScript: patch -p1 &lt; %{PatchFile}</codeblock>
<p>
Using <code>PatchFile<em>N</em></code> appends the following to the
default <code>PatchScript</code> above:
</p>
<codeblock>patch -p1 &lt; %{PatchFile<em>N</em>}</codeblock>
<p>
This will be overridden if you supply a <code>PatchScript</code>
of your own (for example, to perform a substitution on the patch file
before applying it).
</p>
<p>
If you  need to have the user's chosen prefix in the patch file
it is recommended that you have a variable such as <code>@PREFIX@</code> 
instead of <code>/sw</code> in the patch and then use:
</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt; %{PatchFile} | patch -p1</codeblock>
<p>Patches should be in unidiff format and are normally generated by using:</p>
<codeblock>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</codeblock>
<p>
If you have used emacs to edit files, you can add <code>-x'*~'</code> to the
diff command above in order to exclude automatically-generated backup files.
</p>
<p>
It must also be noted that extremely large patches should not be put in cvs.
They should be put on a web/ftp server and specified using the
<code>SourceN:</code> field. If you don't have a website, fink project
admins can make the file available from fink's own website. If your
patch is larger than about 30Kb, you should consider making it a
separate download.
</p>

</section>

<section name="profile.d"><title>Profile.d scripts</title>
<p>
If your package needs some run-time initialization  (e.g. to setup environment
variables), you can use profile.d scripts.
These script fragments are sourced by the <filename>/sw/bin/init.[c]sh</filename>
scripts. Normally, all fink users will load these scripts in their shell startup
files (<filename>.cshrc</filename> and comparable files).
Your package must provide each script in two variants: one for sh compatible
shells (sh, zsh, bash, ksh, ...) and one for csh compatible shells (csh, tcsh).
They have to be installed as <filename>/sw/etc/profile.d/%n.[c]sh</filename>
(where %n as usual stands for the package name).
Also, their executable and read bits have to be set (i.e. install them with -m
755), otherwise they will not be loaded correctly.
</p>
<p>
If you just need to set some environment variables (for example, QTDIR to
'/sw'), you can use the RuntimeVars field which is provided as a convenient way
to achieve exactly this.
</p>

</section>

</chapter>

</document>
