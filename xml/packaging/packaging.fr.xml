<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="fr" >
<title>Création de paquets Fink</title>
<shorttitle>Paquets</shorttitle>
<cvsid>$Id: packaging.fr.xml,v 1.49 2004/11/02 02:38:51 michga Exp $</cvsid>

<preface>
<p>
Ce document explique comment créer des descriptions de paquets pour le gestionnaire de paquets de Fink.
Il fournit aussi des règles et un fil conducteur pour la distribution Fink.
Le format des fichiers de description et les règles de distribution sont en constante évolution. Il faut donc regarder en bas de page la ligne "Last changed..." pour détecter les changements.
Les informations contenues dans ce document correspondent à la description du format et des règles utilisées dans les versions de développement postérieures à la version 0.9.0 du gestionnaire de paquets <tt>fink</tt>.
</p>
<p>
Si vous créez des paquets pour Fink, vous avez tout intérêt à vous abonner à la liste de diffusion <link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>.
Si vous cherchez un moyen d'aider Fink et que vous avez des compétences dans ce domaine, vous pouvez aussi adopter un <link url="http://fink.sourceforge.net/pdb/nomaintainer.php">paquet sans mainteneur</link>.
</p>
</preface>

<chapter filename="intro">
<title>Introduction</title>
<shorttitle>Intro</shorttitle>

<section name="def1"><title>Qu'est-ce qu'un paquet ?</title>
<p>
Un paquet est un logiciel qui forme une unité atomique.
Un paquet contient en général un programme exécutable, les fichiers de données dont il a besoin et des catalogues de message pour l'internationalisation et la documentation.
Dans Fink, les paquets peuvent exister sous deux formes : la description de paquet et le paquet binaire prêt à installer.
</p>
<p>
La description de paquet est un fichier texte compréhensible par un être humain qui contient tout ce qui est nécessaire pour construire le paquet, c'est-à-dire pour créer le paquet binaire.
Les informations contenues dans la description de paquet comprennent des métainformations (comme le nom du paquet et une description de son objet), l'URL du source code et les instructions nécessaires à la configuration, compilation et construction du paquet.
La description peut être accompagnée d'une rustine.
</p>
<p>
Un paquet binaire est une archive qui contient effectivement les fichiers qui constituent le paquet, c'est-à-dire les exécutables, les fichiers de données, les catalogues de messages, les librairies, les fichiers include, etc...
Le paquet peut aussi contenir des métainformations pour le paquet lui-même. 
L'installation d'un paquet binaire consiste simplement à le dépaqueter, puisqu'il est déjà dans un format prêt à l'emploi.
Comme Fink construit les paquets avec le gestionnaire de paquets dpkg, les paquets binaires ont le format dpkg et ont une extension .deb.
</p>
</section>

<section name="ident"><title>Identification d'un paquet</title>
<p>
Un paquet est identifié par trois éléments : le nom du paquet, la version et la révision.
Tous ces éléments peuvent contenir des lettres minuscules (a-z), des nombres (0-9), des tirets (-), des signes plus (+) et des points (.).
Les autres caractères sont interdits.
En particulier, on ne peut utiliser de majuscules et de tiret de soulignement.
</p>
<p>
Le nom du paquet est tout simplement le nom du logiciel, par exemple openssh.
La version, aussi appelée version en amont, est l'identifiant de version du paquet original.
On peut utiliser des lettres dans la version, par exemple 2.9p1.
fink et dpkg les trient correctement.
La révision est un compteur qui est incrémenté quand la description du paquet change.
Il démarre à 1 et doit être remis à 1 quand la version en amont change.
La révision ne doit pas contenir de tiret.
Le nom complet du paquet est constitué de la concaténation de ces trois éléments, séparés par des tirets, par exemple openssh-2.9p1-2.
</p>

</section>
</chapter>

<chapter filename="format">
<title>Descriptions de paquets</title>
<shorttitle>Descriptions de paquets</shorttitle>

<section name="trees"><title>Arborescence</title>
<p>
Les descriptions de paquets sont lues à partir des répertoires <code>finkinfo</code>
situés dans le répertoire <filename>/sw/fink/dists</filename>.
La valeur de la variable "Trees" dans <filename>/sw/etc/fink.conf</filename> contrôle quels répertoires sont lus.
Le nom des fichiers de description de paquets doit être identique au nom complet du paquet suivi de l'extension ".info".
À partir de fink 0.13.0, on peut aussi n'utiliser que le nom du paquet suivi de l'extension ".info", de manière à simplifier les mises à jour.
</p>
<p>
L'arborescence des descriptions de paquets comprend plusieurs niveaux de répertoires.
En voici la liste de la racine au bas de l'arborescence :
</p>
<ul>
<li><code>dists</code> est à la racine.  Le répertoire <code>dists</code> est nécessaire pour les outils Debian.</li>
<li>La distribution. Il y en a trois : <code>stable</code>, <code>unstable</code> et <code>local</code>. Le répertoire <code>local</code>
est sous le contrôle de l'utilisateur/administrateur local. Les répertoires 
<code>stable</code> et <code>unstable</code> font partie de Fink.</li>
<li>L'arbre. L'arbre <code>main</code> - principal contient la plupart des paquets. Les logiciels cryptographiques sont situés dans un arbre spécial <code>crypto</code>, pour faciliter leur suppression, si cela s'avérait nécessaire.</li>
<li><code>finkinfo</code> et <code>binary-darwin-powerpc</code>. <code>finkinfo</code> contient les descriptions de paquets Fink et leurs rustines, tandis que <code>binary-darwin-powerpc</code> contient les paquets binaires <code>.deb</code>.</li>
<li>Sections. L'arbre <code>main</code> est subdivisé en sections thématiques pour en faciliter la gestion. L'arbre <code>crypto</code> n'est, lui, pas subdivisé en sections à l'heure actuelle.</li>
</ul>
</section>

<section name="format"><title>Format de fichier</title>
<p>
Les fichiers de description sont de simples listes de paires clés-valeurs, appelés également "champs".
Chaque ligne commence par une clé, suivie de deux-points et d'une espace, puis de la valeur de clé :
</p>
<codeblock>clé: valeur</codeblock>
<p>
Il y a deux notations pour les champs qui peuvent s'étendre sur plusieurs lignes.
</p><p>
La notation recommandée est basée sur la syntaxe "here-document" - "données ci-après", utilisée dans les scripts shell.
Dans cette syntaxe, la première ligne est composée de la clé, suivie du symbole redoublé <code>&lt;&lt;</code> comme valeur.
Toutes les lignes suivantes sont considérées comme valeurs, jusqu'à la rencontre d'une ligne ne contenant que <code>&lt;&lt;</code>.
L'exemple ci-dessus ressemble maintenant à :
</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>
Avec ce format, l'indentation est optionnelle, mais vous pouvez l'utiliser pour améliorer la lisibilité.
</p><p>
On peut imbriquer plusieurs "here-document". Cela arrive souvent dans un champ
 <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>.
 Ces champs contiennent d'autres champs (à lignes multiples), et cette syntaxe permet aux sous-champs de contenir eux mêmes des lignes multiples. Le même code de terminaison <code>&lt;&lt;</code> est utilisé pour les sous-champs utilisant la syntaxe "here-document".
En voici un exemple :
</p>
<codeblock>
SplitOff: &lt;&lt;
  Package: %N-shlibs
  InstallScript: &lt;&lt;
    ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
  &lt;&lt;
&lt;&lt;
</codeblock>
<p>
Une notation plus ancienne, obsolète, est basée sur la méthode de pliage des headers du RFC 822.
Une ligne commençant par une espace est traitée comme la continuation de la ligne précédente.
Exemple :
</p>
<codeblock>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</codeblock>
<p>
Notez l'indentation obligatoire des lignes.
</p><p>
Dans les deux formats, les lignes vides ainsi que celles débutant avec un dièse (#) sont ignorées.
Dans Fink, les clés (noms des champs) ne sont pas sensibles à la casse, vous pouvez donc écrire indifféremment : <code>InstallScript</code>, <code>installscript</code> ou
<code>INSTALLSCRIPT</code>.
Cependant, on conseille la première forme, où chaque initiale de mot est mise en majuscules, pour des raisons de lisibilité.
Certains champs prennent une valeur booléenne ; sont traitées comme vraies, les valeurs suivantes : "true", "yes", "on", "1" (toutes insensibles à la casse) ; toute autre valeur est traitée comme fausse.
</p>
</section>

<section name="percent"><title>Raccourcis %</title>
<p>
Pour vous rendre la vie plus facile, Fink gère un jeu de raccourcis sur certains champs.
Pour lever toute ambiguïté, vous pouvez utiliser des accolades autour des caractères qui doivent être considérés comme des raccourcis. Par exemple, <code>%{n}</code> a la même signification que <code>%n</code>.
Les raccourcis disponibles sont les suivants :</p>
<itemtable labeld="Signification" labelt="Raccourcis">
<item><itemt>%n</itemt>
<itemd>
<p>
le <em>n</em>om du paquet actif
</p>
</itemd></item>

<item><itemt>%N</itemt>
<itemd>
<p>
<em>N</em>om du paquet parent (le même que %n à moins d'être dans un
<code>SplitOff</code>)
</p>
<p>Note : si le champ <code>Package</code> d'un paquet parent contient %type_*[], la valeur de ces raccourcis <em>sera</em> incluse dans %N dans un bloc <code>SplitOff</code> (étant donné qu'elle est incluse dans %n dans le paquet parent).
</p>
</itemd></item>

<item><itemt>%e</itemt>
<itemd>
<p>
ère du paqu<em>e</em>t
</p>
</itemd></item>

<item><itemt>%v</itemt>
<itemd>
<p>
<em>v</em>ersion du paquet
</p>
</itemd></item>

<item><itemt>%r</itemt>
<itemd>
<p>
<em>r</em>évision du paquet
</p>
</itemd></item>

<item><itemt>%f</itemt>
<itemd>
<p>
nom complet du paquet, c'est-à-dire : %n-%v-%r
</p>
</itemd></item>

<item><itemt>%p, %P</itemt>
<itemd>
<p>
<em>p</em>réfixe d'installation de Fink, par exemple : <filename>/sw</filename>. Vous ne devez pas partir du principe que Fink est installé dans <filename>/sw</filename>, utilisez <code>%p</code> pour obtenir le bon chemin.
</p>
</itemd></item>

<item><itemt>%d</itemt>
<itemd>
<p>
répertoire <em>d</em>ans lequel le paquet est construit, par exemple : 
<filename>/sw/src/root-gimp-1.2.1-1</filename>. Ce répertoire temporaire sert de racine d'arborescence lors de la phase d'installation de la compilation d'un paquet. Vous ne devez pas partir du principe que <filename>root-%f</filename> est dans <filename>%p/src</filename>, car l'utilisateur peut changer ce répertoire en utilisant le champ <code>Buildpath</code> de <filename>/sw/etc/fink.conf</filename>.
</p>
</itemd></item>

<item><itemt>%D</itemt>
<itemd>
<p>
répertoire <em>D</em>ans lequel le paquet parent est construit (le même que %d à moins d'être dans un <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%i</itemt>
<itemd>
<p>
préf<em>i</em>xe complet de la phase d'installation, équivalent à %d%p
</p>
</itemd></item>

<item><itemt>%I</itemt>
<itemd>
<p>
préfixe d'<em>I</em>nstallation du paquet parent, équivalent à %D%P (identique 
à %i à moins d'être dans un <code>SplitOff</code>)
</p>
</itemd></item>

<item><itemt>%a</itemt>
<itemd>
<p>
chemin des rustines
</p>
</itemd></item>

<item><itemt>%b</itemt>
<itemd>
<p>
répertoire de compilation, exemple : <filename>/sw/src/gimp-1.2.1-1/gimp-1.2.1</filename>.Vous ne devez pas partir du principe que <filename>%f</filename> est dans <filename>%p/src</filename>, car l'utilisateur peut changer ce répertoire en utilisant le champ <code>Buildpath</code> de <filename>/sw/etc/fink.conf</filename>.
Le dernier sous-répertoire tire son nom du champ <code>Source</code>, ou du champ <code>SourceDirectory</code> (si ce champ existe), ou bien n'existe pas si le champ <code>NoSourceDirectory</code> a pour valeur <code>true</code> (vrai).
</p>
<p>
Note: ne l'utilisez que s'il n'y a pas d'autres possibilités. Le répertoire de compilation est
le répertoire actif lorsque les scripts sont exécutés ; vous devez utiliser des chemins relatifs dans les commandes.
</p>
</itemd></item>

<item><itemt>%c</itemt>
<itemd>
<p>
paramètres pour <em>c</em>onfigure : <code>--prefix=%p</code> plus tout autre élément spécifié avec ConfigureParams
</p>
</itemd></item>

<item><itemt>%m</itemt>
<itemd>
<p>
chaîne spécifiant l'architecture de la <em>m</em>achine .  Identique au résultat de la commande <code>uname -p</code>. Les valeurs habituelles sont 'powerpc' pour les machines ppc
and 'i386' pour les machines x86. (Introduit dans les versions CVS de fink postérieures à la 0.12.1.)
</p>
</itemd></item>

<item><itemt>%%</itemt>
<itemd>
<p>
signe pourcentage (%) (ce signe n'est pas interprété en fonction de ce qui le suit). L'interprétation se fait de gauche à droite, si bien que %%n n'a rien à voir avec le nom du paquet,  mais représente la chaîne %n.  (Introduit dans fink-0.18.0).
</p>
</itemd></item>

<item><itemt>%type_raw[<em>type</em>], %type_pkg[<em>type</em>]</itemt>
<itemd>
<p>
fonction de pseudo-hachage retournant le sous-type du <em>type</em> donné. Voir la documentation sur le champ <code>Type</code> plus bas.
La forme _raw correspond à la chaîne précise du sous-type, tandis que la forme _pkg correspond à la même chaîne dont tous les points auraient été enlevés (suivant les conventions de nommage des paquets - language-version - de Fink et pour d'autres usages réservés aux experts). (Introduit dans une version CVS de Fink ultérieure à la version 0.19.2).
</p>
</itemd></item>

<item><itemt>%{ni}, %{Ni}</itemt>
<itemd>
<p>
la partie <em>i</em>nvariante du <em>n</em>om  du paquet. Identiques à %n et %N, à l'exception près que tous les %type_pkg[] et %type_raw[] sont occultés.
(Introduit dans une version CVS de Fink ultérieure à la version 0.19.2). Vous devez utiliser %{ni} et %{Ni} pour éviter de possibles confusions avec les raccourcis %n et %N.
</p>
</itemd></item>
<item><itemt>%{default_script}</itemt>
<itemd>
<p>Uniquement valide dans les champs <code>*Script</code>, correspond au contenu par défaut de ce type de champ. Sa valeur dépend souvent du champ <code>Type</code> et est toujours définie (même si elle vide). Lorsque ce raccourci est utilisé dans un <code>SplitOff: InstallScript</code>, son interprétation correspond à la valeur par défaut du champ <em>parent</em>, bien que la valeur par défaut de <code>InstallScript</code> dans un <code>SplitOff</code> soit vide. (Introduit dans fink-0.20.6)
</p>
</itemd></item>
</itemtable>

</section>
</chapter>

<chapter filename="policy">
<title>Règles de distribution des paquets</title>
<shorttitle>Règles</shorttitle>

<section name="licenses"><title>Licences de paquets</title>
<p>
Les paquets inclus dans Fink ont différents types de licences.
La plupart d'entre elles stipulent une restriction sur la redistribution des sources complètes et particulièrement sur la distribution des binaires.
Certains paquets ne peuvent être inclus dans la distribution binaire de Fink à cause de ces licences restrictives.
C'est pourquoi il est essentiel que les mainteneurs de paquets vérifient,  scrupuleusement, les licences de leurs paquets.
</p>
<p>
Chaque paquet distribué en tant que binaire doit contenir une copie de la licence.
Elle doit être installée dans le répertoire de documentation, c'est à dire dans <filename>%p/share/doc/%n</filename>.
(Dans InstallScript, il faut, évidemment, utiliser %i au lieu de %p.
Le champ DocFiles gère les détails automatiquement.)
S'il n'y a pas de licence explicite dans le source original, placez un fichier texte contenant une note à propos du statut du paquet.
La plupart des licences requièrent que celle-ci accompagne toute distribution.
La règle de Fink est de toujours faire ainsi, même si ce n'est pas explicitement requis.
</p>
<p>
Pour automatiser le plus possible la maintenance de la distribution binaire, tout paquet distribué doit avoir un champ <code>License</code>.
Ce champ indique la nature de la licence et est utilisé pour décider quels paquets font partie de la distribution et quels paquets doivent en être exclus.
Le champ ne peut exister que si les termes réels de la licence sont inclus dans le paquet binaire, comme expliqué ci-dessus.
</p>
<p>
Pour que le champ <code>License</code> ait une utilité, n'utilisez qu'une seule des valeurs prédéfinies suivantes.
Si vous construisez un paquet qui ne rentre pas dans ces catégories, demandez de l'aide sur la liste des développeurs.
</p>
<ul>

<li><code>GPL</code> - la licence générale publique GNU.
Cette licence requiert que le source soit accessible au même endroit que le binaire.</li>

<li><code>LGPL</code> - la licence publique GNU moins générale.
Cette licence requiert que le source soit accessible au même endroit que le binaire.</li>

<li><code>GPL/LGPL</code> - c'est un cas spécial pour les paquets dans lesquels une partie est sous licence GPL (par exemple les exécutables) et une autre partie est sous licence LGPL (par exemple les librairies).</li>

<li><code>BSD</code> - pour les licences style BSD.
Ceci inclue la licence BSD dite "original", la licence BSD "modified" et la licence MIT. La licence Apache compte aussi parmi les licences BSD. Avec ces licences, la distribution du code source est optionnelle.
</li>

<li><code>Artistic</code> - pour la licence "Artistic" et ses dérivées.</li>

<li><code>Artistic/GPL</code> - licence duale, combinée Artistic/GPL.</li> 

<li><code>GNU Free Documentation License</code> et <code>Linux
Documentation Project</code> - si la documentation incluse dans un paquet l'est explicitement sous une de ces licences, alors ce sera indiqué par l'ajout de <code>/GFDL</code> ou <code>/LDP</code> au code de la licence, ce qui donne l'une des combinaisons autorisées suivantes : "GFDL", "GPL/GFDL", "LGPL/GFDL", "GPL/LGPL/GFDL", "LDP", ou "GPL/LGPL/LDP".
</li>

<li><code>OSI-Approved</code> - pour les autres licences Open Source approuvées par l'Initiative Open Source (OSI) <link url="http://www.opensource.org/"></link>. L'une des règles de l'OSI est que la libre distribution de binaires et de sources est autorisée. Ce code peut aussi servir de cadre aux paquets à licence duale.</li>

<li><code>Restrictive</code> - pour les licences restrictives.
Utilisez ceci pour les paquets qui sont accessibles en tant que sources à usage libre auprès de l'auteur, mais dont la libre redistribution n'est pas autorisée. </li>

<li><code>Restrictive/Distributable</code> - pour des licences restrictives qui admettent une distribution des binaires et du source.
Utilisez ceci pour les paquets qui sont accessibles en tant que sources auprès de l'auteur, autorisent la distribution du source et des binaires, mais ont des restrictions qui en font des licences non open-sources.</li>

<li><code>Commercial</code> - pour des licences restrictives de type commercial.
Utilisez ceci pour des paquets  de type commercial ( par exemple graticiels, partagiciels qui n'autorisent pas la libre redistribution du source ou des binaires.</li>

<li><code>Public Domain</code> - pour des paquets qui sont dans le domaine public, c'est-à-dire que l'auteur a abandonné ses droits sur le code. Ces paquets n'ont aucune licence d'aucune sorte et tout un chacun peut en faire ce que bon lui semble.</li>
</ul>
</section>

<section name="prefix"><title>Interférence avec le système de base</title>
<p>
Fink est une distribution additionnelle qui est installée dans un répertoire distinct du système de base.
Il est essentiel qu'un paquet n'installe aucun fichier en dehors du répertoire de Fink.
</p>
<p>
Il peut y avoir des exceptions quand on ne peut faire autrement, par exemple avec XFree86.
Dans ce cas, le paquet doit tester l'existence de fichiers avant l'installation et refuser de s'installer si cela amène à écraser des fichiers déjà existants.
Le paquet doit s'assurer que tous les fichiers qu'il aura installés en dehors du répertoire de Fink seront supprimés lorsque le paquet lui-même sera éliminé, ou que ces fichiers ne causeront aucun problème s'ils sont laissés sur place (c'est-à-dire qu'ils devront tester l'existence des binaires avant de les appeler, etc...).
</p>
</section>

<section name="sharedlibs"><title>Librairies partagées</title>
<p>
Fink a de nouvelles règles en ce qui concerne les librairies partagées, règles qui prennent effet à compter de février 2002.
Cette partie de la documentation donne des explications sur la version 4 de ces règles, qui coïncide avec la publication de la distribution 0.5.0 de Fink.
Nous commencerons par un bref résumé, puis nous passerons à une revue de détails.
</p><p>
Tout paquet qui construit des librairies partagées et qui, soit (1) est placé  dans la branche stable, soit (2) est un nouveau paquet de Fink, doit gérer ses librairies partagées conformément aux règles de Fink. Ceci signifie :</p>
<ul>
<li>vérifier, à l'aide de <code>otool -L</code>, que le nom d'installation de chaque librairie, ses numéros de versions de compatibilité et actuels sont corrects</li>
<li>mettre les librairies partagées dans un paquet séparé (exception faite pour les liens de libfoo.dylib vers nom d'installation), et inclure le champ <code>Shlibs</code> dans ce paquet</li>
<li>mettre les headers et les liens finaux venant de libfoo.dylib dans un paquet caractérisé par <code>BuildDependsOnly: True</code>, et prévoir qu'aucun autre paquet ne dépendra de lui.</li>
</ul>
<p>
Un mainteneur, qui a de bonnes raisons de s'écarter de ces règles et ne scinde pas le paquet, devra expliquer pourquoi dans le champ DescPackaging.
</p><p>
Pour certains paquets, tout peut être fait avec un paquet principal et un paquet -shlibs ; dans d'autres cas, vous aurez besoin d'un troisième paquet. Le nouveau champ <code>SplitOff</code> facilite ce processus.
</p><p>
Quand trois paquets sont nécessaires, il y a deux façons différentes de les nommer, suivant que les librairies (option 1) ou les binaires (option 2) sont les fonctionnalités les plus importantes du paquet. 
Pour l'option 1, utilisez le schéma suivant :
</p>
<itemtable labeld="Contenu" labelt="Paquet">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Librairies partagées</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>Headers</p></itemd></item>
<item><itemt><code>foo-bin</code></itemt>
<itemd><p>Binaires, etc...</p></itemd></item>
</itemtable>

<p>Pour l'option 2, utilisez :</p>
<itemtable labeld="Contenu" labelt="Paquet">
<item><itemt><code>foo-shlibs</code></itemt>
<itemd><p>Librairies partagées</p></itemd></item>
<item><itemt><code>foo-dev</code></itemt>
<itemd><p>Headers</p></itemd></item>
<item><itemt><code>foo</code></itemt>
<itemd><p>Binaires, etc...</p></itemd></item>
</itemtable>

<p>
Avec l'option 2, il est plus difficile de mettre à jour un paquet existant : quand vous réalisez la mise à jour, vous devez ajouter <code>BuildDepends: foo-dev</code> à chaque paquet qui a un champ <code>Depends: foo</code>.
Autre problème de mise à jour à garder à l'esprit : un paquet qui dépend indirectement du vôtre (par l'intermédiaire d'un paquet tiers) peut nécessiter qu'on lui ajoute <code>BuildDepends: foo</code> ou <code>BuildDepends: foo-dev</code> pour assurer une mise à jour correcte. C'est à vous de veiller à ce que que le champ <code>BuildDepends</code> soit renseigné si nécessaire.
</p>
<p><em>Règles détaillées</em></p>
<p>
Nous allons désormais discuter de tout cela en détails, premièrement nous aborderons les règles applicables aux logiciels nouvellement portés, puis nous nous tournerons vers la question de la mise à  jour de paquets existant dans fink.  Comme exemples des règles en action, voir les paquets libpng, libjpeg et libtiff.
</p><p>
Les logiciels portés sur Darwin doivent, autant que possible, construire des librairies partagées.
(Les mainteneurs de paquets sont libres de construire des librairies statiques, si cela s'avère plus approprié pour leurs paquets; ils peuvent aussi soumettre des paquets contenant uniquement des librairies statiques, s'ils le souhaitent.)
Quand on construit des librairies partagées, <em>deux</em> paquets - nommés foo et foo-shlibs -, étroitement liés, doivent être construits. Les librairies partagées vont dans foo-shlibs, et les headers dans foo. 
Ces deux paquets peuvent être réalisés avec un seul fichier .info, en utilisant le champ <code>SplitOff</code>, comme indiqué ci-dessous.  
(En fait, il est souvent nécessaire de construire plus de deux paquets à partir du source, et cela peut être fait en utilisant <code>SplitOff2</code>, <code>SplitOff3</code>, etc...)
</p><p>
Chaque paquet logiciel pour lequel des librairies partagées peuvent être construites doit avoir un <em>numéro de version majeure</em> N.  Le numéro de version majeure n'est censé changer que lorsqu'un changement irréversible se produit dans l'API de la librairie.
Fink utilise la convention de nommage suivante : si le nom en amont du paquet est bar, alors les paquets fink sont appelés barN et barN-shlibs. (Ceci n'est appliqué rigoureusement qu'à de nouveaux paquets ou lorsque le numéro de version majeure change).
Par exemple, le numéro de version majeure pour le paquet pré-existant libpng était 2, mais les versions récentes de la librairie ont pour numéro de version majeure 3. Il y a donc, maintenant, 4 paquets fink pour gérer ceci : libpng, libpng-shlibs, libpng3, libpng3-shlibs.
Seul libpng ou libpng3 peut être installé à un moment donné, mais libpng-shlibs et libpng3-shlibs peuvent être installés en même temps.
(Notez que deux fichiers .info suffisent à construire ces quatre paquets.)
</p><p>
La librairie partagée elle-même et certains fichiers liés seront placés 
dans le paquet barN-shlibs ; les fichiers "include" et un certain nombre d'autres fichiers seront placés dans le paquet barN. Il ne peut y avoir de recouvrement de fichiers entre ces deux paquets, et tout ce qui est placé dans barN-shlibs doit avoir un nom chemin qui, d'une façon ou d'une autre, contienne le numéro de version majeure N. Dans de nombreux cas, votre paquet aura besoin de certains fichiers à l'exécution, fichiers qui sont généralement installés dans <filename>%i/lib/bar/</filename> ou <filename>%i/share/bar/</filename> ; vous devrez adapter les chemins d'installation à <filename>%i/lib/bar/N/</filename> ou <filename>%i/share/bar/N/</filename>.
</p><p>
Tous les autres paquets dépendant de bar, version majeure N, devront utiliser les dépendances :
</p>
<codeblock>
  Depends: barN-shlibs
  BuildDepends: barN
</codeblock>
<p>
Quand ce système sera complètement opérationnel, il ne sera plus permis à un autre paquet de dépendre de barN lui-même. (Pour des raisons de compatibilité arrière, de telles dépendances sont autorisées pour des paquets pré-existants.) Ceci est signalé aux autres développeurs par un champ de type booléen :
</p>
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>
dans la description du paquet barN.
</p><p>
Si votre paquet inclut à la fois des librairies partagées et des binaires, et si les binaires doivent être présents à l'exécution (et pas seulement à la compilation), alors les binaires doivent être regroupés dans un troisième paquet, qui peut être appelé barN-bin.
Les autres paquets peuvent dépendre de barN-bin comme de barN-shlibs.
</p><p>
Lors de la construction de librairies partagées de version majeure N, il est important que le "nom d'installation" soit <filename>%p/lib/bar.N.dylib</filename>.  
(Vous pouvez trouver le nom d'installation en exécutant <code>otool -L</code> sur votre librairie.)
Le fichier librairie réel doit être installé sous le nom de :
</p>
<codeblock>
  %i/lib/bar.N.x.y.dylib
</codeblock>
<p>
et votre paquet doit créer des liens symboliques :
</p>
<codeblock>
  %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
</codeblock>
<p>Si la librairie statique est aussi construite, elle doit être installée sous le nom de :
</p>
<codeblock>
  %i/lib/bar.a
</codeblock>
<p>
Si le paquet utilise libtool, ceci est généralement géré automatiquement, mais, dans tous les cas,  vous devez vérifier que tout s'est passé correctement.
Vous devez aussi vérifier que la version courante et la version de compatibilité sont définies de façon appropriée à vos librairies partagées. (On peut trouver les numéros de version avec la commande 
<code>otool -L</code>.)
</p><p>
Les fichiers sont scindés entre les deux paquets comme suit :
</p>
<ul>
<li>  dans le paquet barN-shlibs :
<codeblock>
  %i/lib/bar.N.x.y.dylib
  %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar/N/*
  %i/share/bar/N/*
  %i/share/doc/barN-shlibs/*
</codeblock></li>
<li>  dans le paquet barN :
<codeblock>
  %i/include/*
  %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar.a
  %i/share/doc/barN/*
  autres fichiers, si nécessaire
</codeblock></li></ul>
<p>
Notez que les deux paquets doivent contenir des informations sur la licence, mais que les répertoires contenant les fichiers de documentation (DocFiles) sont différents.
</p><p>
Tout ceci est facile à réaliser en utilisant le champ <code>SplitOff</code>. Voici comment l'exemple ci-dessus serait (partiellement) implémenté :
</p>
<codeblock>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/bar.N.x.y.dylib lib/bar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;
</codeblock>
<p>
Durant l'exécution du champ <code>SplitOff</code>, les fichiers et les répertoires spécifiés sont déplacés du répertoire d'installation %I du paquet principal vers le répertoire d'installation %i du paquet splitoff.  (Il y a une convention similaire pour les noms : %N est le nom du paquet principal, et %n est le nom du paquet actif.)
La commande <code>DocFiles</code> place ensuite une copie de la documentation dans <filename>%i/share/doc/barN-shlibs</filename>.
</p><p>
Notez que nous avons inclus la version courante exacte de barN-shlibs comme dépendance du paquet principal barN (qui peut être abrégé en %N-shlibs (= %v-%r) ).
Ceci assure que les versions correspondent, et garantit aussi que barN "hérite" automatiquement de toutes les dépendances de barN-shlibs.
</p>
<p><em>Le champ BuildDependsOnly</em>
</p><p>
Lors de mises à jour de librairies, il est souvent nécessaire d'avoir deux versions des headers pendant une période de transition. L'une d'entre elles est utilisée pour compiler certaines choses, l'autre pour en compiler d'autres. C'est pouquoi, les paquets contenant des headers doivent être construits avec soin. Si foo-dev et bar-dev contiennent tous les deux des headers qui se recouvrent, alors foo-dev doit déclarer :
</p>
<codeblock>
  Conflicts: bar-dev
  Replaces: bar-dev
</codeblock>
<p>de même, bar-dev déclare des Conflicts/Replaces sur foo-dev.
</p><p>
De plus, les deux paquets doivent déclarer :
</p>
<codeblock>
  BuildDependsOnly: True
</codeblock>
<p>Ceci empêche d'autres paquets de dépendre de foo-dev ou de bar-dev, car de telles dépendances enrayeraient le mécanisme du Conflicts/Replaces.
</p><p>
Il existe certains paquets contenant des headers et pour lesquels il ne semble pas approprié de déclarer une valeur "true" pour BuildDependsOnly to be true. Dans ce cas, le paquet doit déclarer : 
</p>
<codeblock>
  BuildDependsOnly: False
</codeblock>
<p>et la raison pour laquelle cela est fait doit être mentionnée dans le champ DescPackaging.
</p><p>
Le champ BuildDependsOnly ne doit être mentionné dans le fichier .info du paquet que si ce paquet contient des headers installés dans /sw/include.
</p><p>
À partir de la version 0.20.5 de fink, "fink validate" affichage un message pour tout .deb qui contient des headers et au moins une dylib, et qui ne donne pas la valeur "true" ou "false" au champ BuildDependsOnly. (Il est possible que, dans les versions postérieures de fink, ce message soit étendu aux cas des .deb contenant des headers et une librairie statique). 
</p>
<p><em>Le champ Shlibs :</em>
</p><p>
En sus de placer les librairies partagées dans le bon paquet, suivant en cela la version 4 de cette règle, vous devez également déclarer toutes les librairies partagées en utilisant le champ <code>Shlibs</code>.
Ce champ contient une ligne distincte pour chaque librairie partagée ; la ligne comprend le <code>nom d'installation</code> de la librairie, la <code>version de compatibilité</code>, et des informations de dépendance qui indiquent le paquet de Fink qui fournit cette librairie à cette version de compatibilité.
La dépendance doit être déclarée sous la forme <code> foo (>= version-révision)</code> où <code>version-révision</code> correspond à la <em>première</em> version du paquet de Fink qui fournit cette librairie (avec cette version de compatibilité). Par exemple, une déclaration :</p>
<codeblock>
  Shlibs: &lt;&lt;
    %p/lib/bar.1.dylib 2.1.0 bar1 (>= 1.1-2)
  &lt;&lt;
</codeblock>
<p>indique qu'une librairie, dont le <code>nom d'installation</code> est %p/lib/bar.1.dylib et <code>la version de compatibilité </code> est 2.1.0, a été installée à partir de la version 1.1-2 du paquet <em>bar1</em>.  De plus, cette déclaration équivaut à la promesse du mainteneur qu'une librairie avec ce nom et une version de compatibilité au moins égale à 2.10 sera toujours présente dans les versions ultérieures du paquet <em>bar1</em>.
</p><p>
Notez l'utilisation de %p dans le nom de la librairie, ce qui permet à tous les utilisateurs de Fink de trouver le bon <code>nom d'installation</code>, quel que soit le préfixe qu'ils ont choisi.
</p><p>
Quand un paquet est mis à jour, on copie tout simplement le champ <code>Shlibs</code> dans la nouvelle version/révision du paquet. L'exception à cette règle survient quand la <code>version de compatibilité</code> est incrémentée : dans ce cas, le numéro de version
dans les informations de dépendance doit être changé pour la version/révision courante (celle  qui est la première à fournir la librairie avec le nouveau numéro de version de compatibilité).
</p><p>
<em>Mesures à prendre quand le numéro de version majeure change :</em>
</p><p>
Si le numéro de version majeure change de N à M, vous devez créer deux nouveaux paquets barM et barM-shlibs. Le paquet barM-shlibs ne peut recouvrir le paquet barN-shlibs, puisque de nombreux utilisateurs installeront les deux simultanément.
Dans le paquet barM, vous devez utiliser les dépendances :
</p>
<codeblock>
  Conflicts: barN
  Replaces: barN
</codeblock>
<p>
et vous devez modifier barN, de façon similaire, pour inclure les dépendances :
</p>
<codeblock>
  Conflicts: barM
  Replaces: barM
</codeblock>
<p>
Les utilisateurs verront alors barN et barM apparaître et disparaître au gré de la construction de divers paquets dépendant de l'une ou l'autre version de la librairie partagée, tandis que barN-shlibs et barM-shlibs resteront installés de façon permanente.
</p><p>
<em>Mise à jour d'un paquet de fink existant :</em>
</p><p>
Le meilleur moyen de mettre à jour un paquet fink existant qui installe des librairies, qu'elles soient statiques ou partagées, est de créer une nouvelle version foo du paquet, accompagné d'un nouveau paquet foo-shlibs, qui satisfait aux règles ci-dessus.
Si des librairies partagées (ou d'autres fichiers présents maintenant dans foo-shlibs) étaient installées auparavant, ces nouveaux paquets doivent stipuler : 
</p>
<codeblock>
  Replaces: foo (&lt;&lt; earliest.compliant.version)
</codeblock>
<p>
de façon que la mise à jour soit transparente pour les utilisateurs.
(Vous <em>ne</em> devez <em>pas</em> utiliser "Conflicts: foo", car cela empêche la mise à jour.)
</p><p>
Après mise à jour, les paquets qui stipulent "Depends: foo" continueront à fonctionner normalement. Toutefois, vous devez contacter les mainteneurs de tous ces paquets fink et les presser de modifier leurs paquets pour qu'ils stipulent, dès que possible, "Depends: foo-shlibs, BuildDepends: foo".  
Vous ne pourrez pas créer de nouveaux paquets fooM, fooM-shlibs qui implémentent une version majeure de la librairie partagée tant qu'ils ne l'auront pas fait.
</p><p>
Les paquets fink existants qui n'ont pas utilisé le bon nom d'installation ou qui n'ont pas utilisé un nom correct ou des liens symboliques pour les libraires partagées doivent être mis à jour soigneusement, au cas par cas.
Si vous êtes embarrassé pour choisir une stratégie de mise à jour rendant vos paquets compatibles avec les nouvelles règles, parlez-en sur la liste de diffusion fink-devel.
</p><p>
<em>Paquets contenant des fichiers binaires et des librairies :</em>
</p><p>
Quand un paquet en amont contient tout à la fois des fichiers binaires et des librairies, la construction des paquets fink doit être menée avec soin. Dans certains cas, les seuls fichiers binaires seront des fichiers du genre <code>foo-config</code>, qui sont censés n'être utilisés qu'à la compilation, et jamais à l'exécution. Dans ces cas, les binaires peuvent aller avec les headers dans le paquet <code>foo</code>.
</p><p>
Dans d'autres cas, les fichiers binaires seront nécessaires à d'autres paquets pendant l'exécution, et devront être regroupés dans un paquet fink séparé avec un nom du type <code>foo-bin</code>.
Le paquet <code>foo-bin</code> doit dépendre du paquet <code>foo-shlibs</code>, et les mainteneurs d'autres paquets doivent être encouragés à utiliser :
</p>
<codeblock>
  Depends: foo-bin
  BuildDepends: foo
</codeblock>
<p>
ainsi la gestion de foo-shlibs sera assurée implicitement.
</p><p>
Néanmoins, la mise à jour pose un problème dans ce cas, puisque les utilisateurs ne seront pas invités à installer <code>foo-bin</code>. Pour résoudre ce problème, tant que tous les autres mainteneurs de paquets n'ont pas révisé leur paquets comme indiqué ci-dessus, votre paquet <code>foo</code> peut stipuler :
</p>
<codeblock>
  Depends: foo-shlibs (= exact.version), foo-bin
</codeblock>
<p>
Ceci forcera l'installation de foo-bin sur la plupart des systèmes, jusqu'au moment où les mainteneurs de paquets auront mis à jour leurs paquets qui dépendent de <code>foo</code>.
</p>
</section>

<section name="perlmods"><title>Modules Perl</title>
<p>La réglementation de Fink pour les modules perl, effective à partir de mai 2003, a été modifiée en avril 2004.
</p><p>
Traditionnellement, les paquets Fink pour les modules Perl avaient un suffixe <code>-pm</code>, et  étaient compilés en utilisant la directive <code>Type: perl</code>, qui place les modules Perl dans <filename>/sw/lib/perl5</filename> et/ou dans <filename>/sw/lib/perl5/darwin</filename>.  Avec la nouvelle réglementation, cet emplacement n'est autorisé que pour les modules perl qui sont indépendants de la version de perl utilisée pour les compiler (et qui ne dépendent pas d'autres modules perl dépendants des versions).
</p><p>
Les modules Perl qui sont dépendants des versions sont les modules dits XS, qui contiennent fréquemment du code C compilé ainsi que des routines écrites en langage Perl.
Il y a de nombreuses façons de les reconnaître, notamment par la présence d'un fichier avec un suffixe <code>.bundle</code>.
</p><p>
Un module perl qui dépend des versions doit être construit en utilisant un binaire dont le nom comporte le numéro de version de perl, comme <code>perl5.6.0</code>, et doit stocker ses fichiers dans des sous-répertoires des répertoires standards de perl ; les noms de ces sous-répertoires doivent comporter le numéro de version de perl, comme <filename>/sw/lib/perl5/5.6.0</filename> et <filename>/sw/lib/perl5/5.6.0/darwin</filename>.
Par convention, les noms des paquets utilisent le suffixe <code>-pm560</code> pour un module Perl de version 5.6.0.  Des conventions de stockage et de nommage similaires s'imposent pour les autres versions de perl, qui incluent perl 5.6.1 (dans les seules branches 10.2), perl 5.8.0, perl 5.8.1 et perl 5.8.4 (bientôt disponible).  
</p><p>
La directive <code>Type: perl 5.6.0</code> utilise automatiquement le binaire dont le nom comporte le numéro de version de perl et stocke les fichiers dans les bons sous-répertoires.
(Cette directive est disponible à partir de la version 0.13.0 de fink.)
</p><p>
Sous la réglementation de mai 2003, il était permis de créer un paquet <code>-pm</code>, qui est essentiellement un paquet "lot", qui charge la variante <code>-pm560</code> ou une autre variante existante.
Cette stratégie est déconseillée sous la réglementation d'avril 2004, et sera complètement interdite après une période de transition. (La seule exception sera le paquet <code>storable-pm</code> qui doit se présenter sous cette forme pour le bootstrap).
</p>
<p>À partir de la version 0.20.2 de fink, le paquet virtuel system-perl "fournit" automatiquement certains modules perl quand la version de Peerl présente sur le système est supérieure ou égale à 5.8.0. Dans le cas de system-perl-5.8.1-1, ces modules sont les suivants : 
<em>attribute-handlers-pm581, cgi-pm581, digest-md5-pm581, file-spec-pm581, file-temp-pm581, filter-simple-pm581, filter-util-pm581, getopt-long-pm581, i18n-langtags-pm581, libnet-pm581, locale-maketext-pm581, memoize-pm581, mime-base64-pm581, scalar-list-utils-pm581, test-harness-pm581, test-simple-pm581, time-hires-pm581.</em>
(Cette liste était légèrement différente dans la version 0.20.1 de fink ; les mainteneurs de paquet sont invités à vérifier que c'est bien sur la nouvelle liste qu'ils se basent). 
</p>
<p>
Effective à partir de la version 0.13.0 de fink, la commande <code>fink validate</code>, quand elle est appliquée à un fichier <code>.deb</code>, teste si le paquet fink est un module XS qui a été installé dans un répertoire dont le nom ne comporte pas le numéro de version, et, génère, dans ce cas, une alerte.
</p>

</section>
<section name="emacs"><title>Règles Emacs</title>
<p>Le projet Fink a choisi de suivre les règles du projet Debian en ce qui concerne emacs, avec quelques différences. (Vous trouverez les règles Debian sur <link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">http://www.debian.org/doc/packaging-manuals/debian-emacs-policy</link>.)
Il existe deux différences dans les règles de Fink. Premièrement, ces règles ne s'appliquent, à l'heure actuelle, qu'aux paquets emacs20 et emacs21 de fink. (Ceci pourra changer à l'avenir). Deuxièmement, contrairement aux règles Debian, les paquets Fink peuvent installer des objets directement dans /sw/share/emacs/site-lisp.
</p>

</section>
</chapter>

<chapter filename="fslayout">
<title>Organisation des fichiers</title>
<shorttitle>Organisation des fichiers</shorttitle>

<preface>
<p>
Les règles d'organisation des fichiers suivantes font partie intégrante des règles de construction des paquets de Fink.
</p>
</preface>

<section name="fhs"><title>Hiérarchie standard des fichiers</title>
<p>
Fink suit l'esprit de <link url="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</link> - Norme de hiérarchie du système de fichiers, ou FHS en raccourci. Il ne peut qu'en suivre l'esprit car FHS a été conçu pour les vendeurs de systèmes qui ont le contrôle des arborescences <filename>/</filename> et <filename>/usr</filename>. Fink n'est qu'une distribution supplémentaire qui ne contrôle que son répertoire (ou préfixe) d'installation. Les exemples ci-dessous utilisent le préfixe par défaut, soit <filename>/sw</filename>.
</p>
</section>

<section name="dirs"><title>Répertoires</title>
<p>
Les fichiers doivent être placés dans les sous-répertoires suivant de l'arborescence :
</p>

<itemtable labeld="Utilisation" labelt="Répertoire">

<item><itemt><filename>/sw/bin</filename></itemt>
<itemd>
<p>
Ce répertoire est dédié aux exécutables généraux. Il n'existe pas de sous-répertoire.</p>
</itemd></item>

<item><itemt><filename>/sw/sbin</filename></itemt>
<itemd>
<p>
Ce répertoire correspond aux exécutables pour administrateurs système. Les démons lancés en tâche de fond y sont placés. Il n'y a pas de sous-répertoire.
</p>
</itemd></item>

<item><itemt><filename>/sw/include</filename></itemt>
<itemd>
<p>
Ce répertoire stocke les headers C et C++. On peut créer autant de sous-répertoires que nécessaire. Si un paquet installe des headers qui peuvent être confondus avec des headers standard C, les headers du paquet <em>doivent</em> être installés dans un sous-répertoire.
</p>
</itemd></item>

<item><itemt><filename>/sw/lib</filename></itemt>
<itemd>
<p>
Ce répertoire est destiné aux fichiers de données et librairies dépendants de l'architecture du système. Les librairies statiques et partagées doivent être placées dans <filename>/sw/lib</filename>, sauf s'il existe une bonne raison pour ne pas le faire. C'est également là que sont placés les exécutables qui ne  doivent pas être directement lancés par l'utilisateur (dans le cas contraire, ils sont placés dans libexec).
</p>
<p>
On peut créer un sous-répertoire spécifique à un paquet, afin d'y mettre des données privées ou des modules chargeables. Pensez à utiliser des noms de répertoire qui garantissent la compatibilité entre versions. Il est bon d'utiliser le numéro de version majeur du paquet dans le nom du sous-répertoire ou à un niveau inférieur de la hiérarchie ; par exemple, <filename>/sw/lib/perl5</filename> ou <filename>/sw/lib/apache/1.3</filename>. Faites attention si vous utilisez le type d'hôte dans le nom des répertoires créés. Un sous-répertoire nommé <code>powerpc-apple-darwin1.3.3</code> ne garantit pas la compatibilité entre versions ; utilisez plutôt <code>powerpc-apple-darwin1.3</code> ou <code>powerpc-apple-darwin</code>.
</p>
</itemd></item>

<item><itemt><filename>/sw/share</filename></itemt>
<itemd>
<p>
Ce répertoire sert aux fichiers de données indépendants de l'architecture. Les mêmes règles que celles en vigueur pour <filename>/sw/lib</filename> s'appliquent ici. Quelques sous-répertoires courants sont décrits ci-dessous.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/man</filename></itemt>
<itemd>
<p>
Ce répertoire contient les pages de manuel. Son arborescence suit celle des sections courantes. Chaque programme installé dans <filename>/sw/bin</filename> et <filename>/sw/sbin</filename> doit avoir une page de manuel associée dans ce répertoire.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/info</filename></itemt>
<itemd>
<p>
Ce répertoire contient la documentation en format Info (produit à partir de sources Texinfo). La maintenance du fichier <code>dir</code> est automatisée par la version Debian du programme <code>install-info</code> (qui fait partie du paquet <code>dpkg</code>). Utilisez le champ de description <code>InfoDocs</code> pour générer le code approprié utilisé par les scripts de paquet <code>postinst</code> et <code>prerm</code>. Fink s'assure qu'aucun paquet n'installe un fichier <code>dir</code> de lui-même. Il n'y a pas de sous-répertoire.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/doc</filename></itemt>
<itemd>
<p>
Ce répertoire contient la documentation autre que les pages de manuel ou les documents Info. Les fichiers README, LICENSE et COPYING sont placés dans ce répertoire. Chaque paquet doit y créer un sous-répertoire, dont le nom est basé sur celui du paquet. Le nom du sous-répertoire ne doit pas contenir de numéro de version (sauf s'il fait lui-même partie du nom du paquet). Conseil : utilisez <code>%n</code>.
</p>
</itemd></item>

<item><itemt><filename>/sw/share/locale</filename></itemt>
<itemd>
<p>
Ce répertoire contient les catalogues de messages de traduction.
</p>
</itemd></item>

<item><itemt><filename>/sw/var</filename></itemt>
<itemd>
<p>
Le répertoire <filename>var</filename> contient les données variables. Ceci inclut les répertoires spool (fichiers en attente de traitement), les fichiers verrous (lock), les bases de données des variables d'état (db), les données variables des jeux (games) et les fichiers d'historique (log).
</p>
</itemd></item>

<item><itemt><filename>/sw/etc</filename></itemt>
<itemd>
<p>
Ce répertoire contient les fichiers de configuration. Quand un paquet possède plus d'un ou deux fichiers de configuration, un sous-répertoire doit être créé. Le nom du sous-répertoire doit être celui du paquet ou d'un de ses programmes, de façon à l'identifier facilement.
</p>
</itemd></item>

<item><itemt><filename>/sw/src</filename></itemt>
<itemd>
<p>
Ce répertoire sert à stocker et compiler le code source. Un paquet ne doit rien installer dans ce répertoire.
</p>
</itemd></item>

</itemtable>
</section>

<section name="avoid"><title>À éviter</title>
<p>
Aucun autre répertoire que ceux mentionnés ci-dessus ne doit être créé dans <filename>/sw</filename>. En particulier, les répertoires suivant ne doivent pas être utilisés : <filename>/sw/man</filename>, <filename>/sw/info</filename>, <filename>/sw/doc</filename>, <filename>/sw/libexec</filename> et <filename>/sw/lib/locale</filename>.
</p>

</section>
</chapter>

<chapter filename="reference">
<title>Référence</title>
<shorttitle>Référence</shorttitle>

<section name="build"><title>Construction d'un paquet</title>

<p>Pour comprendre l'utilité de certains des champs, vous devez d'abord savoir comment Fink construit un paquet. La construction se déroule en cinq phases : décompression, application des rustines, compilation, installation et construction proprement dite. L'exemple ci-dessous correspond à une installation dans <filename>/sw</filename> du paquet gimp-1.2.1-1.</p>
<p>Lors de la <em>phase de décompression</em>, le répertoire <filename>/sw/src/gimp-1.2.1-1</filename> est créé et l'archive tar y est décompressée (il peut y avoir plusieurs archives tar). Dans la plupart des cas, un répertoire gimp-1.2.1, contenant le source, sera créé ; toutes les étapes suivantes seront exécutées dans ce répertoire (par exemple <filename>/sw/src/gimp-1.2.1-1/gimp-1.2.1</filename>). Les champs SourceDirectory, NoSourceDirectory et Source<em>N</em>ExtractDir permettent de contrôler quels sont les répertoires à utiliser.</p>
<p>Lors de la <em>phase d'application des rustines</em>, le code source est modifié par les rustines, pour qu'il compile sous Darwin. Les actions dérivées des champs UpdateConfigGuess, UpdateLibtool, Patch et PatchScript sont exécutées dans l'ordre d'énumération de ces champs.</p>
<p>Lors de la <em>phase de compilation</em>, le source est configuré et compilé. En général, cela correspond au lancement du script <code>configure</code> avec certains paramètres, puis à l'exécution de la commande <code>make</code>. Voir la description du champ CompileScript pour de plus amples informations.</p>
<p>Lors de la <em>phase d'installation</em>, le paquet est installé dans un répertoire temporaire, <filename>/sw/src/root-gimp-1.2.1-1</filename> (= %d). (Notez la partie "root-"). Tous les fichiers qui sont normalement installés dans <filename>/sw</filename> sont installés dans <filename>/sw/src/root-gimp-1.2.1-1/sw</filename> (= %i = %d%p). Voir la description du champ InstallScript pour de plus amples informations.</p>
<p>(<em>À partir de fink 0.9.9.</em>, il est possible de générer plusieurs paquets à partir d'une seule description de paquet en utilisant le champ <code>SplitOff</code>. À la fin de la phase d'installation, des répertoires d'installation distincts sont créés pour chaque paquet à construire et les fichiers sont placés dans le répertoire approprié.)</p>
<p>Lors de la <em>phase de construction</em>, un fichier binaire (.deb) est construit à partir du répertoire temporaire. On ne peut agir directement sur cette étape, néanmoins différentes informations issues de la description du paquet sont utilisées afin de générer un fichier de  <filename>contrôle</filename> pour dpkg.</p>
</section>

<section name="fields"><title>Champs</title>

<p>Nous avons classé les champs en plusieurs catégories. Cette liste n'est pas forcément exhaustive. <code>:-)</code></p>
<p><em>Données initiales :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">
<item><itemt>Package</itemt>
<itemd>
<p>
Nom du paquet. Peut contenir des minuscules, des nombres ou les caractères spéciaux suivants : '.', '+' et '-'. Pas de trait de soulignement ('_'), ni de majuscules. Champ obligatoire.
</p>
<p>Seuls les raccourcis %N, %{Ni}, %type_raw[] et %type_pkg[] sont applicables à ce champ.</p>
<p>
Selon les règles de Fink, un paquet donné doit toujours être compilé avec les mêmes options activées. Si un paquet peut avoir plusieurs variantes (voir la documentation sur le champ <code>Type</code>), vous devez encoder les informations concernant la variante dans le champ <code>Package</code> (voir la documentation sur le raccourci  %type_pkg[]). De cette façon, chaque variante possédera un nom unique. Le nom du paquet indique quelles variantes sont incluses. Notez que l'usage des raccourcis %type_pkg[] et %type_raw[] dans le nom du paquet est récent et grandement incompatible avec les anciennes versions de fink ; les descriptions de ces paquets doivent être insérés dans un champ <code>InfoN</code> avec N>=2.
</p>
</itemd></item>

<item><itemt>Version</itemt>
<itemd>
<p>
Le numéro de version en amont. Même limitations que pour le champ Package. Champ obligatoire.</p>
<p>Notez que certains programmes utilisent une numérotation de version non standard qui peut provoquer des problèmes de tri, ou bien utilisent des caractères non autorisés dans ce champ. Dans ce cas, vous devez convertir la valeur de la version originale en une valeur acceptable qui permette de trier les versions correctement. Si vous ne savez pas comment les versions seront triées, utilisez la commande <code>dpkg</code> à l'invite d'un shell. Par exemple :
</p>
<codeblock>
  dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo "vrai"
</codeblock>
<p>imprimera &quot;vrai&quot; car le numéro de version &quot;1.2.1&quot; est inférieur au numéro de version &quot;1.3&quot;. Voir la page de manuel <code>dpkg</code> pour de plus amples informations.</p>
</itemd></item>

<item><itemt>Revision</itemt>
<itemd>
<p>
Le numéro de révision du paquet. Incrémentez ce numéro quand vous faites une nouvelle description pour la même version en amont. Les numéros de révision commencent à 1. Champ obligatoire.
</p>
<p>
 Les règles de Fink stipule vous <em>devez</em> incrémenter le champ <code>Revision</code> <em>chaque fois</em> que vous changez un fichier <filename>.info</filename>, si les changements entraînent une modification de la forme binaire (compilée) du paquet (le  fichier <filename>.deb</filename>). Cela s'applique aux changements opérés dans le champ <code>Depends</code> ou les autres champs incluant une liste de paquets, ainsi qu'à l'ajout, la suppression ou le changement de nom des paquets splitoff, ou bien encore le déplacement de fichiers d'un splitoff à un autre. Quand la migration d'un paquet vers une nouvelle arborescence (par exemple de 10.2 à 10.3) conduit à des modifications de cette nature, vous devez incrémenter le champ <code>Revision</code> de 10 unités dans la nouvelle arborescence, de façon à garder la possibilité de mises à jour ultérieures dans l'arborescence la plus ancienne.
</p></itemd></item>

<item><itemt>Epoch</itemt>
<itemd>
<p>
<em>Introduit à partir de fink 0.12.0.</em>
Ce champ facultatif peut être utilisé pour spécifier l'ère du paquet (défaut 0 si ce champ n'est pas renseigné). Pour de plus amples informations, voir <link url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian Policy Manual</link>.
</p>
</itemd></item>

<item><itemt>Description</itemt>
<itemd>
<p>
Courte description du paquet (répond à la question qu'est-ce c'est ?). C'est une description d'une ligne qui est affichée sous forme de liste, elle doit donc être courte et bien ciblée. Elle peut avoir moins de 45 caractères, mais ne peut dépasser 60 caractères. Il n'est pas nécessaire d'indiquer le nom du paquet, il sera affiché de toute façon. Champ obligatoire.
</p>
</itemd></item>

<item><itemt>Type</itemt>
<itemd>
<p>
Peut être <code>bundle</code>. Les paquets lots sont utilisés pour regrouper plusieurs paquets. Ils n'ont que des dépendances, mais ni code ni fichiers installés. Les champs Source, PatchScript, CompileScript, InstallScript et ceux qui leur sont liés sont ignorés pour ce type de paquets.
</p>
<p>
<code>nosource</code> est un type très voisin.
Il sert à indiquer qu'il n'y a pas d'archive tar source. Rien n'est téléchargé et la phase de décompression crée simplement un répertoire vide. Néanmoins, les phases d'application de rustine, de compilation et d'installation sont exécutées normalement. De cette façon, on peut incorporer tout le code avec une rustine, ou créer quelques répertoires avec InstallScript. À partir de la version 0.18.0 de fink, on peut utiliser <code>Source: none</code> pour obtenir le même résultat. Ceci permet d'utiliser "Type" pour d'autres usages (<code>Type: perl</code>, etc...).
</p>
<p>
À partir de fink 0.9.5, il existe un type  <code>perl</code>, qui permet d'offrir un choix de valeurs par défaut pour les scripts de compilation et d'installation. À partir de  fink 0.13.0, il existe une nouvelle variante de ce type, <code>perl $version</code>, où $version est une version spécifique de perl, constituée de trois chiffres séparés par un point, par exemple : <code>perl 5.6.0</code>.
</p>
<p>
Dans une version CVS postérieure à fink-0.19.2, l'utilisation de langage/langage-version a été généralisée pour permettre à tout mainteneur de définir des types et sous-types associés et ainsi d'utiliser plus d'un type par paquet. Les types et sous-types sont des chaînes de caractères arbitraires ; toutefois, les blancs sont interdits et les parenthèses, virgules, crochets et signe pourcentage ne doivent pas être utilisés. Les raccourcis ne sont pas interprétés et le type (mais non le sous-type) est converti en minuscules. Les valeurs du type sont définies dans une liste , chaque valeur étant séparée de la suivante par des virgules ; chaque valeur peut elle-même avoir une liste de sous-types associés séparés par des blancs.
</p>
<p>
De plus, il existe un concept de &quot;variantes&quot;, qui permet de décrire dans un fichier .info unique une famille de paquets étroitement liés, ayant chacun des options différentes activées. La clé de ce processus est l'utilisation d'une liste de sous-types. Au lieu d'une simple chaîne de caractères, on utilise une liste de chaînes de caractères séparés par des blancs et mise entre parenthèses. Fink clone le fichier de description du paquet pour chaque sous-type de la liste et remplace cette liste par un unique sous-type dans le clone. Par exemple :
</p>
<codeblock>Type: perl (5.6.0 5.8.1)</codeblock>
<p>
provoque la création de deux descriptions de paquet, une qui se comporte comme si on avait <code>Type: perl 5.6.0</code> et l'autre comme si on avait <code>Type: perl 5.8.1</code>. Le sous-type spécial &quot;(boolean)&quot; est un raccourci pour une liste contenant le type lui-même et un point. Ainsi les deux formes suivantes sont identiques :
</p>
<codeblock>
Type: -x11 (boolean)
Type: -x11 (-x11 .)
</codeblock>
<p>
L'interprétation de la liste de sous-types / clonage du paquet est récursive. S'il y a plusieurs types avec des listes de sous-types, on obtient toutes les combinaisons possibles :
</p>
<codeblock>Type: -ssl (boolean), perl (5.6.0 5.8.1)</codeblock>
<p>
Dans les autres champs, on accède à un sous-type donné de variante en utilisant les fonctions de pseudo-hachage %type_raw[] et %type_pkg[]. Voici deux exemples de fragments de fichiers .info :
</p>
<codeblock>
Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.6.0 5.8.1)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;
</codeblock>
<codeblock>
Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [ &quot;%type_raw[-x11]&quot; == &quot;-x11&quot; ]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;
</codeblock>
</itemd></item>

<item><itemt>License</itemt>
<itemd>
<p>
Ce champ indique la nature de la licence sous laquelle le paquet est distribué. Sa valeur doit être l'une de celles décrites plus haut dans la section <xref chapter="policy" section="licenses">Licences de paquet</xref>. De plus, ce champ ne doit être renseigné que si le paquet respecte effectivement les règles de construction des paquets, c'est-à-dire installe une copie de la licence dans le répertoire doc.
</p>
</itemd></item>

<item><itemt>Maintainer</itemt>
<itemd>
<p>
Nom et adresse e-mail de la personne responsable du paquet. Ce champ est obligatoire et ne doit mentionner qu'un nom et qu'une adresse e-mail sous le format suivant :
</p>
<codeblock>Prénom Nom &lt;utilisateur@hôte.domaine.com&gt;</codeblock>
</itemd></item>

<item><itemt>InfoN</itemt>
<itemd>
<p>
Ce champ permet à fink d'implémenter des changements de syntaxe incompatibles avec les versions précédentes dans les fichiers de description de paquet. Une version donnée de fink est configurée avec un nombre entier maximum "N", qu'il sait gérer. Tout paquet dont le champ InfoN est supérieur à ce nombre sera ignoré. Il ne faut donc utiliser ce mécanisme que dans les cas d'absolue nécessité, faute de quoi on priverait de ces paquets les personnes utilisant des versions plus anciennes de fink.  Quand un autre champ doit utiliser un numéro InfoN spécifique, mention en est faite dans la description du champ. Pour utiliser ce mécanisme, il faut insérer l'ensemble de la description du paquet dans le champ InfoN. Voir plus haut la section "Format de fichier" pour une description de la syntaxe des champs constitués de plusieurs lignes.
</p>
</itemd></item>

</itemtable>
<p><em>Dépendances :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>Depends</itemt>
<itemd>
<p>
Liste de paquets à installer pour que le paquet puisse compiler. L'interprétation des raccourcis a lieu dans ce champ (tout comme dans les autres champs de cette catégorie : BuildDepends, Provides, Conflicts, Replaces, Recommends, Suggests et Enhances). C'est, en général, une liste de noms de paquets séparés par des virgules, mais Fink gère maintenant les clauses de choix et de version avec la même syntaxe que dpkg. En voici un exemple :
</p>
<codeblock>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</codeblock>
<p>
Notez qu'on ne peut indiquer de réelles options de dépendances. Si un paquet fonctionne avec ou sans un autre paquet, vous devez soit vous assurer que l'autre paquet n'est pas utilisé, même s'il est présent, soit l'ajouter à la liste des dépendances. Si vous voulez donner à l'utilisateur le choix entre les deux options, faîtes deux paquets distincts, par exemple : wget et wget-ssl.
</p>
<p>
Ordre des opérations: le &quot;OU&quot; logique (liste de choix exclusifs) a priorité sur le &quot;ET&quot; logique entre chaque paquet (ou jeu de choix) dans la liste séparée par des virgules. À moins de mettre des parenthèses comme celles utilisées en arithmétique, il n'y a aucun moyen de spécifier des groupes de choix ou de changer l'ordre des opérations dans le champ <code>Depends</code> et les champs similaires.
</p>
<p>
À partir d'une version CVS postérieure à la version 0.18.2 de fink, on peut utiliser des dépendances conditionnelles. Celles-ci sont indiquées en plaçant <code>(chaîne1 opérateur chaîne2)</code> avant le nom du paquet. L'interprétation des raccourcis se fait normalement, puis les deux chaînes sont comparées en fonction de l'<code>opérateur</code> utilisé, qui peut être : &lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=. Le paquet qui suit n'est considéré comme une dépendance que si la comparaison est vraie.
</p>
<p>
Vous pouvez utiliser ce format pour simplifier la maintenance de paquets similaires. Par exemple, elinks et elinks-ssl peuvent avoir :
</p>
<codeblock>Depends: (%n = elinks-ssl) openssl097-shlibs, expat-shlibs</codeblock>
<p>Ce qui a le même effet que si elinks avait :</p>
<codeblock>Depends: expat-shlibs</codeblock>
<p>et elinks-ssl avait :</p>
<codeblock>Depends: openssl097-shlibs, expat-shlibs</codeblock>
<p>
Vous pouvez aussi utiliser un autre type de syntaxe : <code>(chaîne de caractères)</code>, qui est &quot;vrai&quot; si la <code>chaîne de caractères</code> est non nulle. Par exemple :
</p>
<codeblock>
Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11
</codeblock>
<p>
indiquera une dépendance du paquet x11 pour la variante nethack-x11, mais pas pour la variante nethack.
</p>
<p>
Notez que quand on utilise les champs Depends/BuildDepends pour les paquets de librairies partagées, alors qu'il existe plus d'une version majeure disponible, il <em>ne faut pas</em> utiliser la syntaxe suivante :
</p>
<codeblock>
  Package: foo
  Depends: id3lib3.7-shlibs | id3lib3.7-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev
</codeblock>
<p>
même si le paquet peut fonctionner avec l'une ou l'autre librairie. Il faut en choisir une (de préférence, la version la plus élevée possible) et s'y tenir dans l'ensemble du paquet.
</p>
<p>
Comme cela a été expliqué dans la section <xref chapter="policy" section="sharedlibs">Librairies partagées</xref>, un seul des paquets -dev peut être installé à un instant donné, et chacun possède des liens de même nom qui peuvent se référer à des noms de fichiers différents dans le paquet associé -shlibs. Lors de la compilation du paquet foo, le nom réél du fichier (dans le paquet -shlibs) est codé en dur dans le binaire foo. Cela signifie que le paquet résultant nécessite le paquet -shlibs associé au -dev qui était installé au moment de la compilation. En conséquence, on ne peut indiquer dans le champ <code>Depends</code> que l'un quelconque des paquets est requis.
</p></itemd></item>

<item><itemt>BuildDepends</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.9.0.</em> Liste de dépendances utilisées uniquement lors de la compilation.
Il sert à spécifier des outils (par exemple flex) qui doivent être présents pour compiler les paquets, mais qui ne sont pas nécessaires à l'exécution. Utilise la même syntaxe que Depends.
</p>
</itemd></item>

<item><itemt>Provides</itemt>
<itemd>
<p>
Liste de noms de paquets séparés par des virgules que ce paquet est censé "fournir". Si un paquet nommé "pine" indique <code>Provides: mailer</code>, alors toute dépendance à "mailer" est considérée comme satisfaite si "pine" est installé. En général, on énumère aussi ces paquets dans les champs "Conflicts" et "Replaces".
</p>
</itemd></item>

<item><itemt>Conflicts</itemt>
<itemd>
<p>
Liste de noms de paquets séparés par des virgules qui ne doivent pas être installés en même temps que le paquet. Pour les paquets virtuels, on peut énumérer dans ce champ les noms des paquets fournis ; ils seront gérés correctement. Ce champ gère aussi les clauses de versions tout comme le champ Depends, mais pas les clauses de choix (cela n'aurait aucun sens). Si un paquet est nommé dans son propre champ Conflicts, il sera supprimé de cette liste (sans avertissement). (Introduit dans une version CVS de fink postérieure à la version 0.18.2).
</p>
<p>
<em>Note :</em> Fink lui-même ignore ce champ à l'heure actuelle. Néanmoins, il est passé à dpkg et est géré en conséquence. Bref, il n'a d'effet qu'à l'exécution, pas à la compilation.
</p>
</itemd></item>

<item><itemt>Replaces</itemt>
<itemd>
<p>
Utilisé en général avec "Conflicts", quand le paquet non seulement remplace les fonctions du paquet en conflit, mais a aussi des fichiers en commun. Sans ce champ, dpkg pourrait générer des erreurs lors de la phase d'installation du paquet, car certains fichiers appartiendraient toujours à un autre paquet. C'est aussi l'indication que les deux paquets en cause sont équivalents l'un l'autre, et que l'un peut être remplacé par l'autre. Si un paquet est nommé dans son propre champ Replaces, il sera supprimé (sans avertissement) de cette liste. (Introduit dans une version CVS de fink postérieure à la version 0.18.2).
</p>
<p>
<em>Note :</em> Fink lui-même ignore ce champ à l'heure actuelle. Néanmoins, il est passé à dpkg et est géré en conséquence. Bref, il n'a d'effet qu'à l'exécution, pas à la compilation.
</p>
</itemd></item>

<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>
Ces champs indiquent des relations supplémentaires spécifiques dans le même style que les autres champs de dépendances. Ces trois champs n'ont aucun effet sur l'installation via <code>dpkg</code> ou <code>apt-get</code>. Néanmoins, ils sont utilisés par <code>dselect</code> et d'autres interfaces pour aider l'utilisateur à faire des choix.
</p>
</itemd></item>

<item><itemt>Pre-Depends</itemt>
<itemd>
<p>
Une variante spéciale du champ Depends avec une sémantique plus stricte. Ce champ ne doit être utilisé qu'après en avoir discuté sur la liste de développeurs et qu'il soit apparu évident que cela était nécessaire.
</p>
</itemd></item>

<item><itemt>Essential</itemt>
<itemd>
<p>
Valeur booléenne qui signale les paquets essentiels. Ceux-ci sont installés lors du processus de bootstrap. Tous les paquets non essentiels dépendent implicitement des paquets essentiels. dpkg refusera de supprimer les paquets essentiels du système, à moins d'utiliser des options spéciales, qui permettent de lever cette interdiction.
</p>
</itemd></item>

<item><itemt>BuildDependsOnly</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.9.9.</em>
Valeur booléenne qui indique qu'aucun autre paquet ne doit avoir un champ Depend le mentionnant, seul le champ BuildDepend est autorisé. Contrairement aux autres champs booléens, <code>BuildDependsOnly</code> a trois valeurs: undéfini (non spécifié) n'a pas le même sens que faux. Voir la section <xref chapter="policy" section="sharedlibs">Librairies partagées</xref> pour de plus amples informations.
</p>
<p>À partir de la version 0.20.5 de fink, la présence ou l'absence de ce champ, et sa valeur s'il est présent, sont sauvegardées dans le fichier .deb à la construction du paquet. Par conséquent, <em>si vous changez la valeur de BuildDependsOnly, ou si vous l'ajoutez ou le supprimez, vous devez incrémenter le numéro de révision</em> du paquet.
</p>
</itemd></item>
</itemtable>

<p><em>Phase de décompression :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>CustomMirror</itemt>
<itemd>
<p>
Liste de sites miroirs. Chaque ligne correspond à un site miroir, sous le format suivant : <code>&lt;emplacement&gt;: &lt;url&gt;</code>. L'<em>emplacement</em> peut être un code continent (par exemple : <code>nam</code> - Amérique du Nord), un code pays (par exemple : <code>nam-us</code> - Amérique du Nord-États-Unis), ou bien autre chose ; les archives sont recherchées sur les miroirs dans l'ordre d'énumération de ces derniers. Exemple :
</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
</itemd></item>

<item><itemt>Source</itemt>
<itemd>
<p>
URL de l'archive tar du source. Ce doit être une URL HTTP ou FTP, mais Fink ne fait pas de vérification  - il se contente de passer l'URL à wget. Ce champ gère un type spécial d'URL pour les miroirs : <code>miroir:&lt;nom-miroir&gt;:&lt;chemin-relatif&gt;</code>. Ainsi, la définition du miroir <em>nom-miroir</em> est récupérée dans le fichier de configuration de Fink, la partie <em>chemin-relatif</em> y est ajoutée, et  c'est l'ensemble qui est utilisé comme réelle URL. Chaque <em>nom-miroir</em> reconnu est stocké dans le fichier <filename>/sw/lib/fink/mirror/_list</filename>, qui fait partie du paquet fink ou du packet fink-mirrors. Par ailleurs, l'utilisation de  <code>custom</code> comme <em>nom-miroir</em> oblige Fink à utiliser le champ <code>CustomMirror</code>. L'interprétation des raccourcis a lieu avant utilisation de l'URL. N'oubliez pas que %n correspond à toutes les variantes du champ  %type_, il est donc conseillé d'utiliser ici %{ni} (avec, éventuellement, des spécifications de %type_).
</p>
<p>
À partir de fink 0.18.0, <code>Source: none</code> indique qu'il n'y a pas de source à récupérer. Voir la description du champ <code>Type</code> pour de plus amples informations. La valeur <code>gnu</code> est un raccourci pour <code>mirror:gnu:%n/%n-%v.tar.gz</code> ; de même, <code>gnome</code> est un raccourci pour <code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>. La valeur par défaut est <code>%n-%v.tar.gz</code> (correspond à un téléchargement ordinaire). Cette forme de définition implicite pour <code>Source</code> est obsolète (il est toujours possible de fournir un nom de fichier explicite ou d'opérer un téléchargement manuel).</p>
</itemd></item>

<item><itemt>Source<em>N</em></itemt>
<itemd>
<p>
Quand un paquet est constitué de plusieurs archives tar, vous devez les énumérer en utilisant ces champs supplémentaires, où N commence à 2. Le premier fichier archive tar (sorte d'archive tar "principale") est indiqué dans <code>Source</code>, le second dans <code>Source2</code>, et ainsi de suite. Les règles sont les mêmes que celles en vigueur pour le champ Source, mais les raccourcis "gnu" et "gnome" ne sont pas interprétés - cela n'aurait aucune utilité par ailleurs. À partir d'une version CVS de fink postérieure à la version 0.19.2, vous pouvez utiliser n'importe quels nombres entiers N >= 2 (non nécessairement consécutifs). Néanmoins, les doublons ne sont pas autorisés.
</p>
</itemd></item>

<item><itemt>SourceDirectory</itemt>
<itemd>
<p>
Doit être utilisé quand la décompression de l'archive tar aboutit à la création d'un répertoire dont le nom est différent du nom de base de l'archive. En général, une archive tar nommée "foo-1.0.tar.gz" crée un répertoire nommé "foo-1.0". Si le répertoire créé porte un nom différent, indiquez-le dans ce champ. L'interprétation des raccourcis y est effectuée.
</p>
</itemd></item>

<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>
Donnez à ce paramètre booléen la valeur "true" si la décompression de l'archive tar ne crée pas de répertoire. En général, une archive tar nommée "foo-1.0.tar.gz" crée un répertoire nommé "foo-1.0". Si les fichiers sont simplement décompressés dans le répertoire en cours, utilisez ce champ et donnez-lui la valeur "true".
</p>
</itemd></item>

<item><itemt>Source<em>N</em>ExtractDir</itemt>
<itemd>
<p>
Normalement, une archive tar auxiliaire est extraite dans le même répertoire que l'archive tar principale. Si vous devez l'extraire dans un sous-répertoire spécifique, utilisez ce champ pour l'indiquer. Source2ExtractDir correspond, bien évidemment, à l'archive tar Source2. Voir ghostscript, vim et tetex comme exemples d'utilisation de ce champ.
</p>
</itemd></item>

<item><itemt>SourceRename</itemt>
<itemd>
<p>
Ce champ renomme une archive tar à la volée. Ceci est utile, par exemple, lorsque la version du source est encodée dans le nom du répertoire du serveur, mais que l'archive elle-même porte le même nom pour toutes les versions, comme <filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename>. Pour résoudre les problèmes que cela cause, vous pouvez utiliser quelque chose de similaire à :
</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>
Dans l'exemple ci-dessus, l'archive tar sera sauvegardée sous <filename>/sw/src/coolapp-1.2.3.tar.gz</filename>.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>Rename</itemt>
<itemd>
<p>
Ce champ est semblable au champ <code>SourceRename</code>, mais il est utilisé pour renommer l'archive tar correspondant au champ <code>Source<em>N</em></code>. Voir context ou hyperref comme exemples d'utilisation de ce champ.
</p>
</itemd></item>

<item><itemt>Source-MD5</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.10.0.</em>
Vous pouvez indiquer dans ce champ la somme de contrôle MD5 du fichier source. La valeur sera alors utilisée par Fink pour détecter les fichiers sources incorrects, c'est-à-dire les archives tar qui ne correspondent pas à celles que le créateur du paquet a utilisées. Les causes les plus courantes de ce type de problème sont : téléchargement incomplet de l'archive, mainteneurs en amont ayant changé l'archive sans le signaler, chevaux de Troie ou attaques similaires, etc... 
</p>
<p>
Exemple :
</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
<p>
La somme de contrôle est calculée avec l'outil <code>md5sum</code>. Si vous voulez calculer la somme de contrôle de l'archive tar <filename>/sw/src/apache_1.3.23.tar.gz</filename>, exécutez la commande suivante (le résultat est affiché au-dessous) :
</p>
<codeblock>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz 
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</codeblock>
<p>
La valeur affichée à gauche correspond à la valeur recherchée.
</p>
</itemd></item>

<item><itemt>Source<em>N</em>-MD5</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.10.0.</em>
Ce champ est semblable au champ <code>Source-MD5</code>, mais il est utilisé pour indiquer la somme de contrôle MD5 de l'archive tar correspondant au champ <code>Source<em>N</em></code>.
</p>
</itemd></item>

<item><itemt>TarFilesRename</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.10.0.</em>
Ce champ ne s'applique qu'aux fichiers sources utilisant le format tar.
</p>
<p>
Avec ce champ, vous pouvez renommer les fichiers d'une archive tar donnée durant l'extraction. Ceci est très utile pour gérer les problèmes dus au fait que le système de fichiers HFS+ ne tient pas compte de la casse. En effet, sur un système standard Mac OS X, les fichiers <filename>install</filename> et <filename>INSTALL</filename> ne sont pas distinguables. L'utilisation de ce champ permet d'éviter ces problèmes sans avoir à changer l'archive tar (comme on le faisait auparavant dans de tels cas).
</p>
<p>
Indiquez juste la liste des fichiers à renommer dans ce champ. Vous pouvez utiliser des caractères joker. Par défaut, à tout fichier spécifié dans la liste est ajouté le suffixe <code>_tmp</code>. Vous pouvez modifier ce comportement en utilisant la même syntaxe que celles des champs <code>Files</code> et <code>DocFiles</code>, c'est-à-dire en écrivant l'ancien nom suivi de deux-points, puis du nouveau nom. Exemple :
</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: directory/INSTALL:directory/INSTALL.txt</codeblock>
</itemd></item>

<item><itemt>Tar<em>N</em>FilesRename</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.10.0.</em>
Ce champ est similaire au champ <code>TarFilesRename</code>, mais il est utilisé pour renommer l'archive tar correspondant au champ <code>Source<em>N</em></code>.
</p>
</itemd></item>

</itemtable>

<!-- Patch Phase -->
<p><em>Phase d'application des rustines :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>
Valeur booléenne. Si elle est vraie ("true"), les fichiers config.guess et config.sub présents dans le répertoire de compilation sont remplacés par des versions reconnaissant Darwin. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté. <em>N'utilisez</em> ce champ quand cas d'absolue nécessité, c'est-à-dire lorsque le script configure se termine inopinément par un message "unknown host" (système inconnu).
</p>
</itemd></item>

<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p>
<em>Introduit dans une version CVS postérieure à la version 0.9.0.</em>
Liste de sous-répertoires. A le même effet que UpdateConfigGuess, mais dans toute l'arborescence du source ; utile lorsque plusieurs fichiers config.guess existent dans différents répertoires du source. Auparavant, il fallait copier ou déplacer les fichiers dans le script PatchScript. Avec ce nouveau champ, il suffit de donner la liste des répertoires. Utilisez <code>.</code> pour mettre à jour les fichiers dans le répertoire de compilation.
</p>
</itemd></item>

<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>
Valeur booléenne. Si elle est vraie ("true"), les fichiers ltconfig et ltmain.sh présents dans le répertoire de compilation sont remplacés par des versions reconnaissant Darwin. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté. <em>N'utilisez</em> ce champ quand cas d'absolue nécessité. Certains paquets ne fonctionnent plus lorsqu'on modifie la version des scripts libtool. Voir la <link url="http://fink.sourceforge.net/doc/porting/libtool.php">page libtool</link> pour de plus amples informations.
</p>
</itemd></item>

<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p>
<em>Introduit dans une version CVS postérieure à la version 0.9.0.</em>
Liste de sous-répertoires. A le même effet que UpdateLibtool ; utile lorsque plusieurs fichiers scripts libtool 1.3.x sont présents dans différents répertoires de l'arborescence du source. Auparavant, il fallait copier ou déplacer les fichiers dans le script PatchScript. Avec ce nouveau champ, il suffit de donner la liste des répertoires. Utilisez <code>.</code> pour mettre à jour les fichiers dans le répertoire de compilation.
</p>
</itemd></item>

<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>
Valeur booléenne. Si elle est vraie ("true"), le fichier <filename>Makefile.in.in</filename> présent dans le sous-répertoire <filename>po</filename> est remplacé par une version modifiée. Ce remplacement se produit lors de la phase d'application des rustines avant que le script PatchScript soit exécuté.
</p>
<p>
La version modifiée prend en compte DESTDIR et garantit que les catalogues de messages seront placés dans <filename>/sw/share/locale</filename>, et non pas dans <filename>/sw/lib/locale</filename>. Assurez-vous, avant d'utiliser ce champ, qu'il est absolument nécessaire et que le paquet continuera à fonctionner. Vous pouvez exécuter <code>diff</code> pour trouver les différences entre la version du paquet et celle de Fink (située dans <filename>/sw/lib/fink/update</filename>).
</p>
</itemd></item>

<item><itemt>Patch</itemt>
<itemd>
<p>
Le nom d'une rustine à appliquer avec <code>patch -p1 &lt;<em>nom-rustine</em></code>. Ne donnez que le nom du fichier ; le chemin est ajouté automatiquement devant le nom du fichier. L'interprétation des raccourcis y est effectuée, si bien qu'on trouve, en général : <code>%f.patch</code> ou <code>%n.patch</code>. La rustine est appliquée avant que le script PatchScript soit exécuté (s'il existe).
</p>
<p>
N'oubliez pas que %n inclut implicitement toutes les variantes %type_. Le cas échéant, utilisez %{ni} (éventuellement avec des variantes spécifiques %type_). Il est plus facile de gérer une seule rustine et de faire des changements spécifiques à certaines variantes dans le script <code>PatchScript</code> que de gérer une rustine par variante.
</p>
</itemd></item>

<item><itemt>PatchScript</itemt>
<itemd>
<p>
Liste de commandes à exécuter lors de la phase d'application des rustines. Voir plus bas la note sur les scripts. C'est là où vous pouvez placer les commandes qui modifient le paquet. Il n'existe pas de script par défaut. L'interprétation des raccourcis (voir la section précédente) a lieu avant que les commandes ne soient exécutées.
</p>
</itemd></item>

</itemtable>
<p><em>Phase de compilation :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>Set<em>ENVVAR</em></itemt>
<itemd>
<p>
Définit certaines variables d'environnement pendant les phases de compilation et d'installation. On peut utiliser ce champ pour passer des drapeaux de compilation, etc... aux scripts configure et aux Makefile. Les variables reconnues à l'heure actuelle sont : CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, LD, LDFLAGS, LIBS, MAKE, MFLAGS, MAKEFLAGS. L'interprétation des raccourcis a lieu sur la valeur spécifiée, comme expliquée dans la section précédente. Exemple courant : 
</p>
<codeblock>SetCPPFLAGS: -no-cpp-precomp</codeblock>
<p>
Les variables CPPFLAGS et LDFLAGS sont spéciales. Elles ont pour valeur par défaut respective : <code>-I%p/include</code> et <code>-L%p/lib</code>. Si vous spécifiez une valeur pour l'une de ces deux variables, elle sera ajoutée avant la valeur par défaut.
</p>
</itemd></item>

<item><itemt>NoSet<em>ENVVAR</em></itemt>
<itemd>
<p>
Quand la valeur de ce champ est true (vraie), les valeurs par défaut de CPPFLAGS et LDFLAGS mentionnées ci-dessus sont désactivées. Autrement dit, si vous ne voulez pas que LDFLAGS ait une valeur par défaut, utilisez <code>NoSetLDFLAGS: true</code>.
</p>
</itemd></item>

<item><itemt>ConfigureParams</itemt>
<itemd>
<p>
Paramètres supplémentaires à passer au script configure. (Voir CompileScript pour de plus amples informations). À partir des versions de fink > 0.13.7, ce champ fonctionne aussi avec les modules perl <code>Type: Perl</code> ; il ajoute les paramètres à la chaîne perl par défaut Makefile.PL.
</p>
<p>
À partir de la version 0.22.0 de fink, ce champ gère les expressions conditionnelles. La syntaxe est la même que celle utilisée dans le champ <code>Depends</code> et les autres champs basés sur des listes de paquets. L'expression conditionnelle s'applique au &quot;mot&quot; délimité par des espaces suivant immédiatement l'expression. Par exemple : 
</p>
<codeblock>
Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared
</codeblock>
<p>
passera les drapeaux <code>--mandir</code> et <code>--disable-shared</code>  dans tous les cas de figure, mais ne passera le drapeau <code>--with-x11</code> quà la seule variante -x11.
</p>
</itemd></item>

<item><itemt>GCC</itemt>
<itemd>
<p>
Version requise du compilateur gcc à utiliser. Les valeurs autorisées sont : <code>2.95.2</code> ou <code>2.95</code> (pour l'arborescence des paquets 10.1 uniquement), <code>3.1</code> (pour l'arborescence des paquets 10.2 uniquement) et <code>3.3</code> (pour l'arborescence des paquets 10.2-gcc3.3 et 10.3 uniquement).
</p>
<p>À partir de la version 0.13.8 de fink, quand ce champ est utilisé, la version de gcc est testée via <code>gcc_select</code>, et fink se termine avec un message d'erreur si la version requise n'est pas présente.
</p>
<p>
Ce champ a été ajouté pour faciliter la transition entre les compilateurs gcc, qui ont introduit une incompatibilité binaire entre librairies ; cette incompatibilité concerne des parties de code C++ non reproduites dans les différentes versions.
</p>
</itemd></item>

<item><itemt>CompileScript</itemt>
<itemd>
<p>
Liste de commandes à exécuter durant la phase de compilation. Voir plus bas la note au sujet des scripts. C'est là qu'il faut mettre les commandes de configuration et de compilation du paquet. Normalement, les commandes sont les suivantes :
</p>
<codeblock>./configure %c
make</codeblock>
<p>
Elles conviennent pour les paquets utilisant GNU autoconf. Pour ceux de type perl (indiqué via le champ Type) dont la version perl n'est pas indiquée, les commandes par défaut (à partir de la version 0.13.4 de fink) sont les suivantes :
</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>Si le type est du style <code>perl $version</code> (où <code>$version</code> est, par exemple,  5.6.0), les commandes par défaut sont les suivantes :
</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>où <code>$perlarchdir</code> est "darwin" pour les versions antérieures ou égales à 5.8.0, "darwin-thread-multi-2level" pour les versions postérieures ou égales à 5.8.1.</p>
<p>
L'interprétation des raccourcis (voir la section précédente) a lieu avant que les commandes soient exécutées.
</p>
</itemd></item>

<item><itemt>NoPerlTests</itemt>
<itemd> 
<p>
<em>Introduite dans une version de fink > 0.13.7.</em>
Valeur booléenne spécifique aux paquets de module perl. Si sa valeur est true (vraie), la partie <code>make test</code> de <code>CompileScript</code> est ignorée pour ce paquet.
</p>
</itemd></item>

</itemtable>
<p><em>Phase d'installation :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>UpdatePOD</itemt>
<itemd>
<p>
<em>Introduit dans la version 0.9.5 de fink.</em>
Valeur booléenne réservée aux paquets de module perl. Si sa valeur est true (vraie), du code est ajouté aux scripts install, postrm et postinst, qui gèrent les fichiers .pod fournis par les paquets perl. En particulier, la date .pod est ajoutée et ôtée du fichier central <filename>/sw/lib/perl5/darwin/perllocal.pod</filename>. (Si le type est du style <code>perl $version</code>, où $version est, par exemple, 5.6.0, les scripts sont adaptés pour gérer le fichier central .pod <filename>/sw/lib/perl5/$version/perllocal.pod</filename>.)
</p>
</itemd></item>

<item><itemt>InstallScript</itemt>
<itemd>
<p>
Liste de commandes à exécuter durant la phase d'installation. Voir plus bas la note au sujet des scripts. C'est là où il faut mettre les commandes qui copient tous les fichiers requis dans le répertoire de construction du paquet. Normalement, on utilise :
</p>
<codeblock>make install prefix=%i</codeblock>
<p>
Ceci convient pour les paquets utilisant GNU autoconf. Pour ceux de type perl (indiqué via le champ Type) dont la version perl n'est pas indiquée, les commandes par défaut (à partir de la version 0.13.4 de fink) sont les suivantes :
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
 INSTALLARCHLIB=%i/lib/perl5/darwin \
 INSTALLSITELIB=%i/lib/perl5 \
 INSTALLSITEARCH=%i/lib/perl5/darwin \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>Si le type est du style <code>perl $version</code> (où <code>$version</code> est, par exemple,  5.6.0), les commandes par défaut sont les suivantes :
</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
 INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%i/lib/perl5/$version \
 INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%i/share/man/man1 \
 INSTALLMAN3DIR=%i/share/man/man3 \
 INSTALLSITEMAN1DIR=%i/share/man/man1 \
 INSTALLSITEMAN3DIR=%i/share/man/man3 \
 INSTALLBIN=%i/bin \
 INSTALLSITEBIN=%i/bin \
 INSTALLSCRIPT=%i/bin</codeblock>
<p>où <code>$perlarchdir</code> est "darwin" pour les versions antérieures ou égales à 5.8.0, et "darwin-thread-multi-2level" pour les versions postérieures ou égales à 5.8.1.</p>
<p>
Si le paquet l'admet, il est préférable d'utiliser <code>make install DESTDIR=%d</code>. L'interprétation des raccourcis (voir section précédente) a lieu avant que les commandes ne soient exécutées .
</p>
</itemd></item>

<item><itemt>AppBundles</itemt>
<itemd>
<p><em>Introduit dans une version postérieure à la version 0.23.1.</em> Ce champ installe le(s) lot(s) dans le répertoire <filename>%p/Applications</filename>. Il crée également un lien symbolique vers le répertoire <filename>/Applications/Fink</filename>. Exemple:
</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
</itemd></item>

<item><itemt>JarFiles</itemt>
<itemd>
<p>
<em>Introduit dans la version 0.10.0 de fink.</em>
Champ similaire au champ DocFiles. Il installe les fichiers jar spécifiés dans <filename>%p/share/java/%n</filename>. Exemple :
</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
<p>
Cette commande installe tous les fichiers jar situés dans le répertoire lib, puis installe le fichier foo.jar sous le nom de fooBar.jar.
</p>
<p>
Elle garantit aussi que les fichiers jar (en fait, tous les fichiers d'extension .jar situés dans <filename>%p/share/java/%n</filename>) sont ajoutés à la variable d'environnement CLASSPATH. Ceci permet aux outils tels configure ou ant de détecter correctement les fichiers jar installés.
</p>
</itemd></item>

<item><itemt>DocFiles</itemt>
<itemd>
<p>
Ce champ fournit un moyen simple d'installer les fichiers README et COPYING dans le répertoire doc du paquet, soit <filename>%p/share/doc/%n</filename>. Sa valeur consiste en une liste de fichiers séparés par des espaces. Vous pouvez copier les fichiers à partir de sous-répertoires du répertoire de compilation, ils seront placés dans le répertoire lui-même et non pas dans un sous-répertoire. Les caractères joker reconnus par le shell sont autorisés. On peut aussi renommer des fichiers à la volée en faisant suivre le nom du fichier de deux-points (:), puis du nouveau nom. Exemple :<code>libgimp/COPYING:COPYING.libgimp</code>. Ce champ ajoute les commandes <code>install</code> appropriées au script InstallScript.
</p>
</itemd></item>

<item><itemt>Shlibs</itemt>
<itemd>
<p>
<em>Introduit dans la version 0.11.0 de fink.</em>
Ce champ déclare les librairies partagées installées dans le paquet. Il y a une ligne par librairie partagée, cette ligne est constituée de trois éléments séparés par des blancs : le nom d'installation de la librairie <code>-install_name</code>, le numéro de version de compatibilité de la librairie <code>-compatibility_version</code> et des informations de dépendance de version qui indiquent quel paquet de Fink fournit la librairie à cette version de compatibilité. Les informations de dépendance doivent être spécifiées sous la forme <code> foo (>= version-revision)</code>, où  <code>version-revision</code> représente la <em>première</em> version d'un paquet Fink qui rend disponible cette librairie (avec cette version de compatibilité). La déclaration Shlibs revient à dire que le mainteneur du paquet garantit qu'une librairie portant ce nom et ayant une version de compatibilité au moins égale à <code>-compatibility_version</code> sera présente dans toutes les versions postérieures de ce paquet Fink.
</p></itemd></item>

<item><itemt>RuntimeVars</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.10.0.</em>
Ce champ fournit un moyen pratique de donner une valeur statique à des variables d'environnement pendant l'exécution (si vous voulez avoir plus de latitude dans ce domaine, voir la <xref section="profile.d">section scripts profile.d</xref>). À partir du moment où le paquet est installé, ces variables sont définies par les scripts <filename>/sw/bin/init.[c]sh</filename>.
</p>
<p>
La valeur de la variable peut contenir des espaces (seuls les espaces de fin de chaîne sont supprimés) ; l'interprétation des raccourcis a eu lieu sur ce champ. Exemple :
</p>
<codeblock>RuntimeVars: &lt;&lt;
 UneVariable: %p/Valeur
 UneAutreVariable: toto tata
&lt;&lt;</codeblock>
<p>
définit deux variables d'environnement 'UneVariable' et 'UneAutreVariable' ; leurs valeurs seront respectivement '/sw/Valeur' (si votre préfixe est /sw) et 'toto tata'.
</p>
<p>
Ce champ ajoute les commandes appropriées au script InstallScript. Ces commandes ajoutent une ligne setenv/export pour chaque variable aux scripts profile.d du paquet ; vous pouvez donc spécifier vos propres commandes, elles ne seront pas remplacées. Les lignes sont ajoutées en début de scripts, vous pouvez donc utiliser ces variables dans vos scripts.
</p>
</itemd></item>

<item><itemt>SplitOff</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.9.9.</em>
Génère un second paquet à partir d'une seule exécution du couple compilation/installation. Pour avoir de plus amples informations sur la façon dont ce champ fonctionne, voir la <link url="#splitoffs">section splitoff</link> ci-dessous.
</p>
</itemd></item>

<item><itemt>SplitOff<em>N</em></itemt>
<itemd>
<p>
<em>Introduit dans fink 0.9.9.</em>
Similaire au champ <code>SplitOff</code>, utilisé pour générer un N-ième paquet à partir d'une seule exécution du couple compilation/installation. À partir d'une version CVS de fink postérieure à la version 0.19.2, vous pouvez utiliser des valeurs entières (non nécessairement consécutives) de N >= 2. Néanmoins, il ne peut pas y avoir de doublons.
</p>
</itemd></item>

<item><itemt>Files</itemt>
<itemd>
<p>
<em>Introduit dans fink 0.9.9.</em>
Utilisé <em>uniquement</em> avec un champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>, ce champ indique quels fichiers et répertoires doivent être déplacés du répertoire d'installation %I du paquet parent vers le répertoire d'installation en cours %i. Notez que le déplacement a lieu après l'exécution des scripts InstallScript et DocFiles du paquet parent, mais avant l'exécution des mêmes scripts du paquet en cours d'installation.
</p>
</itemd></item>

</itemtable>
<p><em>Phase de construction :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>
Ces champs correspondent à des scripts shell qui seront appelés lors de l'installation, la mise à jour ou la suppression du paquet. Fink ajoute automatiquement l'en-tête du script shell <code>#!/bin/sh</code> et appelle  <code>set -e</code>, de façon à ce que tout échec d'une commande entraîne 'arrêt immédiat du script. Fink ajoute aussi  <code>exit 0</code> à la fin du script. Pour signaler une erreur, utilisez exit avec un code non nul. Le premier paramètre (<code>$1</code>) contient une valeur indiquant l'action à faire. Exemples de valeurs possibles : <code>install</code>, <code>upgrade</code>, <code>remove</code> et <code>purge</code>. Notez qu'il existe d'autres valeurs, utilisées lors des reprises sur erreur et du remplacement d'un paquet par un autre.
</p>
<p>
Ces différents scripts sont appelés lors des évènements suivants :
</p>
<ul>
<li>PreInstScript : lors de la première installation d'un paquet et avant la mise à jour d'un paquet à la même version.</li>
<li>PostInstScript : après le dépaquetage et la définition des variables spécifiques au paquet.</li>
<li>PreRmScript : avant la suppression et la mise à jour d'un paquet à une version ultérieure.</li>
<li>PostRmScript : après la suppression et la mise à jour du paquet à une version ultérieure.</li>
</ul>
<p>
Soyons plus clair. Une mise à jour invoque à la fois les scripts ...Inst de la nouvelle version et les scripts ...Rm de l'ancienne version. Vous trouverez de plus amples informations à ce sujet dans le <link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">Chapitre 6</link> du Manuel des normes Debian.
</p>
<p>
L'interprétation des raccourcis a lieu dans ces scripts. Les commandes peuvent, en général, être lancées sans donner leur chemin complet.
</p>
</itemd></item>

<item><itemt>ConfFiles</itemt>
<itemd>
<p>
Liste de fichiers séparés par des espaces. Ces fichiers sont des fichiers de configuration modifiables par l'utilisateur. L'interprétation des raccourcis a lieu sur ce champ. Le chemin complet des fichiers doit être indiqué, comme dans <filename>%p/etc/%n.conf</filename>. Ces fichiers sont traités de façon spéciale par dpkg. Quand un paquet est mis à jour et que le fichier de configuration a changé à la fois sur le disque et dans le paquet, dpkg demande à l'utilisateur quelle version il veut utiliser et sauvegarde l'ancien fichier. Quand un paquet est supprimé avec "remove", les fichiers de configuration ne sont pas supprimés. Pour les supprimer, il faut utiliser "purge".
</p>
</itemd></item>

<item><itemt>InfoDocs</itemt>
<itemd>
<p>
Liste des documents Info que le paquet installe dans %p/share/info. Des commandes appropriées sont ajoutées aux scripts postinst et prerm pour mettre à jour le fichier de la hiérarchie Info <code>dir</code>. Cette fonctionnalité est en cours de développement, d'autres champs pourront être ajoutés à l'avenir pour une gestion plus précise.
</p>
</itemd></item>

<item><itemt>DaemonicFile</itemt>
<itemd>
<p>
Décrit un service pour <code>daemonic</code>. <code>daemonic</code> est utilisé par Fink pour créer et supprimer des éléments à lancer au démarrage pour les processus démon (par exemple les serveurs web). La description est ajoutée au paquet sous la forme d'un fichier nommé <code>%p/etc/daemons/<em>nom</em>.xml</code>, où <em>nom</em> est indiqué par le champ DaemonicName et est réduit, par défaut,  au nom du paquet. L'interprétation des raccourcis a lieu sur le contenu de ce champ. Notez que vous devez ajouter <code>daemonic</code> à la liste des dépendances, si votre paquet utilise ce champ.
</p>
</itemd></item>

<item><itemt>DaemonicName</itemt>
<itemd>
<p>
Nom du fichier de description d'un service <code>daemonic</code>. Voir la description de DaemonicFile pour de plus amples informations.
</p>
</itemd></item>

</itemtable>
<p><em>Autres informations :</em></p>
<itemtable labeld="Utilisation" labelt="Champ">

<item><itemt>Homepage</itemt>
<itemd>
<p>
URL de la page d'accueil du paquet en amont.
</p>
</itemd></item>


<item><itemt>DescDetail</itemt>
<itemd>
<p>
Description plus détaillée que celle figurant dans le champ <code>Description</code> (répond aux questions : qu'est-ce que c'est ?, comment l'utiliser?). Les lignes multiples sont autorisées. Comme ce champ sera affiché sans que la longueur des lignes soit adaptée à la largeur de la fenêtre d'affichage, vous devez insérer des sauts de ligne, de façon à ce que les lignes ne dépassent pas 78 caractères (si possible).
</p>
</itemd></item>

<item><itemt>DescUsage</itemt>
<itemd>
<p>
Information nécessaire à l'utilisation du paquet (répond à la question : comment l'utiliser ?). Exemple : "run wmaker.inst once before using WindowMaker". Lignes multiples autorisées. Comme ce champ sera affiché sans que la longueur des lignes soit adaptée à la largeur de la fenêtre d'affichage, vous devez insérer des sauts de ligne, de façon à ce que les lignes ne dépassent pas 78 caractères (si possible).
</p>
</itemd></item>

<item><itemt>DescPackaging</itemt>
<itemd>
<p>
Notes sur la construction du paquet. Les éléments du type : "patches the Makefile to put everything in place" sont placés dans ce champ. Lignes multiples autorisées.
</p>
</itemd></item>

<item><itemt>DescPort</itemt>
<itemd>
<p>
Notes spécifiques au portage du paquet sur Darwin. Les éléments du type : "config.guess and libtool scripts are updated, -no-cpp-precomp is necessary" sont placés dans ce champ. Lignes multiples autorisées.
</p>
</itemd></item>

</itemtable>
</section>

<section name="splitoffs"><title>Paquets multiples</title>
<p>
À partir de la version 0.9.9 de fink, on peut utiliser un seul fichier .info pour construire plusieurs paquets. La phase d'installation commence, comme pour tout autre type de paquet, par l'exécution des scripts <code>InstallScript</code> et <code>DocFiles</code>. Si un champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code> est présent, il y a création d'un répertoire d'installation supplémentaire. À l'intérieur des champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>, le nouveau répertoire d'installation est désigné par %i, tandis que le répertoire d'installation du paquet parent est désigné par %I.
</p>
<p>
Chaque champ <code>SplitOff</code> ou <code>SplitOff<em>N</em></code> doit contenir un certain nombre de champs qui lui sont propres. En fait, cela ressemble à une description de paquet ordinaire, mais certains champs sont omis. Voici les champs qui peuvent y figurer (classés par catégorie) :
</p>
<ul>
<li>Données initiales : seul le champ <code>Package</code> doit être spécifié, tout le reste est hérité du paquet parent. Vous pouvez modifier les champs <code>Type</code> et <code>License</code> en déclarant ces champs dans les champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>. On peut utiliser les raccourcis ; il est préférable de mentionner le nom du paquet parent sous la forme %N.</li>
<li>Dépendances : tous les champs sont autorisés.</li>
<li>Phases de décompression, d'application des rustines, de compilation : ces champs n'ont pas de signification dans ce contexte et seront ignorés s'ils sont présents.</li>
<li>Phases d'installation et de construction : tous les champs sont autorisés à l'exception des champs SplitOff (un champ SplitOff ne peut contenir lui-même un autre champ SplitOff).</li>
<li>Données supplémentaires : elles sont héritées du paquet parent, mais peuvent être modifiées en déclarant le champ dans les champs <code>SplitOff</code> ou <code>SplitOff<em>N</em></code>.</li>
</ul>
<p>
Lors de la phase d'installation, les champs <code>InstallScript</code> et <code>DocFiles</code> du paquet parent sont exécutés en premier. Puis vient l'exécution des champs <code>SplitOff</code> et <code>SplitOff<em>N</em></code>. Pour chacun de ces champs à tour de rôle, la commande <code>Files</code> déplace les fichiers et répertoires spécifiés, du répertoire d'installation %I du paquet parent dans le répertoire de l'installation en cours %i. Puis les scripts <code>InstallScript</code> et <code>DocFiles</code> des paquets <code>SplitOff</code> et <code>SplitOff<em>N</em></code> sont exécutés.
</p>
<p>
À l'heure actuelle, le champ <code>SplitOff</code>, s'il existe, est exécuté en premier, suivi des champs <code>SplitOff<em>N</em></code> par ordre numérique. Néanmoins, cela pourrait changer dans le futur. Il est donc conseillé de ne pas utiliser :
</p>
<codeblock>
SplitOff: &lt;&lt;
  Description: certains headers
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: tous les autres headers
  Files: include/*
&lt;&lt;
</codeblock>
<p>
qui ne fonctionne correctement que si <code>SplitOff</code> est exécuté avant <code>SplitOff2</code>. Il vaut mieux donner la liste explicite des fichiers pour chaque champ (ou utiliser des noms de fichier plus explicites).
</p>
<p>
Lors de la phase de construction du paquet, les scripts pre/post install/remove de chacun des paquets sont construits à partir des commandes spécifiques de la phase de construction desdits paquets.
</p>
<p>
Chaque paquet à construire doit placer les fichiers de licence dans %i/share/doc/%n (avec %n ayant une valeur différente pour chaque paquet). Notez que <code>DocFiles</code> copie les fichiers au lieu de les déplacer ; il est donc possible d'installer une même copie de la documentation dans chacun des paquets en utilisant <code>DocFiles</code> plusieurs fois.
</p>
</section>

<section name="scripts"><title>Scripts</title>

<p>
Les champs PatchScript, CompileScript et InstallScript vous permettent d'indiquer des commandes shell à exécuter. Le répertoire de construction (<filename>%b</filename>) est le répertoire en cours lors de l'exécution des scripts. Vous devez toujours utiliser des chemins relatifs ou des raccourcis pour les fichiers et répertoires de l'arborescence fink, et jamais des chemins absolus. Deux formats différents sont possibles pour ces champs.
</p>
<p>
Le champ peut être constitué d'une simple liste de commandes, un peu comme un script shell. Néanmoins, les commandes sont exécutées ligne après ligne via system(). Il en résulte que l'assignation de variables ou les changements de répertoire n'ont d'effet que pour les commandes résidant sur une même ligne. À partir d'une version CVS de fink postérieure à 0.18.2, vous pouvez ajuster la longueur des lignes de la même manière que dans les scripts shell : une barre oblique inversée (<code>\</code>) à la fin de la ligne indique que la ligne suivante est la suite de la ligne précédente.
</p>
<p>
Vous pouvez aussi insérer un script complet, en utilisant l'interpréteur que vous voulez. Comme avec tout autre script Unix, la première ligne doit commencer par <code>#!</code> suivi du chemin complet de l'interpréteur et des options désirées (exemple : <code>#!/bin/csh</code>, <code>#!/bin/bash -ev</code>, etc...). Dans ce cas, la totalité du champ *Script est déversé dans un fichier temporaire, qui est alors exécuté.
</p>
</section>

<section name="patches"><title>Rustines</title>

<p>
Si votre paquet nécessite une rustine pour compiler sous Darwin (ou pour fonctionner avec fink), donnez à la rustine le même nom que celui indiqué dans la description du paquet, en utilisant l'extension ".patch" au lieu de ".info", et placez-la dans le même répertoire que le fichier .info. Si vous utilisez le nom complet du paquet dans le nom du fichier, indiquez-le dans le champ d'une des façons suivantes (elles sont équivalentes) :
</p>
<codeblock>Patch: %f.patch</codeblock>
<codeblock>PatchScript: patch -p1 &lt;%a/%f.patch</codeblock>
<p>
Si vous utilisez les nouvelles conventions de nommage d'un paquet unique, utilisez %n au lieu de %f. Ces deux champs ne sont pas exclusifs l'un de l'autre ; vous pouvez utiliser les deux et ils seront tous deux exécutés. Dans ce cas,  le script PatchScript sera exécuté en dernier.
</p>
<p>
Comme il se peut que vous ayez besoin du préfixe choisi par l'utilisateur dans le fichier rustine, il est conseillé d'utiliser une variable telle <code>@PREFIX@</code> au lieu de <code>/sw</code> dans la rustine et d'utiliser ensuite :
</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt;%a/%f.patch | patch -p1</codeblock>
<p>Les rustines doivent être en format unidiff et sont, en général, créées en utilisant :</p>
<codeblock>diff -urN &lt;répertoiredusourceoriginel&gt; &lt;répertoiredusourcemodifié&gt;</codeblock>
<p>
Si vous utilisez emacs pour modifier les fichiers, vous devez ajouter <code>-x'*~'</code> à la commande diff ci-dessus, pour exclure les fichiers de sauvegarde générés automatiquement.</p>
<p>
Il faut aussi noter que les très grosses rustines ne doivent pas être mises dans cvs. Elles doivent être placées sur un serveur web/ftp et référencées en utilisant le champ <code>SourceN:</code>. Si vous n'avez pas de site web, les administrateurs du projet fink peuvent mettre le fichier à disposition à partir du site web de fink. Si votre rustine fait plus de 30Kb, vous devez la traiter comme un téléchargement distinct.
</p>
</section>

<section name="profile.d"><title>Scripts profile.d</title>

<p>
Si votre paquet nécessite une initialisation à l'exécution (par exemple, pour définir des variables d'environnement), vous pouvez utiliser des scripts profile.d. Ces scripts sont sourcés par les scripts <filename>/sw/bin/init.[c]sh</filename>. Normalement, tout utilisateur de fink charge ces scripts dans ses fichiers de démarrage de shell (<filename>.cshrc</filename> et équivalents). Votre paquet doit fournir deux variantes de scripts : l'une pour les shells compatibles avec sh (sh, zsh, bash, ksh, ...), l'autre pour les shells compatibles avec csh (csh, tcsh). Elles doivent être installées sous la forme <filename>/sw/etc/profile.d/%n.[c]sh</filename> (où %n représente le nom du paquet). Il faut aussi positionner leurs bits de lecture et d'exécution (c'est-à-dire les installer avec -m 755), autrement elles ne seront pas chargées correctement.
</p>
<p>
Si vous n'avez besoin que d'initialiser certaines variables d'environnement (par exemple, définir QTDIR comme '/sw'), vous pouvez utiliser le champ RuntimeVars, qui a été conçu exactement pour ce faire.
</p>
</section>
</chapter>
</document>
