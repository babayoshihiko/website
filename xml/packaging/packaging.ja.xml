<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document SYSTEM "../finkdoc.dtd">

<document filename="index" lang="ja" >
	<title>Fink パッケージの作成方法</title>
	<shorttitle>パッケージ作成</shorttitle>
	<cvsid>$Id: packaging.ja.xml,v 1.28 2005/06/09 21:45:18 babayoshihiko Exp $</cvsid>
	<preface>
		<p>
			このマニュアルではパッケージ管理システム Fink 用のパッケージ記述 (Package Description) の作成方法を解説します．
			また Fink ディストリビューションのポリシーとガイドラインも解説します．
			パッケージ記述の書式もディストリビューションのポリシーも共に発展途上です．
			&quot;Last changed&quot; (最終更新) 情報とこのページの CVS タグを確認することで，更新されているかがわかります．
			ここで扱うのはパッケージ管理システム Fink の「0.9.0 以降の開発版」で使われる書式とポリシーの説明です．
		</p>
		<p>
			Fink 用にパッケージを作成した場合，メーリングリスト
			<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link> を購読するとよいでしょう．
			Fink に貢献する方法を探していて，関連分野のスキルをお持ちなら，是非とも
			<link url="http://fink.sourceforge.net/pdb/nomaintainer.php">現在メンテナのいないパッケージ</link>
			のメンテナンスをお願いいたします．
		</p>
	</preface>
	<chapter filename="intro">
		<title>始めに</title>
		<shorttitle>始めに</shorttitle>
		<section name="def1">
			<title>パッケージとは何か?</title>
			<p>
				パッケージとは，基本的単位を構成するソフトウェアのまとまりを指します．
				典型的なパッケージには，例えば実行可能プログラム，それが必要とするデータファイル，
				国際化のためのメッセージカタログ，そしてドキュメントが含まれます．
				Fink のパッケージには2種類の形式があります．
				すなわちパッケージ記述情報と，そのままインストール可能なバイナリパッケージファイルです．
			</p>
			<p>
				パッケージ記述情報は人でも読めるテキストファイルで，
				パッケージをビルドするために必要な (つまりバイナリパッケージファイルを作るのに必要な) 全ての情報を含みます．
				それにはメタデータ (パッケージ名や目的を記した文章) やソースコードの URL の他，
				パッケージの configure ，コンパイルやバイナリパッケージの生成に必要な命令が書かれています．
			</p>
			<p>
				バイナリパッケージファイルとは，パッケージを実際に構成する各ファイルのアーカイブを指し，
				中には実行可能プログラム，データファイル，メッセージカタログ，ライブラリ，インクルードファイルなどが含まれます．
				また，そのパッケージに関するメタデータも含まれます．
				バイナリパッケージは既にそのまま使用できる形式ですので，インストールとは主に中身の展開です．
				Finkはパッケージ管理システム dpkg の上に構築されたシステムですので，
				バイナリパッケージには dpkg の形式が使われ，拡張子は .deb です．
			</p>
		</section>
		<section name="ident">
			<title>パッケージの区別</title>
			<p>
				パッケージは3つの文字列で区別されます．
				すなわち「パッケージ名」，「バージョン」と「版」です．
				これらのいずれにも英小文字 (a から z)，数字 (0 から 9)， ダッシュ (-)，プラス (+)，ドット (.) のみが使えます．
				この他の字は使えません．
				特に，大文字と下線 (_) が使えないことに注意して下さい．
			</p>
			<p>
				「パッケージ名」にはソフトウェアの名前 (openssh など) をそのまま使います．
				「バージョン」は「upstream バージョン」とも呼ばれますが，これには元となるソフトウェアパッケージのバージョンを使います．
				「バージョン」には (2.9p1 のように) 数字以外を使っても構いません．
				Fink も dpkg もそれらを認識してソートできます．
				「版」はカウンタで，最初は 1 で始まり，パッケージ記述情報への変更回数に応じて 1 ずつ増加します．
				「upstream バージョン」が変化すると再び 1 に戻ります．
				「版」にダッシュを使ってはいけません．
				Fink パッケージの正式名称は「パッケージ名」，「バージョン」と「版」をダッシュでつないだもので，
				&quot;openssh-2.9p1-2&quot; などという形式になります．
			</p>
		</section>
	</chapter>
	<chapter filename="format">
		<title>パッケージ記述</title>
		<shorttitle>パッケージ記述</shorttitle>
		<section name="trees">
			<title>ツリーレイアウト</title>
			<p>
				パッケージ記述はディレクトリ <filename>/sw/fink/dists</filename> 下のディレクトリ <code>finkinfo</code> から読み込まれます．
				「ツリー」の設定はファイル <filename>/sw/etc/fink.conf</filename> にあり，これでどのディレクトリを読むかを指定します．
				パッケージ記述ファイルの名前は，Fink パッケージの正式名称に拡張子 &quot;.info&quot; を付けたものです．
				Fink 0.13.0 以降では，パッケージのアップデートの手間を省くための，
				「パッケージ名」に拡張子 &quot;.info&quot; を付けただけの簡略形式が便利です．
			</p>
			<p>
				パッケージ記述ツリーはいくつかの階層のディレクトリにまとめられています．
				最上段から順の説明:
			</p>
			<ul>
				<li>
					ツリーは <code>dists</code> から始まる．
					<code>dists</code> ディレクトリは Debian ツールで必須．
				</li>
				<li>
					ディストリビューション．
					<code>stable</code>,<code>unstable</code>, <code>local</code> に分かれる．
					ディレクトリ <code>local</code> は各システムの管理者とユーザが管理する．
					ディレクトリ <code>stable</code> と <code>unstable</code> は Fink システムの一部．
				</li>
				<li>
					ツリー．
					ツリー <code>main</code> にはパッケージの大部分が含まれる．
					暗号を使うソフトウェアは別ツリー <code>crypto</code> に収められ，必要とあらば簡単に取り除ける．
				</li>
				<li>
					<code>finkinfo</code> または <code>binary-darwin-powerpc</code>．
					<code>finkinfo</code> は Fink のパッケージ記述とパッチを含み，
					<code>binary-darwin-powerpc</code> は <code>.deb</code> 形式のバイナリパッケージを含む．
				</li>
				<li>
					セクション．
					ツリー <code>main</code> は，管理しやすくするために種類別に分類されている．
					ツリー <code>crypto</code> は現在のところ分類されていない．
				</li>
			</ul>
		</section>
		<section name="format">
			<title>ファイル形式</title>
			<p>
				パッケージ記述ファイルはキーと値の組 (別名「フィールド」) の単純なリストです．
				次のように，各行はキーで始まり，コロン (:) 以降が値になります:
			</p>
<codeblock>Key: Value</codeblock>
			<p>
				複数行に渡らざるを得ないフィールドには 2 通りの記法があります．
			</p>
			<p>
				1 つ目はシェルスクリプトで言う &quot;here-document&quot; 風の形式で，こちらの方が望ましいです．
				この方式では，第1行は，キー，コロンの次に値として <code>&lt;&lt;</code> が続くものになります．
				その後の行が全て実質的な値となり，行頭に <code>&lt;&lt;</code> を置いた行が値の終端区切りです．
				例:
			</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
			<p>
				この形式ではインデントを付けて構いません．
				その方が読みやすくなるでしょう．
			</p>
			<p>
				here-document 形式はネストできます．
				これはフィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> でよく使われます．
				これらのフィールドは他の (複数行の) フィールドを含むことができ，
				here-document 形式を使えば含まれる方のフィールドにも複数行の値が使えます．
				内側でも同じ区切り <code>&lt;&lt;</code> が使われます．
			</p>
<codeblock>
SplitOff: &lt;&lt;
    Package: %N-shlibs
    InstallScript: &lt;&lt;
        ln -s %p/lib/libfoo.2.dylib %i/lib/libfoo.%v.dylib
    &lt;&lt;
&lt;&lt;
</codeblock>
			<p>
				今は推奨されない旧式の記法は「RFC 822 ヘッダ折り畳み方法」を手本に作られました．
				空白で始まる行を前の行からの続きと認識します．
				例:
			</p>
<codeblock>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</codeblock>
			<p>
				各行頭の空白は必須であることに注意して下さい．
			</p>
			<p>
				どちらの形式でも，空行と，シャープ (#) で始まる行は無視されます．
				キー (フィールド名) では大文字と小文字の区別がないので，
				<code>InstallScript</code> を <code>installscript</code> や <code>INSTALLSCRIPT</code> とも書けますが，
				最初の <code>InstallScript</code> という方式が読み易いのでこれを使いましょう．
				真偽値を取るフィールドでは &quot;true&quot;, &quot;yes&quot;, &quot;on&quot;, &quot;1&quot; (大文字，小文字の区別なし)
				のいずれも「真」となり，それ以外は全て「偽」になります．
			</p>
		</section>
		<section name="percent">
			<title>パーセント展開</title>
			<p>
				簡便のため， Fink はいくつかのフィールドで以下の文字列展開をサポートします．
				曖昧さをさけるため，波括弧を使ってどの文字までがパーセント展開を受けるのかを明示できます．
				例えば <code>%{n}</code> は <code>%n</code> と同義です．
			</p>
			<itemtable labeld="" labelt="">
				<item>
					<itemt>%n</itemt>
					<itemd>
						<p>
							<em>n</em>ame．「パッケージ名」．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%N</itemt>
					<itemd>
						<p>
							<em>N</em>ame．親パッケージの「パッケージ名」． (<code>SplitOff</code> 内部以外では %n と同じ)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%e</itemt>
					<itemd>
						<p>
							<em>e</em>poch．パッケージの「エポック」．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%v</itemt>
					<itemd>
						<p>
							<em>v</em>ersion．「バージョン」．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%r</itemt>
					<itemd>
						<p>
							<em>r</em>evision．パッケージの「版」．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%f</itemt>
					<itemd>
						<p>
							<em>f</em>ull package name．%n-%v-%r と等価．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%p, %P</itemt>
					<itemd>
						<p>
							<em>p</em>refix．Fink のインストール場所．例: <filename>/sw</filename>．
							全てのユーザーが <filename>/sw</filename> に Fink をインストールしているわけではない．
							<code>%p</code> で正しいパスを取得する．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%d</itemt>
					<itemd>
						<p>
							<em>d</em>estination．パッケージ化するツリーのビルド先．
							例:<filename>/sw/src/root-gimp-1.2.1-1</filename>
							この一時ディレクトリはパッケージをコンパイルする際のインストール段階でルートディレクトリの役を果たす．
							<filename>root-%f</filename> が <filename>%p/src</filename> の中にあることを当てにしてはいけない．
							ユーザが設定ファイル <filename>/sw/etc/fink.conf</filename> でフィールド <code>Buildpath</code>
							を指定すればこの場所は変わってしまう．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%D</itemt>
					<itemd>
						<p>
							<em>D</em>estination．
							親パッケージのビルド先 (<code>SplitOff</code> 内部以外では %d と同じ)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%i</itemt>
					<itemd>
						<p>
							the full <em>i</em>nstall-phase prefix．インストール段階での一時インストールディレクトリの完全名． %d%p と等価．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>%I</itemt>
					<itemd>
						<p>
							<em>I</em>nstall prefix．
							親パッケージのインストール段階での一時インストールディレクトリの完全名．
							%D%Pと等価 (<code>SplitOff</code> 内部以外では %i と同じ)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%a</itemt>
					<itemd>
						<p>
							p<em>a</em>tches．
							パッチを検索するディレクトリパス．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%b</itemt>
					<itemd>
						<p>
							<em>b</em>uild．
							ビルドディレクトリ．例: <filename>/sw/src/gimp-1.2.1-1/gimp-1.2.1</filename>
							<filename>%f</filename> が <filename>%p/src</filename> の中にあることを当てにしてはいけない．
							ユーザが設定ファイル <filename>/sw/etc/fink.conf</filename> でフィールド <code>Buildpath</code>
							を指定すればこの場所は変わってしまう．
							最も内側のディレクトリ名は， <code>Source</code> ファイル名か， (もしあれば) <code>SourceDirectory</code> 
							フィールドの値となります．
							ただし， <code>NoSourceDirectory</code> が <code>true</code>
							であれば使用されません．
						</p>
						<p>
							注記: %b は使わざるを得ないときだけ使用して下さい．
							ビルドディレクトリはスクリプトが実行されるときのカレントディレクトリです．
							コマンドでは相対パス名を使わなければいけません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%c</itemt>
					<itemd>
						<p>
							configure に渡すパラメータ: <code>--prefix=%p</code> の他，フィールド <code>ConfigureParams</code> で指定したもの全て．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%m</itemt>
					<itemd>
						<p>
							<em>m</em>achine architecture．
							マシンアーキテクチャーを示す記号で，<code>uname -p</code> の出力．
							現在のところ， PPC マシンでは 'powerpc' ， x86 マシンでは 'i386' という値になる
							(0.12.1 CVS版以降の Fink で導入)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%%</itemt>
					<itemd>
						<p>
							パーセント記号そのもの (これ以降にどの文字が続いても展開されない)．
							展開は厳密に左から右に行われるので， %%n はパッケージ名とは一切関係なく，単なる文字列 %n を表すことになる．
							(fink-0.18.0 で導入)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%type_raw[<em>タイプ</em>], %type_pkg[<em>タイプ</em>]</itemt>
					<itemd>
						<p>
							指定された <em>タイプ</em> のサブタイプを返す疑似ハッシュ．
							詳細は後述のフィールド <code>Type</code> の解説を参照．
							_raw 形式はサブタイプの文字列をそのまま返すが， _pkg 形式はドット (.) を 全て取り除いた文字列を返す．
							(Fink のパッケージ命名規約の「プログラミング言語-バージョン」方式に使う．他にもうまい使い方があるかも)．
							(0.19.2 CVS 版以降の Fink で利用可能)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>%{ni}, %{Ni}</itemt>
					<itemd>
						<p>
							&quot;<em>n</em>ame <em>i</em>nvariant&quot;．
							%n や %N と似ているが， %type_pkg[] と %type_raw[] に当たる部分は全て空白に変わる．
							(0.19.2 CVS 版以降の Fink で利用可能)
							%n や %N を使った際の混乱を避けるためには %{ni} や %{Ni} を使うこと．
						</p>
					</itemd>
				</item>
				
				<item>
					<itemt>%{default_script}</itemt>
					<itemd>
						<p>
							<code>*Script</code> フィールドでのみ有効．
							<code>*Script</code> フィールドでのデフォルトフィールド．
							値は <code>Type</code> に依存するが，常に存在する（または空欄）．
							<code>SplitOff: InstallScript</code> で使われる場合，
							<code>SplitOff</code> パッケージの <code>InstallScript</code> デフォルトが空欄であっても，
							この展開は<em>親</em>のデフォルトになる．
							
						</p>
					</itemd>
				</item>
			</itemtable>
		</section>
	</chapter>
	<chapter filename="policy">
		<title>パッケージ化ポリシー</title>
		<shorttitle>ポリシー</shorttitle>
		<section name="licenses">
			<title>パッケージのライセンス</title>
			<p>
				Fink に含まれるパッケージのライセンスは多岐に渡ります．
				大部分は，ソース全体の再配布と，特に実行可能ファイルの配布に何らかの制限を課します．
				パッケージの中には，ライセンスのために Fink でバイナリ配布を行えないものもあります．
				そのため，パッケージのメンテナがライセンスを注意深くチェックすることが大変に重要です．
			</p>
			<p>
				バイナリ・パッケージとして配布される全てのパッケージは，ライセンスのコピーも含んでいなければいけません．
				ライセンスは doc ディレクトリすなわち <code>%p/share/doc/%n</code> にインストールされます．
				(InstallScript では，当然ながら %p でなく %i を使う必要があります．
				フィールド DocFiles ににより細部は自動的に処理されます．)
				元のソースに明示的なライセンスが存在しない場合，パッケージの状態を記した短いテキストを代わりとします．
				大半のライセンスは，ライセンスが配布物に必ず含まれるよう定めています．
				Finkのポリシーは「ライセンスを含めるよう明示的に要求されなくとも，常にライセンスを含める」ことです．
			</p>
			<p>
				バイナリディストリビューションのメンテナンスを自動化するため，
				配布されるどのパッケージにもフィールド <code>License</code> がなければいけません．
				このフィールドはライセンスの性質に関するもので，
				当該パッケージをバイナリディストリビューションに含めるかどうかを決定する際に参照されます．
				このフィールドは実際のライセンス条項が上記のようにバイナリパッケージに含まれているときのみ存在できます．
			</p>
			<p>
				フィールド License を有効に使用するため，値は以下の既定の選択肢からのみ選べます．
				下記の選択肢に当てはまらないパッケージの場合，開発用メーリングリストへ質問を投げかけて下さい．
			</p>
			<ul>
				<li>
					<code>GPL</code> - GNU General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<code>LGPL</code> - GNU Lesser General Public License．
					ソースがバイナリと同じ場所から入手できる必要がある．
				</li>
				<li>
					<code>GPL/LGPL</code> -
					これは特殊な場合で，パッケージの一部 (実行可能プログラムなど) が GPL で，
					別の部分 (ライブラリなど) が LGPL になっているパッケージ．
				</li>
				<li>
					<code>BSD</code>  -
					BSD形式のライセンス．
					これには，いわゆる「オリジナル」 BSD ライセンス，「修正」 BSD ライセンスおよび MIT ライセンスが含まれる．
					The Apache lisence もこの一種とみなす．
					ソースコードを配布することは必須でない．
				</li>
				<li>
					<code>Artistic</code> -
					The Artistic lisence 及びその派生型．
				</li>
				<li>
					<code>Artistic/GPL</code> -
					The Artistic lisence と GPL のデュアルライセンス．
				</li>
				<li>
					<code>GNU Free Documentation License</code> および <code>Linux Documentation Project</code> -
					付属ドキュメントが明示的にこのライセンスのどちらかを採用している場合，
					値に <code>/GFDL</code> と <code>/LDP</code> のいずれか，または両方を後置する．
					結果として以下の組合せが可能: &quot;GFDL&quot;, &quot;GPL/GFDL&quot;, &quot;LGPL/GFDL&quot;, &quot;GPL/LGPL/GFDL&quot;,
					&quot;LDP&quot;, &quot;GPL/LGPL/LDP&quot;.
				</li>
				<li>
					<code>DFSG-Approved</code> - 
					<link url="http://www.debian.org/social_contract.ja.html">Debian 社会契約</link> のガイドラインに沿ったソフトウェア
				</li>
				<li>
					<code>OSI-Approved</code> -
					<link url="http://www.opensource.org/">Open Source Initiative</link> が承認した，その他の Open Source ライセンス．
					OSI はバイナリとソースの自由な配布を許可するよう要求しています．
					デュアルライセンスのパッケージにとりあえずこの選択肢を選ぶこともできます．
				</li>
				<li>
					<code>Restrictive</code> -
					制限付きのライセンス．
					作者からソース形式で free use のために入手できるが，free redistribution は許可されないパッケージに使う．
				</li>
				<li>
					<code>Restrictive/Distributable</code> -
					ソースとバイナリの配布を許可するが制限のあるライセンス．
					当該パッケージが作者からソース形式で入手でき，ソースとバイナリの配布も許可されているが，
					Open Source ライセンスと認められない制限がある場合に使う．
				</li>
				<li>
					<code>Commercial</code> -
					制限付きの商用ライセンス．
					ソースやバイナリの自由な再配布を許可しない商用パッケージ (フリーウェアやシェアウェアなど) に使う．
				</li>
				<li>
					<code>Public Domain</code> -
					パブリックドメインの，すなわち作者がコードに対するコピーライトを放棄したパッケージ．
					この場合，パッケージにはライセンスが存在せず，だれが何をしても良い．
				</li>
			</ul>
		</section>
		<section name="openssl"><title>GPL と OpenSSL</title>
			<p>
				(2005年４月より施行)
			</p>
			<p>
				OpenSSL ライセンスが GPL と LPGL ライセンスが明らかに整合性を欠いていることから，
				openssl にリンクをしている fink パッケージのうち， GPL または LGPL ライセンスを使用しているものは
				&quot;Restrictive&quot; となります．
				Fink プロジェクトはこれらのパッケージをバイナリ配布しないことになるが，利用者は自己判断でコンパイルすることができます．				
			</p>
			<p>
				パッケージメンテナは，元のパッケージライセンスを <code>DescPackaging</code> に記述してください．
			</p>
		</section>
		<section name="prefix">
			<title>基盤システムへの干渉問題</title>
			<p>
				Finkは基盤システムから分離したディレクトリにインストールされるアドオン・ディストリビューションです．
				パッケージは Fink のディレクトリ外にファイルをインストールしてはしてはいけません．
			</p>
			<p>
				この決まりを破る他に仕方がないときには例外が設けられます (XFree86 など)．
				この場合，パッケージはインストール前に既存のファイルを調べ，上書きの恐れがある場合はインストールを中止する必要があります．
				そのようなパッケージは， Fink ディレクトリ外にインストールしたファイルはそのパッケージが取り除かれるときに全て削除されること，
				あるいはそのようなファイルは残しても問題がないことを保証しなければいけません
				(すなわち，実行可能ファイルを呼び出す前にそれが存在するかどうか調べるなどする必要があります)．
			</p>
		</section>
		<section name="sharedlibs">
			<title>共有ライブラリ</title>
			<p>
				Fink は共有ライブラリに関して新しいポリシーを定め， 2002 年 2 月から施行しています．
				以下では Fink 0.5.0 と共に公布された，共有ライブラリについてのポリシー第 4 版について説明します．
				最初に要点をかいつまんで述べ，後から詳細に移ります．
			</p>
			<p>
				共有ライブラリをビルドするパッケージで，
				(1) ツリー stable に入っているか，または (2) 新規のパッケージである場合，
				Fink ポリシーに従って共有ライブラリを扱う必要があります．
				すなわち以下の約束に従わなければいけません．
			</p>
			<ul>
				<li>
					コマンド <code>otool -L</code> を使い，各ライブラリの install_name ，互換性，バージョンが適切か確認する．
				</li>
				<li>
					共有ライブラリを別パッケージとし (例外は libfoo.dylib から install_name へのリンク) ，
					さらに，そうしてできた別パッケージにフィールド <code>Shlibs</code> を設ける．
				</li>
				<li>
					ヘッダと， libfoo.dylib からの最終的リンクを <code>BuildDependsOnly: True</code> となっているパッケージに入れ，
					他のパッケージが一切そのパッケージに依存しないようにする．
				</li>
			</ul>
			<p>
				このポリシーに反し，パッケージを分割しない場合には，フィールド <code>DescPackaging</code> に理由を記述しなければいけません．
			</p>
			<p>
				パッケージによっては，主パッケージと -shlib パッケージを作成するだけで済みます．
				しかしさらに別のパッケージが必要な場合もあります．
				新設されたフィールド <code>SplitOff</code> を使うとこの作業の手間が省けます．
			</p>
			<p>
				3つのパッケージに分ける必要があるとき，それらの命名法は，
				パッケージの実質的な中身がライブラリなのか (選択肢 1) 実行可能プログラムなのか (選択肢 2) によって変わります．
				選択肢 1 では次の構成を使います．
			</p>
			<itemtable labeld="Contents" labelt="Package">
				<item>
					<itemt>
						<code>foo-shlibs</code>
					</itemt>
					<itemd>
						<p>共有ライブラリ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo</code>
					</itemt>
					<itemd>
						<p>ヘッダ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo-bin</code>
					</itemt>
					<itemd>
						<p>実行可能プログラムなど</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				選択肢 2 では次の構成を使います．
			</p>
			<itemtable labeld="Contents" labelt="Package">
				<item>
					<itemt>
						<code>foo-shlibs</code>
					</itemt>
					<itemd>
						<p>共有ライブラリ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo-dev</code>
					</itemt>
					<itemd>
						<p>ヘッダ</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<code>foo</code>
					</itemt>
					<itemd>
						<p>実行可能プログラムなど</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				選択肢 2 を選ぶと，既存のパッケージのアップグレードに手間がかかります．
				アップグレードと同時に， <code>Depends: foo</code> との記述のある全てのパッケージに
				<code>BuildDepends: foo-dev</code> を加える必要があるのです．
				注意すべき点は他にもあります．
				(中間に別のパッケージを経由して) 間接的に当該パッケージに依存するパッケージのアップグレードを確かに成功させるためには，
				そのようなパッケージに <code>BuildDepends: foo</code> あるいは
				<code>BuildDepends: foo-dev</code> を加える必要があるかもしれません．
				当該パッケージのメンテナには，他のパッケージに <code>BuildDepends</code> が追加されるのを確認する責任があります．
			</p>
			<p>
				<em>詳細なポリシー</em>
			</p>
			<p>
				以下ではさらに詳しく解説します．
				まず新規にソフトウェアを Fink に移植する際のポリシーを解説し，次に既存 Fink パッケージのアップグレードに移ります．
				ポリシーが実際に適用された例としては Fink パッケージ libpng, libjpeg や libtiff を参照して下さい．
			</p>
			<p>
				Darwin にポートされたソフトウェアは可能な限り共有ライブラリをビルドしなければいけません．
				(パッケージメンテナが，必要に応じて共有ライブラリの他に静的ライブラリもビルドすることは自由です．
				または，静的ライブラリのみを含むパッケージを登録することも問題ありません．)
				共有ライブラリをビルドする場合，<em>ふたつの</em>相互関連する Fink パッケージを作成しなければいけません．
				それらの名称は例えば foo と foo-shlibs となります．
				共有ライブラリは foo-shlibs に，ヘッダは foo に入ります．
				これら 2 つのパッケージを単一の .info ファイルから作れます．
				それには後述のフィールド <code>SplitOff</code> を使います．
				(現実には3つ以上のパッケージに分割する必要がある場合も多いですが，
				この場合は <code>SplitOff2</code>, <code>SplitOff3</code> などを使えばだいじょうぶです．)
			</p>
			<p>
				共有ライブラリを伴うソフトウェアパッケージには， <em>「メジャーバージョン」</em> N がなければいけません．
				「メジャーバージョン」は，ライブラリの API にパッケージ間で非互換な変更が加えられたときのみ変わることになっています．
				Fink では，名称は以下の要領で作成されます．
				すなわち， upstream パッケージ名が bar なら，そのFinkパッケージの名前は barN と barN-shlibs になります．
				(この規則が厳密に適用されるのは新規に作られるパッケージと「メジャーバージョン」が変わったパッケージのみです．)
				例えば既存の Fink パッケージ libpng の「メジャーバージョン」は 2 でしたが，最近， 3 に変わりました．
				そこで当面は libpng に関わる Fink パッケージは4種類あることになります:
				libpng, libpng-shlibs, libpng3, libpng3-shlibs です．
				libpng と libpng3 はどちらか片方しか同時にインストールできませんが，
				libpng-shlibs と libpng3-shlibs は同時にインストールできます．
				(これら 4 つのパッケージのビルドに必要な .info ファイルは 2 つだけであることに注意してください．)
			</p>
			<p>
				共有ライブラリ自身とそれに関わるファイルは，パッケージ barN-shlibs に入ります．
				また「インクルード」ファイルとその他のファイルはパッケージ barN に入ります．
				これら 2 つに重複して含まれるファイルがあってはならず，また barN-shlibs に含まれるどのファイルのパス名にも，
				何らかの形で「メジャーバージョン」 N が含まれなくてはいけません．
				多くの場合，パッケージは，典型的には <filename>%i/lib/bar</filename> や
				<filename>%i/share/bar/</filename> にインストールされるようなファイルを実行時に必要とします．
				そのときはインストール先パスを <filename>%i/lib/bar/N</filename> や
				<filename>%i/share/bar/N/</filename> に修正しなければいけません．
			</p>
			<p>
				「メジャーバージョン」が N であるようなパッケージ bar に依存するパッケージは，全て次の依存情報を使うことになります．
			</p>
<codeblock>
Depends: barN-shlibs
BuildDepends: barN
</codeblock>
			<p>
				この方式が機能するようになって以降は，他のパッケージが barN 自体に依存するようにしてはいけません．
				(後方互換性のため，既存のパッケージは barN に依存して構いません．)
				以上を他の開発者がわかるように，barN のパッケージ記述の中に次の真偽値フィールドを設けます．
			</p>
<codeblock>
BuildDependsOnly: True
</codeblock>
			<p>
				共有ライブラリと実行可能プログラムの両方を含むパッケージの場合，実行可能プログラムが (ビルド時だけでなく) 実行時に必要であれば，
				それらの実行可能プログラムは barN-bin という名の第 3 のパッケージに分離されます．
				他のパッケージが barN-shlibs の他に barN-bin に依存しても構いません．
			</p>
			<p>
				「メジャーバージョン」が N の共有ライブラリをビルドするとき，その共有ライブラリの &quot;install_name&quot; が
				<filename>%p/lib/bar.N.dylib</filename> になることが重要です．
				(install_name は，ライブラリに対し <code>otool -L</code> を実行すれば分かります．)
				実際のライブラリファイルのインストール先は，
			</p>
<codeblock>
%i/lib/bar.N.x.y.dylib
</codeblock>
			<p>
				でなければならず，パッケージ側では次のようにシンボリックリンクを貼らなければいけません．
			</p>
<codeblock>
%i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
%i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
</codeblock>
			<p>
				静的ライブラリもビルドする場合，次の場所にインストールされることになります．
			</p>
<codeblock>
%i/lib/bar.a
</codeblock>
			<p>
				パッケージが libtool を利用する場合，上記のことはほぼ自動的に処理されますが，
				どの段階でも処理が適切に行われたか確認する必要があります．
				また，共有ライブラリの current_version と compatibility_version が適切に定義されているかどうかも確認して下さい．
				(これらも <code>otool -L</code> で表示されます．)
			</p>
			<p>
				次に，ファイルを以下のように 2 つのパッケージに分類します．
			</p>
			<ul>
				<li>パッケージ barN-shlibs:
<codeblock>
%i/lib/bar.N.x.y.dylib
%i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
%i/lib/bar/N/*
%i/share/bar/N/*
%i/share/doc/barN-shlibs/*
</codeblock>
				</li>
				<li>パッケージ barN:
<codeblock>
%i/include/*
%i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
%i/lib/bar.a
%i/share/doc/barN/*
必要に応じて，他のファイルも含める
</codeblock>
				</li>
			</ul>
			<p>
				どちらのパッケージにもライセンスに関する何らかの文書が必要ですが，それらを格納するディレクトリは異なることに注意して下さい．
			</p>
			<p>
				このことはフィールド <code>SplitOff</code> を使えば実際には非常に簡単です．
				以下に上の例を実現するためにどのように記述するか (の一部) を示します．
			</p>
<codeblock>
Package: barN
Version: N.x.y
Revision: 1
License: GPL
Depends: barN-shlibs (= %v-%r)
BuildDependsOnly: True
DocFiles: COPYING
SplitOff: &lt;&lt;
  Package: barN-shlibs
  Files: lib/bar.N.x.y.dylib lib/bar.N.dylib lib/bar/N
  DocFiles: COPYING
&lt;&lt;
</codeblock>
			<p>
				フィールド <code>SplitOff</code> の処理により，指定されたファイルとディレクトリが，
				メインパッケージのインストールディレクトリ %I から splitoff パッケージのインストールディレクトリ %i に移動します．
				(これは命名法とも似ています．
				すなわち，%N がメインパッケージの「パッケージ名」で，%n が splitoff パッケージの「パッケージ名」でしたね．)
				次に <code>DocFiles</code> によりドキュメントファイルが <filename>%i/share/doc/barN-shlibs</filename> にコピーされます．
			</p>
			<p>
				barN-shlibs の正確な「バージョン」 (これは &quot;%N-shlibs (= %v-%r)&quot; と略記できます)
				を親パッケージ barN の依存情報に含めたことに注意して下さい．
				これにより「バージョン」が確かに適合するようになり，
				さらにパッケージ barN がパッケージ barN-shlibs の依存情報を自動的に「継承する」ことを保証します．
			</p>
			<p><em>フィールド BuildDependsOnly:</em></p>
			<p>
				ライブラリがアップグレードされる場合，移行期に二つのバージョンのヘッダファイルが必要になる時もあるでしょう．
				一つのバージョンはコンパイル時に使われ，もう一つは他のコンパイルに使われるような場合です．
				このため，ヘッダファイルを含むパッケージの作成には注意が必要となります．
				foo-dev と bar-dev が重複するヘッダを含む場合， foo-dev で，
			</p>
<codeblock>
   Conflicts: bar-dev
   Replaces: bar-dev
</codeblock>
			<p>
				と宣言し，同様に bar-dev では foo-dev を Conflicts/Replaces として宣言します．
			</p>
			<p>
				さらに，両方のパッケージで
			</p>
<codeblock>
   BuildDependsOnly: True 
</codeblock>
			<p>
				を宣言します．
				これにより，foo-dev または bar-dev に依存してパッケージを記述することを防ぐことができます．
				このような依存性が Conflicts/Replaces 手段を実行することを防ぐためです．
			</p>
			<p>
				ヘッダファイル付きのパッケージで， BuildDependsOnly を True にするのが適切ではないものもあります．
				この場合，そのパッケージでは
			</p>
<codeblock>
   BuildDependsOnly: False
</codeblock>
			<p>と宣言し，その理由を DescPackaging に記述します．</p>
			<p>
				BuildDependsOnly フィールドは，パッケージがヘッダファイルを含み /sw/include にインストールされる場合，
				パッケージの .info ファイルに記述されていなければなりません．
			</p>
			<p>
				fink 0.20.5 の時点で， &quot;fink validate&quot; とすることで，
				ヘッダファイルと，最低一つの dylib を含み， BuildDependsOnly 値で真偽を宣言していない .deb ファイルに警告を出します．
				(将来のバージョンでは，この機能をヘッダファイルと静的ライブラリに対応するように拡張する可能性もある．)
			</p>
			<p><em>フィールド Shlibs:</em></p>
			<p>
				共有ライブラリを適切なパッケージに分類する他に， Fink ポリシー第 4版では，
				共有ライブラリ全てをフィールド <code>Shlibs</code> を使って宣言しなければいけません．
				このフィールドでは，各共有ライブラリに対して 1 行ずつ 1) ライブラリの -install_name， 2) ライブラリの -compatibility_version，
				3) そのライブラリを提供する Fink パッケージを指定するバージョン付き依存性情報
				(ただし -compatibility_version が同じでなければならない) を記します．
				依存性情報は <code>foo (&gt;= バージョン-版)</code> という形式で示します．
				ここで <code>バージョン-版</code> にはこの (-compatibility_version が同じ) ライブラリを利用可能にしてくれる
				Fink パッケージの<em>最初</em>の「バージョン」を使います．
				例えば次の宣言は，
			</p>
<codeblock>
Shlibs: &lt;&lt;
%p/lib/bar.1.dylib 2.1.0 bar1 (>= 1.1-2)
&lt;&lt;
</codeblock>
			<p>
				<code>-install_name</code> が %p/lib/bar.1.dylib で <code>-compatibility_version</code> が 2.1.0 のライブラリが，
				Fink パッケージ <em>bar1</em> の「バージョン」1.1-2 以降でインストールされることを示します．
				それに加え，この宣言は「この名前がついていて compatibility_version が少なくとも 2.1.0 のライブラリは，
				Fink パッケージ bar1 の今後のバージョンには必ず含まれている」というメンテナからの保証にも相当します．
			</p>
			<p>
				ライブラリの名称には %p を使用するよう注意して下さい．
				これによって， Fink ユーザはインストールディレクトリに関係なく，正しい <code>-install_name</code> を検索できます．
			</p>
			<p>
				パッケージが更新されたとき，
				普通は次の「バージョン」または「版」のパッケージ記述にフィールド <code>Shlibs</code> をコピーするだけで構いません．
				例外は <code>-compatibility_version</code> が増加したときです．
				その場合，依存性情報の中の「バージョン-版」は新しい「バージョン」または「版」に従って更新されなければいけません．
				(新しい「バージョン」または「版」とは，
				新しい compatibility_version のライブラリを提供する最初の「バージョン」または「版」のことです．)
			</p>
			<p>
				<em>メジャーバージョン番号が変わるとき:</em>
			</p>
			<p>
				「メジャーバージョン」が N から M に変化したときは， 2 つの新しいパッケージ barM と barM-shlibs を作ることになります．
				パッケージ barM-shlibs と barN-shlibs に重複するファイルがあってはいけません．
				これは，多くのユーザにとって両方を同時にインストールする必要があるからです．
				パッケージ barM には以下の依存性情報を指定しなければいけません．
			</p>
<codeblock>
Conflicts: barN
Replaces: barN
</codeblock>
			<p>
				同様に barN の方も次の依存性情報を含むように改訂しなければいけません．
			</p>
<codeblock>
Conflicts: barM
Replaces: barM
</codeblock>
			<p>
				これにより，問題の共有ライブラリの片方のバージョンに依存する他の様々なパッケージがビルドされるときに
				barN と barM が入れ替わり入ってくるのを目にするでしょうが，
				barN-shlibs と barM-shlibs はいつまでもインストールしたままでいられます．
			</p>
			<p>
				<em>既存の Fink パッケージをアップグレードする方法:</em>
			</p>
			<p>
				共有または静的ライブラリをインストールする既存のFinkパッケージについては，
				アップグレードの最良の方法は，問題のパッケージ foo の新しい「バージョン」を作り，
				上のポリシーを満たす新しいパッケージ foo-shlibs を付属させることです．
				共有ライブラリ (または foo-shlibs に含まれる任意のファイル) が以前からインストールされていたら，
				それらの新パッケージで次のように指定します．
			</p>
<codeblock>
Replaces: foo (&lt;&lt; 同等な.旧式パッケージの.バージョン)
</codeblock>
			<p>
				これはアップグレードをユーザに意識させないためです．
				(&quot;Conflicts: foo&quot; ではアップグレードが阻害されるので，<em>使用しないで下さい</em>．)
			</p>
			<p>
				アップグレード後，&quot;Depends: foo&quot; となっているパッケージは普通に機能し続けます．
				しかし，そのようなFinkパッケージのメンテナ全てに連絡し，
				できる限り早くそれらのパッケージで &quot;Depends: foo-shlibs, BuildDepends: foo&quot; とするよう要請しなければいけません．
				メンテナ全員がその措置を終えるまで，
				新しい「メジャーバージョン」の共有ライブラリを提供する新パッケージ fooM と fooM-shlibs を作ることはできません．
			</p>
			<p>
				既存のパッケージで， install_name の名称や，共有ライブラリの名称やシンボリックリンクの名称を正しく使っていない場合，
				注意してケースバイケースで対処することになります．
				パッケージを新ポリシーに従ってアップグレードする方法を決定することが困難であれば，メーリングリスト fink-devel で議論して下さい．
			</p>
			<p>
				<em>実行可能プログラムとライブラリの両方を含むパッケージ:</em>
			</p>
			<p>
				upstream パッケージが実行可能プログラムとライブラリの両方を含む場合，
				Fink パッケージを作成する際にいくつかの注意が必要です．
				唯一の実行可能プログラムが (恐らくビルド時のみに使われ，普段は使われない) foo-config のようなものという場合もあります．
				その場合，実行可能プログラムはヘッダファイルと共にパッケージ <code>foo</code> に入れて構いません．
			</p>
			<p>
				そうでない場合，実行可能プログラムは実行時に他の Fink パッケージから必要とされることになりますが，
				それらは <code>foo-bin</code> などの名前の個別の Fink パッケージに split off しなければいけません．
				パッケージ <code>foo-bin</code> はパッケージ <code>foo-shlibs</code> に依存しなければいけません．
				他パッケージのメンテナは，次のようにすることで
			</p>
<codeblock>
Depends: foo-bin
BuildDepends: foo
</codeblock>
			<p>
				明示せずに <code>foo-shlibs</code> を処理します．
			</p>
			<p>
				しかしこの場合，アップグレードは問題を起こします．
				ユーザは <code>foo-bin</code> をインストールするよう指示されないからです．
				この問題の回避のため，パッケージ <code>foo</code> に依存している全てのパッケージのメンテナがパッケージを上記のように改訂するまで，
				<code>foo</code> で次のようにして構いません．
			</p>
<codeblock>
Depends: foo-shlibs (= 正確な.バージョン), foo-bin
</codeblock>
			<p>
				こうすると， <code>foo</code> に依存する他のパッケージのメンテナが改訂を済ませるまで，
				ユーザのシステムでは大抵 <code>foo-bin</code> のインストールが要求されます．
			</p>
		</section>
		<section name="perlmods">
			<title>Perl モジュール</title>
			<p>
				2003 年 5 月以来， Fink には Perl モジュールに対する新しいポリシーがあります．
				これは 2004 年 4 月に見直されました．
			</p>
			<p>
				伝統的に，perl モジュールの Fink パッケージには <code>-pm</code> が後置され，
				ディレクティブ <code>Type: perl</code> を使ってビルドされていました．
				このディレクティブは Perl モジュールのファイルを
				<filename>/sw/lib/perl5</filename> 及び/または <filename>/sw/lib/perl5/darwin</filename> に格納していました．
				現在のポリシーでは，それらのディレクトリには，コンパイルに使われる Perl のバージョンに依存しない 
				(また，このバージョン非依存性を欠いた Perl モジュールに依存しない)
				Perl モジュールのみを格納します．
			</p>
			<p>
				バージョンに依存する Perl モジュールはいわゆる XS モジュールであり，
				しばしば純粋な Perl コードの他に C コードからコンパイルされたファイルを含みます．
				このことを区別する方法はいくつもありますが，例えば拡張子 <code>.bundle</code> を持つファイルがあるかどうか調べる方法があります．
			</p>
			<p>
				Perl のバージョンに依存する Perl モジュールは該当バージョンの付いた Perl の実行可能プログラム (perl5.6.0 など)
				を使ってビルドされなければいけません．
				また，モジュールの含むファイルは，標準の Perl のディレクトリ内の，バージョンの付いたサブディレクトリ
				(<filename>/sw/lib/perl5/5.6.0</filename> や <filename>/sw/lib/perl5/5.6.0/darwin</filename> など) に格納しなければいけません．
				命名規約により，バージョン 5.6.0 に依存する Perl モジュールに <code>-pm560</code> を後置します．
				格納場所と命名方法に関する同様の規約が他のバージョンの Perl に対しても有効で，
				perl 5.6.1 (10.2 ツリー) と perl 5.8.0， perl 5.8.1， perl 5.8.4 (間もなく) でもそのように対応されます．
			</p>
			<p>
				ディレクティブ <code>Type: perl 5.6.0</code> は自動的にバージョンの付いた Perl の実行可能ファイルを使い，
				できたファイルを適切なサブディレクトリに格納します．
				(このディレクティブは Fink 0.13.0 で導入されました．)
			</p>
			<p>
				<code>-pm</code> の付くパッケージも作成できます．
				これは本質的には「バンドル」パッケージで， <code>-pm560</code> 
				などの付く同等なパッケージなどをロードします．
				2004 年 4 月より，この方式は順次廃止されていきます
				(bootstrap に必要な <code>storable-pm</code> は例外です)．
			</p>
			<p>
				fink 0.20.2 の時点で， system-perl バーチャルパッケージは，
				システムに 5.8.0 以降の Perl がある場合，自動的に Perl モジュールを提供します．
				system-perl-5.8.1-1 の場合，
				<em>attribute-handlers-pm581, cgi-pm581, digest-md5-pm581, file-spec-pm581,
			 file-temp-pm581, filter-simple-pm581, filter-util-pm581, getopt-long-pm581,
			 i18n-langtags-pm581, libnet-pm581, locale-maketext-pm581, memoize-pm581,
			 mime-base64-pm581, scalar-list-utils-pm581, test-harness-pm581,
			 test-simple-pm581, time-hires-pm581.</em>
				です．
				(この一覧は 0.20.1 から若干変更されています．
				パッケージメンテナは正しい一覧を使用しているか必ず確認してください．)
			</p>
			<p>
				Fink 0.13.0 から利用可能になったコマンド <code>fink validate</code> を .deb ファイルに適用すると，
				その Fink パッケージが XS モジュールで，バージョンの付かないディレクトリにインストールされるかチェックし，そうなら警告を発します．
			</p>
		</section>
		<section name="emacs">
			<title>Emacs ポリシー</title>
			<p>
				Fink プロジェクトでは Emacs について Debian プロジェクトのポリシーに従うことに決定しましたが，小さな違いもあります．
				(Debian プロジェクトのポリシーについては
				<link url="http://www.debian.org/doc/packaging-manuals/debian-emacs-policy">
					http://www.debian.org/doc/packaging-manuals/debian-emacs-policy
				</link>
				を参照)
				Fink ポリシーとの違いは 2 点です．
				まず，このポリシーは Fink では現在のところパッケージ emacs20 と emacs21 にのみ適用され，パッケージ xemacs には適用されません．
				(この点は将来変わるかも知れません．)
				次に Debian のポリシーと異なり， Fink パッケージはどれもファイルを直接
				<filename>/sw/share/emacs/site-lisp</filename> にインストールして構いません．
			</p>
		</section>
	</chapter>
	<chapter filename="fslayout">
		<title>ファイルシステムのレイアウト</title>
		<shorttitle>ファイルシステム</shorttitle>
		<preface>
			<p>
				以下はファイルシステムのレイアウトのガイドラインで， Fink のパッケージングポリシーの一部です．
			</p>
		</preface>
		<section name="fhs">
			<title>ファイルシステム構造標準 (Filesystem Hierarchy Standard)</title>
			<p>
				Fink は
				<link url="http://www.pathname.com/fhs/">
					ファイルシステム構造標準 (Filesystem Hierarchy Standard, 略して FHS )
				</link>
				の精神に従います．
				しかし従えるのは飽くまでも精神のみです．
				それは FHS が <filename>/</filename> 以下と <filename>/</filename> 以下の階層を管理できるシステムベンダ向けに作られたからです．
				Fink はインストールディレクトリ (別名「プリフィクス」) 以下のみを管理するアドオン・ディストリビューションです．
				以降の例ではデフォルトの「プリフィクス」 <filename>/sw</filename> を使います．
			</p>
		</section>
		<section name="dirs">
			<title>ディレクトリ</title>
			<p>
				ファイルは以下のサブディレクトリに保存します:
			</p>
			<itemtable>
				<item>
					<itemt>
						<filename>/sw/bin</filename>
					</itemt>
					<itemd>
						<p>
							一般的な実行可能プログラム用．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/sbin</filename>
					</itemt>
					<itemd>
						<p>
							管理者のみが使うことを意図した実行可能プログラム用．
							バックグラウンドで動くデーモンもここに入る．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/include</filename>
					</itemt>
					<itemd>
						<p>
							C と C++ のヘッダファイル用．
							必要に応じてサブディレクトリを作成してよい．
							標準の C ヘッダファイルと混同しそうなヘッダファイルをインストールする場合は<em>必ず</em>サブディレクトリに入れること．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/lib</filename>
					</itemt>
					<itemd>
						<p>
							アーキテクチャ依存のデータファイルやライブラリ用．
							静的および共有ライブラリは，避ける理由が特にない限り <filename>/sw/lib</filename> 直下に置きます．
							ユーザが直接起動することのない実行可能プログラム
							(普通なら <filename>libexec</filename> 下に置かれるはずのもの) もここに置きます．
						</p>
						<p>
							パッケージは，固有のデータやロード可能モジュールを保存するサブディレクトリを自由に作成できます．
							必ず互換性を考慮したディレクトリ名を使って下さい．
							賢明な方法は，そのサブディレクトリの名前にパッケージの「メジャーバージョン」を含めたり，
							「メジャーバージョン」をディレクトリ名にしたさらに深い階層を作ることです
							(<filename>/sw/lib/perl5</filename> や <filename>/sw/lib/apache/1.3</filename> など)．
							ディレクトリにホストの種類を使うときには注意が必要です．
							<code>powerpc-apple-darwin1.3.3</code> は，互換性の観点から問題があります．
							<code>powerpc-apple-darwin1.3</code> または単に <code>powerpc-apple-darwin</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share</filename>
					</itemt>
					<itemd>
						<p>
							アーキテクチャに依存しないデータファイル用で， <filename>/sw/lib</filename> と同じルールが当てはまります．
							よく使われるサブディレクトリについては後述します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/man</filename>
					</itemt>
					<itemd>
						<p>
							man ページ用．
							この中は man のセクションに従って分類されます．
							<filename>/sw/bin</filename> と <filename>/sw/sbin</filename> の中の全てのプログラムには，
							対応した man ページがここになければいけません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/info</filename>
					</itemt>
					<itemd>
						<p>
							Texinfo ソースから生成される Info 形式のドキュメント用．
							索引ファイル <code>dir</code> のメンテナンスは
							Debian 版 <code>install-info</code> (パッケージ <code>dpkg</code> の一部) が自動的に行う．
							パッケージ記述のフィールド <code>InfoDocs</code> を使って，
							パッケージスクリプト <code>PostInst</code> 及び <code>PreRm</code> で使うための適切なコードを自動生成する．
							Fink は，それぞれのパッケージが勝手に <code>dir</code> ファイルを作成しないことを保証する．
							サブディレクトリはなし．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/doc</filename>
					</itemt>
					<itemd>
						<p>
							man でも Info でもないドキュメント用．
							README, LICENSE, COPYING はここに保存する．
							全てのパッケージは，ここに各「パッケージ名」に対応したサブディレクトリを作らなければいけない．
							名前には (「パッケージ名」そのものの一部でない限り) 「バージョン」を含めてはいけない．
							単に <code>%n</code> を使うとよいでしょう．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/share/locale</filename>
					</itemt>
					<itemd>
						<p>
							国際化で使うメッセージカタログ用．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/var</filename>
					</itemt>
					<itemd>
						<p>
							ディレクトリ <filename>var</filename> には変化し得るデータを保存する．
							(スプールディレクトリ，ロックファイル，状態のデータベース，ゲームのハイスコアやログファイルなど)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/etc</filename>
					</itemt>
					<itemd>
						<p>
							設定ファイル用．
							複数のファイルを使用するパッケージは，ここにサブディレクトリを作らなければいけない．
							区別のため，そのサブディレクトリにはパッケージまたはその中のプログラムの名前を付けなければいけない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>
						<filename>/sw/src</filename>
					</itemt>
					<itemd>
						<p>
							ソースコードを保存，ビルドするディレクトリ．
							パッケージはここに何もインストールしてはいけない．
						</p>
					</itemd>
				</item>
			</itemtable>
		</section>
		<section name="avoid">
			<title>避けるべきこと</title>
			<p>
				<filename>/sw</filename> 下には，上述のもの以外ディレクトリを作ってはいけません．
				特に以下のディレクトリを作らないこと:
				<filename>/sw/man</filename>, <filename>/sw/info</filename>, <filename>/sw/doc</filename>,
				<filename>/sw/libexec</filename>, <filename>/sw/lib/locale</filename>
			</p>
		</section>
	</chapter>
	<chapter filename="reference">
		<title>リファレンスマニュアル</title>
		<shorttitle>リファレンス</shorttitle>
		<section name="build">
			<title>ビルドプロセス</title>
			<p>
				各フィールドの意味を理解するには， Fink のビルドプロセスに関する知識がある程度必要です．
				このプロセスは 5 段階になっていて，それぞれ解凍段階，パッチ段階，コンパイル段階，インストール段階，ビルド段階 と呼ばれます．
				下記の例では <filename>/sw</filename> にパッケージ gimp-1.2.1-1 をインストールするものとします．
			</p>
			<p>
				<em>解凍段階</em>では，ディレクトリ <filename>/sw/src/gimp-1.2.1-1</filename> が作成されてソースの tar ボールがそこに解凍されます．
				大抵，解凍によりソースを含むディレクトリ <filename>gimp-1.2.1</filename> が作られます．
				これ以降のステップはすべてこの中 (すなわち <filename>/sw/src/gimp-1.2.1-1/gimp-1.2.1</filename>) で行われます．
				詳細はフィールド SourceDirectory, NoSourceDirectory や Source<em>N</em>ExtractDir (Nは数字) で変更できます．
			</p>
			<p>
				<em>パッチ段階</em>では Darwin でビルドするためのパッチがソースに当てられます．
				フィールド UpdateConfigGuess, UpdateLibtool, Patch や PatchScript で指定されたアクションを，この順で実行します．
			</p>
			<p>
				<em>コンパイル段階</em>ではソースの configure とコンパイルが行われます．
				普通はスクリプト <code>configure</code> を適切な引数で起動し，コマンド <code>make</code> を実行することになります．
				詳細はフィールド CompileScript を参照して下さい．
			</p>
			<p>
				<em>インストール段階</em>では，パッケージは仮ディレクトリ
				<filename>/sw/src/root-gimp-1.2.1-1</filename> (%d と同じ) にインストールされます
				(&quot;root-&quot; が付いていることに注意)．
				ディレクトリ <filename>/sw</filename> にインストールされる予定のファイルは全て，
				<filename>/sw/src/root-gimp-1.2.1-1/sw</filename> (%i すなわち %d%p に同じ) にインストールされます．
				詳細はフィールド InstallScript を参照して下さい．
			</p>
			<p>
				(<em>Fink 0.9.9 で導入:</em>
				フィールド <code>SplitOff</code> を用いると，単一のパッケージ記述から複数のパッケージを生成できます．
				インストール段階の最後のあたりでパッケージそれぞれに対して個別のインストールディレクトリが作られ，
				ファイルが適当なディレクトリに振り分けられます．)
			</p>
			<p>
				<em>ビルド段階</em>では，仮ディレクトリからバイナリパッケージ (.deb ファイル) が作られます．
				この段階を直接制御することはできません．
				代わりに，パッケージ記述からの様々な情報を使って dpkg 用の <filename>control</filename> ファイルが作成できます．
			</p>
		</section>
		<section name="fields">
			<title>フィールド</title>
			<p>
				フィールドを分類して解説します．
				以下の一覧は完全ではありません．
				<code>:-)</code>
			</p>
			<p>
				<em>初期データ関連</em>
			</p>
			<itemtable>
				<item>
					<itemt>Package</itemt>
					<itemd>
						<p>
							「パッケージ名」．
							値には英小文字，数字及び ドット (.), プラス (+), ハイフン (-) を使うことができます．
							下線 (_) と英大文字は使えません．
							必須フィールド．
						</p>
						<p>
							このフィールドで行われるパーセント展開は %N, %{Ni}, %type_raw[] と %type_pkg[] のみです．
						</p>
						<p>
							Fink のパッケージングポリシーでは，
							どのパッケージも常に同じオプションを有効にしてコンパイルされるようにします．
							あるパッケージに複数の変種を設ける場合は (フィールド <code>Type</code> の説明を参照)，
							変種を区別する情報をフィールド <code>Package</code> に含めなければいけません
							(パーセント展開 %type_pkg[] の説明を参照)．
							これにより，各変種に固有の (どのオプションが有効かが分かる) 「パッケージ名」が与えられます．
							フィールド <code>Package</code> 内でパーセント展開 %type_pkg[] および %type_raw[] を使うことは最近導入されたばかりで，
							古い Fink とは非互換であるため，注意が必要です．
							そのため，そのようなパッケージ記述はフィールド <code>InfoN</code> (ただし N&gt;=2) 内に埋め込むようにします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Version</itemt>
					<itemd>
						<p>
							upstream のバージョン．
							値にはフィールド Package と同じ制限がある．
							必須フィールド．
						</p>
						<p>
							プログラムによっては被標準的なバージョン番号の付け方をしていて，ソートや当フィールドで認められていない字を使っている場合があります．
							このような状況では，上流のバージョンを適切にソートされるものに変えます．
							バージョン文字列のソートのされ方がわからない場合，<code>dpkg</code> コマンドをシェルで入力します．例えば，
						</p>
<codeblock> 
 dpkg --compare-versions 1.2.1 lt 1.3 &amp;&amp; echo &quot;true&quot;
</codeblock>
						<p>
							これは &quot;1.2.1&quot; の方が &quot;1.3&quot; より小さいため &quot;true&quot; を出力します．
							詳細は <code>dpkg</code> man ページを参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Revision</itemt>
					<itemd>
						<p>
							Fink パッケージとしてのリビジョン．
							upstream のバージョンが同じパッケージのパッケージ記述を書き換えたら，ここを 1 ずつ増やします．
							最初は 1 で始まます．
							必須フィールド．
						</p>
						<p>
							Fink のポリシーでは，パッケージのバイナリ (コンパイル済み) 形式 (<filename>.deb</filename> ファイル)が変わる<em>いかなる</em>場合でも，<code>Revision</code> をあげなければ<em>なりません</em>．
							例えば，<code>Depends</code> や他のパッケージ一覧フィールド， Splitoff パッケージの追加・削除・名称変更， Splitoff パッケージ間でのファイルの移動など．
							パッケージのツリーを統合 (例えば 10.2 から 10.3) する場合，新しい方のツリーでは <code>Revision</code> を 10 あげて古い方のツリーでのパッケージの更新に対応できるようにします．
 						</p>
					</itemd>
				</item>
				<item>
					<itemt>Epoch</itemt>
					<itemd>
						<p>
							<em>Fink 0.12.0 で導入:</em>
							パッケージの「エポック」を指定します (指定されていない場合は 0 と見なされる)．
							詳細は
							<link url="http://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version">Debian Policy Manual</link>
							を参照．
							省略可能フィールド．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Description</itemt>
					<itemd>
						<p>
							パッケージの短い説明．(それが何であるか)
							一覧表示に使われる1行紹介文なので，簡潔かつ分かり易く．
							(半角) 45文字以下が望ましい．
							60文字を超えないこと．
							このフィールドは，「パッケージ名」と必ず一緒に表示されるので，「パッケージ名」を繰りかえす必要はありません．
							必須フィールド．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Type</itemt>
					<itemd>
						<p>
							値が <code>bundle</code> の場合:
							バンドルパッケージは関連するパッケージをひとまとめにするために使われます．
							各パッケージには，依存関係はありえますが，ソースコードにも，インストールされるファイルにも関連はありません．
							フィールド Source, PatchScript, CompileScript, InstallScript とそれらの関連フィールドは，
							バンドルパッケージでは無視されます．
						</p>
						<p>
							値が <code>nosource</code> の場合:
							これは <code>bundle</code> と非常に似ています．
							これはソースの tar ボールが存在しないことを示します．
							よって何も取り寄せられず，解凍段階では空ディレクトリが作られます．
							しかしパッチ，コンパイル，インストールの各段階は通常通り実行されます．
							このようにして全てのソースコードをパッチと共に配布したり，
							または InstallScript を使ってディレクトリを作るだけのことができます．
							Fink 0.18.0 以降では <code>Source: none</code> と設定しても同じ挙動が実現できます．
							これにより，フィールド <code>Type</code> を他の目的に使えます (<code>Type: perl</code> など)．
						</p>
						<p>
							値が <code>perl</code> の場合 (Fink 0.9.5 以降):
							コンパイル及びインストール段階のスクリプトのデフォルト値が変わります．
							Fink 0.13.0 からは，この値の変種として <code>perl $version</code> が使えます．
							ここで &quot;$version&quot; は perl の特定のバージョンで，3つの数をピリオドで区切ったもの
							(<code>perl 5.6.0</code> など)．
						</p>
						<p>
							CVS 版の Fink 0.19.2 以降では，
							「プログラミング言語」または「プログラミング言語-バージョン」という記法は一般化され，
							メンテナの定義した任意のタイプとそれに関連するサブタイプが指定できるようになり，
							あるパッケージに複数のタイプを指定できるようになりました．
							タイプとサブタイプにはそれぞれ空白以外からなる任意の文字列が使えます．
							(しかし括弧，大括弧，カンマ，パーセント記号を使ってはいけません．)
							ここではパーセント展開は行われません．
							また，タイプの値は小文字に変換されます(が，サブタイプは変換されません)．
							複数のタイプを指定するにはカンマ区切りのリストを使います
							(各タイプに空白区切りのサブタイプリストが伴うことができます)．
							
						</p>
						<p>
							これに加えて「変種」という概念があります．
							単一のパッケージ記述が，有効なコンパイルオプションだけが違う複数のパッケージを生成するとき，
							これらのパッケージは「変種」になります．
							このプロセスの鍵はサブタイプリストの利用です．
							単一の文字列ではなく，文字列の空白区切りリストを括弧で括ったものを使います．
							Fink はリスト内のサブタイプ毎にパッケージ記述をコピーし，各コピー内ではリストを単一のサブタイプに置き換えます．
							例:
						</p>
						<codeblock>Type: perl (5.6.0 5.8.1)</codeblock>
						<p>
							これは 2 つのパッケージ記述を生成します．
							片方は <code>Type: perl 5.6.0</code> と，もう片方は <code>Type: perl 5.8.1</code> と同等になります．
							特殊なサブタイプリスト &quot;(boolean)&quot; が意味するのは，(サブでない) タイプ自身とドット '.' から成るリストです．
							つまり以下の 2 つは同一です．
						</p>
<codeblock>
Type: -x11 (boolean)
Type: -x11 (-x11 .)
</codeblock>
						<p>
							サブタイプリストの展開とそれに伴うパッケージ変種の作成は，再帰的に行われます．
							またサブタイプリストを持つタイプが複数ある場合は，あり得る組み合わせが全て生成されます．
						</p>
<codeblock>Type: -ssl (boolean), perl (5.6.0 5.8.1)</codeblock>
						<p>
							Type 以外のフィールドから特定の変種のサブタイプを得るには，疑似ハッシュ %type_raw[] および %type_pkg[] を使います．
							以下にパッケージ記述の例の一部を示します．
						</p>
<codeblock>
Info2: &lt;&lt;
Package: foo-pm%type_pkg[perl]
Type: perl (5.6.0 5.8.1)
Depends: perl%type_pkg[perl]-core
 &lt;&lt;
</codeblock>
<codeblock>
Info2: &lt;&lt;
Package: bar%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_raw[-x11] = -x11) x11
CompileScript:  &lt;&lt;
  #!/bin/bash -ev
  if [&quot;%type_raw[-x11]&quot; == &quot;-x11&quot;]; then
    ./configure %c --with-x11
  else
    ./configure %c --without-x11
  fi
  make
&lt;&lt;
&lt;&lt;
</codeblock>
					</itemd>
				</item>

				<item>
					<itemt>License</itemt>
					<itemd>
						<p>
							パッケージ配布の際にパッケージの従うライセンスの性質を表す．
							値は <xref chapter="policy" section="licenses">パッケージのライセンス</xref> で示した選択肢から選ばなければいけない．
							それに加え，パッケージが実際にパッケージング・ポリシーに従うとき，
							すなわちライセンスのコピーがパッケージの doc ディレクトリにインストールされるときでなければ
							このフィールドを指定してはいけない．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>Maintainer</itemt>
					<itemd>
						<p>
							パッケージに責任を負っている人物の名前とメールアドレス．
							必須フィールド．
							値は以下の形式で，名前とメールアドレスはそれぞれ一つだけとする．
						</p>
<codeblock>名前 名字 &lt;アカウント@ドメイン.example.com&gt;</codeblock>
						<p>
							訳注: 名前はローマ字表記です．
							順序は，特に指定はありませんが， YAMADA Taro などとするのが一般的です．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InfoN</itemt>
					<itemd>
						<p>
							このフィールドにより Fink はパッケージ記述の構文の非互換な変更に対処できる．
							任意のバージョンの Fink には扱える &quot;N&quot; (整数) の最大値が設定されている．
							それより大きいNを持つフィールド InfoN はいずれも無視される．
							だからこの機構の利用は必要最低限に止めなければいけない．
							そうしないと古いバージョンの Fink のユーザが必然性なしに仲間外れにされてしまう．
							他のフィールドの解説には，どのバージョンの Fink ではどのNの InfoN を使わなければいけないか記されているだろう．
							この機構を使うには，パッケージ記述全体をフィールド InfoN の値に埋め込む．
							複数行に渡る値の記述方法については，前述の「ファイル形式」を参照．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>依存性関連</em>
			</p>
			<itemtable>
				<item>
					<itemt>Depends</itemt>
					<itemd>
						<p>
							そのパッケージがビルドできるようになる前にインストールされていなければいけないパッケージのリスト．
							このフィールドではパーセント展開が行われる
							(「依存性関連」の他のフィールドでも同様:
							BuildDepends, Provides, Conflicts, Replaces, Recommends, Suggests および Enhances)
							普通，値は「パッケージ名」の単なるカンマ区切りリストだが，
							現在の Fink は (dpkgと同じ形式の) 「代替パッケージ節」と「バージョン節」に対応している．
							それらを全て盛りこんだ例:
						</p>
<codeblock>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</codeblock>
						<p>
							本当の意味で「省略可能」な依存性を表現する方法がないことに注意．
							あるパッケージが別のパッケージがあってもなくても動作するとき，
							もう片方のパッケージが (存在するときであっても) 確かに使われていないか確かめるか，
							またはフィールド Depends に加えるかのどちらかを行うこと．
							ユーザにどちらの使い方をも提供したいときは，2 つの別々のパッケージ (例えば wget と wget-ssl) を作る．
						</p>
						<p>
							0.18.2 CVS版以降の Fink では，条件付き依存性を記述できる．
							それを指定するには「パッケージ名」の前に <code>(string1 op string2)</code> を付ける．
							パーセント記法が普通に展開され，その後オペレータ <code>op</code> によって2つの文字列が比較される．
							<code>op</code> には以下のものが使える: &lt;&lt;, &lt;=, =, !=, &gt;&gt;, &gt;=．
							その直後に「パッケージ名」の記されたパッケージには，比較が真を返したときのみ依存性があると判断される．
						</p>
						<p>
							この機能は，複数の似通ったパッケージを管理する際に手間を省くためにも使える．
							例えば elinks と elinks-ssl は次のように列挙できるが，
						</p>
<codeblock>Depends: (%n = elinks-ssl) openssl097-shlibs, expat-shlibs</codeblock>
						<p>
							これは elinks の方で
						</p>
<codeblock>Depends: expat-shlibs</codeblock>
						<p>
							とし， elinks-ssl の方で
						</p>
<codeblock>Depends: openssl097-shlibs, expat-shlibs</codeblock>
						<p>
							とすることと同じである．
						</p>
						<p>
							この他の文法として， <code>(string)</code> 指定をすることもできる．
							<code>string</code> が null でない場合， &quot;true&quot; を返す．
						</p>
<codeblock>
Package: nethack%type_pkg[-x11]
Type: -x11 (boolean)
Depends: (%type_pkg[-x11]) x11
</codeblock>
						<p>
							これにより，nethack-x11 は x11 パッケージに依存するが， nethack は依存しない．
						</p>
						<p>
							Depends/BuildDepends を，複数のメジャーバージョンを持つ共有ライブラリパッケージに使用する場合，下記のようにしては<em>いけない</em>:
 </p>
<codeblock>
  Package: foo
  Depends: id3lib3.7-shlibs | id3lib4-shlibs
  BuildDepends: id3lib3.7-dev | id3lib4-dev
</codeblock>
						<p>
							どちらのライブラリとも動作するパッケージであっても，どちらか一つ (適切に動作する高い方のバージョンが望ましい) のパッケージを選び，パッケージ内で統一する． 
						</p>
						<p>
							<xref chapter="policy" section="sharedlibs">共有ライブラリポリシー</xref>で説明したように， -dev パッケージがインストールされるのは一つだけである．
							各パッケージは -shlibs パッケージに関連づけられた異なるファイル名へ同じ名前のシンボリックリンクを作成することがある．
							しかし，パッケージ foo をコンパイルする際には実際の (-shlibs パッケージ内の) ファイル名の方が foo バイナリにハードコードされる．
							パッケージは，コンパイル時にインストールされた -dev に合った -shlibs パッケージを必要とする．
							このため， <code>Depends</code> でどちらも満たすようにはできないのである．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>BuildDepends</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.0 で導入:</em>
							ビルド時のみに適用される依存性のリスト．
							ビルド時には必要だが，実行時には使われないツール (flexなど) を示すのに使う．
							書式は Depends と同じ．
						</p>
					</itemd>
				</item>

				<item>
					<itemt>Provides</itemt>
					<itemd>
						<p>
							そのパッケージが「提供」すると考えられる「パッケージ名」のカンマ区切りのリスト．
							パッケージ pine で <code>Provides: mailer</code> となっている場合，
							pine がインストールされると mailer についての全ての依存性は解決したものとされる．
							普通，そのようなパッケージは pine のフィールド Conflicts や Replaces にも入れるとよい．
						</p>

						<p>
							Provides 項目には，バージョン番号に関連した情報はない．
							親パッケージから取得することも，Provides フィールド自体にはバージョン番号を特定するような仕組みなどもない．
							バージョンを指定する依存性があっても，Provides を持つパッケージによって満たすことはできない．
							結果として，同一の代理パッケージを提供するバリアントが多数あるのは危険である．
							これによってバージョンを指定した依存性ができなくなるためである．
							例えば， foo-gnome と foo-nogome が &quot;Provides: foo&quot; を提供する場合，&quot;Depends: foo (> 1.1)&quot; は動作しない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Conflicts</itemt>
					<itemd>
						<p>
							そのパッケージと同時にインストールしてはいけない「パッケージ名」のカンマ区切りのリスト．
							バーチャルパッケージでは，そのパッケージが提供する「パッケージ名」をここに指定してもよい．
							それらは適切に扱われる．
							このフィールドはフィールド Depends のようにバージョン付きの依存性情報にも対応しているが，
							代替パッケージには対応していない (意味をなさない)．
							あるパッケージがそれ自身のパッケージ記述の Conflicts に入っていると， (暗黙のうちに) そこから取り除かれる．
							(Fink のバージョン 0.18.2 CVS 以降で導入)
						</p>
						<p>
							<em>注記:</em> Fink自身はこのフィールドを無視する．
							しかしこれは dpkg に渡され，そこで適切に扱われる．
							要するにこのフィールドが影響するのはビルド時でなく実行時だ．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Replaces</itemt>
					<itemd>
						<p>
							Conflicts と共に使われる．
							そのパッケ−ジが，衝突するパッケ−ジの機能の代わりになるだけでなく，共通するファイルを持つときに使われる．
							このフィールドがないと，dpkg はパッケージのインストール時にエラーを出すかも知れない．
							それはいくつかのファイルが依然として元あった方のパッケージに属しているからだ．
							それら 2 つのパッケージが純粋な意味で互いに代替物であり，どちらか好きな方を選べるようなときはこれを使うとよい．
							あるパッケージがそれ自身のパッケージ記述の Conflicts に入っていると， (暗黙のうちに) そこから取り除かれる．
							(Fink のバージョン 0.18.2 CVS 以降で導入)
						</p>
						<p>
							<em>注記:</em> Fink自身はこのフィールドを無視する．
							しかしこれは dpkg に渡され，そこで適切に扱われる．
							要するにこのフィールドが影響するのはビルド時でなく実行時だ．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Recommends, Suggests, Enhances</itemt>
					<itemd>
						<p>
							これらのフィールドはパッケージ同士の付加的な関係情報を指定する．
							書式は他の依存情報フィールドと同じ．
							これら 3 つの情報は dpkg や apt-get によるインストール過程そのものには影響しないが，
							dselect や他のフロントエンドが，微妙な選択を行うユーザの判断を助けるのに使われる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Pre-Depends</itemt>
					<itemd>
						<p>
							フィールド Depends の特別なもので，意味の上で厳密さが必要になる．
							このフィールドを使うのは，開発者用メーリングリストで議論を行い，確かに使う必要があるとの同意が得られた場合に限る．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Essential</itemt>
					<itemd>
						<p>
							必須パッケージを表す真偽値フィールド．
							必須パッケージはブートストラップ・プロセスの一環としてインストールされる．
							必須パッケージでないパッケージは必須パッケージに暗黙のうちに依存して構わない．
							dpkg は，このフィールドの指示に優先する特別なフラグを使わない限り，必須パッケージをシステムから取り除くことを拒む．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>BuildDependsOnly</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							真偽値フィールド．
							他パッケージはこのパッケージを BuildDepend に入れてもよいが， Depend に入れてはいけないことを示します．
							通常の真偽値とは異なり，<code>BuildDependsOnly</code> は３つの状態があります．
							未定義 (何も指定しない) の場合と明示的に False を指定するのとは異なります．
							詳細は<xref chapter="policy" section="sharedlibs">共有ライブラリポリシー</xref>を参照してください．
						</p>
						<p>
							fink 0.20.5 より，このフィールドが設定されているか，設定されている場合その値が，
							パッケージがビルドされる際には .deb ファイルに記録されます．
							このため， BuildDependsOnly の値を変更したり，追加・削除時には Rivision 番号をあげる必要があります．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>解凍段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>CustomMirror</itemt>
					<itemd>
						<p>
							ミラーサイトのリスト．
							各ミラーサイトは <code>&lt;場所&gt;: &lt;url&gt;</code> という書式に従って 1 行ずつ記述する．
							<em>場所</em> には大陸コード (例えば nam) や国コード (例えば nam-us) など (何でもよい) を使う．
							ミラーサイトはここに記述した順に試される．
							例:
						</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&lt;&lt;</codeblock>
						<p>
							大陸及び国のコードは  <filename>/sw/lib/fink/mirror/_keys</filename> にある．
							これは， fink および fink-mirrors パッケージの一部である．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source</itemt>
					<itemd>
						<p>
							ソースの tar ボールの URL ．
							HTTP または FTP でなければいけないが，Fink はそれを単に wget に渡すだけなので，実際には問題にならない．
							このフィールドは，ミラーサイトを示す特別な記法に対応している．
							すなわち <code>mirror:&lt;ミラー名称&gt;:&lt;相対パス&gt;</code> だ．
							こうすると Fink に <em>ミラー名称</em> として設定された URL を探し，
							その後ろに <em>相対パス</em> を付け加え，それを実際の URL として使う．
							Fink の認識する <em>ミラー名称</em> の一覧は <filename>/sw/lib/fink/mirror/_list</filename>
							(パッケージ fink または fink-mirrors の一部) に記される．
							または <em>ミラー名称</em> に <code>custom</code> と書くことで，
							Fink にフィールド <code>CustomMirror</code> を使わせることもできる．
							URL が wget に渡される前に，パーセント記法の展開が行われる．
							%n は %type_ 系で示される変種データ全てを含む文字列に展開されることに注意．
							ここでは %{ni} を (場合によっては特定の %type_ の展開値と共に) 使うとよい．
						</p>
						<p>
							Fink 0.18.0 以降では <code>Source: none</code> は特殊な意味を持ち，取り寄せるべきソースは存在しないことを表す．
							詳細についてはフィールド Type の説明を参照．
							<code>gnu</code> という値は <code>mirror:gnu:%n/%n-%v.tar.gz</code> の，
							<code>gnome</code> という値は <code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code> の省略形．
							デフォルト値は <code>%n-%v.tar.gz</code>  (すなわちマニュアル・ダウンロード) になっている．
							暗示的に <code>Source</code> を指定するのは廃止予定である (明示的に簡単なファイル名指定/手動ダウンロードするのは可)．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em></itemt>
					<itemd>
						<p>
							パッケージが複数の tar ボールから形成されている場合，それらはこの (省略可能) フィールドで指定する．
							N は 2 から始まる数．
							つまり最初の tar ボール (ある意味「メイン」になるもの) をフィールド <code>Source</code> に，
							2 番目の tar ボールをフィールド <code>Source2</code> に，という風になる．
							値の書式は <code>Source</code> と共通だが，
							<code>gnu</code> や <code>gnome</code> という省略形は展開されない (結局，意味をなさない)．
							バージョン 0.19.2 以降の CVS 版 Fink では， 2 以上の任意の (つまり，必ずしも連続しない) 整数を N に使える．
							しかし，重複はやはり許されない．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SourceDirectory</itemt>
					<itemd>
						<p>
							tar ボールが単一のディレクトリに展開されはするが，
							そのディレクトリ名が tar ボールのファイル名から拡張子を除いたものと異なる場合には，これを設定しなければいけない．
							つまり，普通なら &quot;foo-1.0.tar.gz&quot; という tar ボールは &quot;foo-1.0&quot; というディレクトリを生成する．
							しかし生成されるディレクトリ名がそれと異なる場合，そのディレクトリ名をこのフィールドで指定する．
							パーセント展開が行われる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>NoSourceDirectory</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							tar ボールが単一のディレクトリに展開されないときにこのフィールドを設定する．
							つまり，普通なら &quot;foo-1.0.tar.gz&quot; という tar ボールは &quot;foo-1.0&quot; というディレクトリを生成する．
							しかし tar ボールを展開したときにファイルがカレントディレクトリに撒き散らされる場合は，
							このフィールドを &quot;true&quot; に設定する．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>ExtractDir</itemt>
					<itemd>
						<p>
							普通，補助的な tar ボールは「メイン」の tar ボールと同じディレクトリで展開される．
							それを特定のサブディレクトリ内で展開して欲しいときは，このフィールドでサブディレクトリ名を指定する．
							ご想像の通り， <code>Source2ExtractDir</code> は <code>Source2</code> で指定した tar ボールに対応する．
							用例についてはパッケージ ghostscript, vim や tetex を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SourceRename</itemt>
					<itemd>
						<p>
							このフィールドを使うと，ビルド時にソースの tarball をリネームできる．
							これが便利なのは，例えば，ソースのバージョンがサーバのディレクトリ名には示されているが，
							tar ボールそのものはどのバージョンでも同じ名前のときだ．
							(例えば <filename>http://www.foobar.org/coolapp/1.2.3/source.tar.gz</filename> というとき)
							このことで起きる問題を回避するためには次のようにすればよい．
						</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
						<p>
							この例では，ご想像の通り， tar ボールは <filename>/sw/src/coolapp-1.2.3.tar.gz</filename> として格納されることになる．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>Rename</itemt>
					<itemd>
						<p>
							これはフィールド <code>SourceRename</code> と同じだが，
							<code>Source<em>N</em></code> で指定された N 番目の tar ボールのリネームに使う．
							用例についてはパッケージ context や hyperref を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source-MD5</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドではソースファイルの MD5 チェックサムを指定します．
							Fink はこの情報によりおかしなソースファイル，
							すなわち Fink パッケージの作成者が指定したものではない tar ボールを見分けられます．
							この問題の原因には，以下のようなものがあります:
							tar ボールのダウンロードに失敗した，upstreamのメンテナが知らないうちに tar ボールを更新した，トロイの木馬などの攻撃，など．
						</p>
						<p>
							このフィールドの典型的な用例は次の通り．
						</p>
<codeblock>Source-MD5: 4499443fa1d604243467afe64522abac</codeblock>
						<p>
							チェックサムの算出にはツール <code>md5sum</code> を使います．
							tar ボール <filename>/sw/src/apache_1.3.23.tar.gz</filename> のチェックサムが知りたいときには，
							次のコマンドを実行します (出力も一緒に示した)．
						</p>
<codeblock>fingolfin% md5sum /sw/src/apache_1.3.23.tar.gz
4499443fa1d604243467afe64522abac  /sw/src/apache_1.3.23.tar.gz</codeblock>
						<p>
							左に表示された値がここで必要なものです．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Source<em>N</em>-MD5</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							フィールド <code>Source-MD5</code> と同様ですが，
							フィールド <code>Source<em>N</em></code> に対応する N 番目の tar ボールの MD5 チェックサムを指定します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>TarFilesRename</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドは tar 形式を使うソースファイルにのみ適用されます．
						</p>
						<p>
							このフィールドを使うと，任意のソース tar ボールの中のファイルを， tar ボールの展開中にリネームできます．
							ファイルシステム HFS+ がケースインセンシティブである (大文字と小文字を区別しない) ことを回避するために非常に便利でしょう．
							普通の Mac OS X システムでは，ファイル <filename>install</filename> と <filename>INSTALL</filename> は衝突してしまいます．
							このフィールドを使うと， tar ボールをわざわざ再パッケージしなくとも (以前はこのような場合に行われていた)，
							こういった問題を回避することができます．
						</p>
						<p>
							このフィールドでは，単に，リネームされるファイルのリストを指定します．
							ワイルドカードも使うことができます．
							デフォルトでは，指定されたファイルは，いずれも元の名前に <code>_tmp</code> を後置したファイル名にリネームされます．
							デフォルト値に優先する指定をするには，
							フィールド <code>Files</code> や <code>DocFiles</code> と同様の書式を使います．
							すなわち 元のファイル名，コロン (:)，新ファイル名，という順です．
							例:
						</p>
<codeblock>TarFilesRename: foo bar.* qux:quux
Tar2FilesRename: direcory/INSTALL:directory/INSTALL.txt</codeblock>
					</itemd>
				</item>

				<item>
					<itemt>Tar<em>N</em>FilesRename</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							フィールド <code>TarFilesRename</code> と同様ですが，
							フィールド <code>Source<em>N</em></code> に対応する N 番目の tar ボールに対して機能します．
						</p>
					</itemd>
				</item>
			</itemtable>
			<!-- Patch Phase -->
			<p>
				<em>パッチ段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>UpdateConfigGuess</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，ビルド用ディレクトリ内のファイル config.guess と config.sub が
							Darwin に対応したバージョンに置き換えられます．
							その動作は，パッチ段階の，PatchScript が実行される前に行われます．
							これが必要だと分かっているとき，
							すなわち configure スクリプトが "unknown host" というメッセージで失敗するとき<em>のみ</em>使うこと．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateConfigGuessInDirs</itemt>
					<itemd>
						<p>
							<em>0.9.0 CVS バージョン以降で導入:</em>
							サブディレクトリのリストを指定します．
							これは UpdateConfigGuess と同じことを行いますが，
							ソースツリー中の複数のディレクトリに古い config.guess が入っているパッケージで便利でしょう．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要がありましたが，
							この新フィールドを使えばディレクトリを単に列挙するだけでよくなりました．
							ビルド用ディレクトリ自身のファイルの更新には <code>.</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateLibtool</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，ビルド用ディレクトリ内のファイル ltconfig と ltmain.sh が
							Darwin に対応したバージョンに置き換えられます．
							その動作は，パッチ段階の， PatchScript が実行される前に行われます．
							これが必要だと分かっているとき<em>のみ</em>使うこと．
							libtool 関連のスクリプトをバージョンの合わないものに取り換えると壊れるパッケージもあrimasu
							．
							詳細については<link url="http://fink.sourceforge.net/doc/porting/libtool.php">libtool のページ</link>を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdateLibtoolInDirs</itemt>
					<itemd>
						<p>
							<em>0.9.0 CVS バージョン以降で導入:</em>
							サブディレクトリのリストを指定します．
							これは UpdateLibtool と同じことを行いますが，
							ソースツリー中の複数のディレクトリに古い libtool 1.3.x 系列のスクリプトが入っているパッケージで便利でしょう．
							以前はコピーや移動を行うよう PatchScript に手動で指定する必要がありましたが，
							この新フィールドを使えばディレクトリを単に列挙するだけでよくなりました．
							ビルド用ディレクトリ自身のファイルの更新には <code>.</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>UpdatePoMakefile</itemt>
					<itemd>
						<p>
							真偽値フィールド．
							&quot;true&quot; にすると，サブディレクトリ <filename>po</filename> 内のファイル
							<filename>Makefile.in.in</filename> が，パッチの当たったものと取り換えられます．
							その動作は，パッチ段階の， PatchScript が実行される前に行われます．
						</p>
						<p>
							パッチの当たった <filename>Makefile.in.in</filename> は DESTDIR の指定を優先し，メッセージカタログを，
							<filename>/sw/lib/locale</filename> ではなく，確実に <filename>/sw/share/locale</filename> に格納します．
							このフィールドを利用する前に，入れ換えによってパッケージを破壊していないこと，また入れ換えが本当に必要かどうかを確認すること．
							<code>diff</code> を実行すれば，パッケージ付属のものと Fink 向けのもの
							(<filename>/sw/lib/fink/update</filename> 内にある) との違いが分かります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Patch</itemt>
					<itemd>
						<p>
							<code>patch -p1 &lt;<em>パッチファイル</em></code> として適用されるパッチのファイル名．
							ここにはファイル名のみを指定します．
							適切なパスは自動的に前置されます．
							このフィールドではパーセント展開が行われるので，典型的な値は単に <code>%f.patch</code> または <code>%n.patch</code> となります．
							PatchScript が指定されている場合，パッチはその後に実行されます．
						</p>
						<p>
							%n は %type_ 系で示される変種データ全てを含む文字列に展開されることに注意．
							ここでは %{ni} を (場合によっては特定の %type_ の展開値と共に) 使うとよいでしょう．
							単一のパッチファイルを管理し，
							各変種固有の変更点を <code>PatchScript</code> に記述する方が，
							各変種毎にパッチファイルを作るより手間が少ないでしょう．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>PatchScript</itemt>
					<itemd>
						<p>
							パッチ段階で実行されるコマンドのリスト．
							下記のスクリプトの注意書きを参照してください．
							ここには，パッチを当てるか，またはパッケージに変更を加えるコマンドを指定します．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
							デフォルト値はありません．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>コンパイル段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>Set<em>環境変数名</em></itemt>
					<itemd>
						<p>
							コンパイルおよびインストールの段階の間，環境変数を設定します．
							コンパイラフラグなどを configure スクリプトや Makefile に渡すために使われます．
							現在，対応している変数は次の通り: 
							CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, DYLD_LIBRARY_PATH, JAVA_HOME,
							LD_PREBIND, LD_PREBIND_ALLOW_OVERLAP, LD_FORCE_NO_PREBIND, LD_SEG_ADDR_TABLE,
							LD, LDFLAGS, LIBRARY_PATH, LIBS, MACOSX_DEPLOYMENT_TARGET, MAKE, 
							MFLAGS, MAKEFLAGS.
							指定した値の中では前節で説明したパーセント展開が行われます．
							よく使われる例:
						</p>
<codeblock>SetCPPFLAGS: -no-cpp-precomp</codeblock>
						<p>
							環境変数には，既定値を持つものもあります．
							この場合に値を指定すると，既定値に追加されます．
							既定値を持つ変数とその値は:
						</p>
<codeblock>
CPPFLAGS: -I%p/include
LDFLAGS: -L%p/lib
</codeblock>
						<p>
							fink 0.17.0 からはさらに以下が追加されています:
						</p>
<codeblock>
LD_PREBIND: 1
LD_PREBIND_ALLOW_OVERLAP: 1
LD_SEG_ADDR_TABLE: $basepath/var/lib/fink/prebound/seg_addr_table
</codeblock>
						<p>
							fink 0.24.3 (と 0.23.7) からの 10.3 および 10.4-transitional 用ディストリビューションでは
						</p>
<codeblock>
CXXFLAGS: -fabi-version=1
</codeblock>
						<p>
							10.4 以降のディストリビューションでは
						</p>
<codeblock>
CXXFLAGS: -fabi-version=2
</codeblock>
						<p>
							となります．
							MACOSX_DEPLOYMENT_TARGET は OSX のバージョンを既定値として持ちます．
							これに値を指定することで (値の追加ではなく) 既定値を書き換えることができます．
						</p>

					</itemd>
				</item>
				<item>
					<itemt>NoSet<em>環境変数名</em>
					</itemt>
					<itemd>
						<p>
							真の場合，既定値を持つ変数 (上述の CPPFLAGS, LDFLAGS, CXXFLAGS など) の既定値を使いません．
							例えば，LDFLAGS を unset のままにしたい場合， <code>NoSetLDFLAGS: true</code> とします．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>ConfigureParams</itemt>
					<itemd>
						<p>
							configure スクリプトに渡す付加的なパラメータ．
							(詳細は CompileScript を参照)

							バージョン 0.13.7 以降の Fink では，
							このパラメータは <code>Type: Perl</code> となっている perl モジュールにも使えます．
							その場合，指定した値はデフォルトの文字列 perl Makefile.PL の後ろに追加されます．
						</p>
						<p>
							fink-0.22.0 より，このフィールドは条件をサポートする．
							文法は <code>Depends</code> や他のパッケージ一覧フィールドと同様です．
							条件は，スペースデリミティッドな &quot;word&quot;  の直後に記述します．
							例えば:
						</p>
<codeblock>
Type: -x11 (boolean)
ConfigureParams: --mandir=%p/share/man (%type_pkg[-x11]) --with-x11 --disable-shared
</codeblock>
						<p>
							これは<code>--mandir</code> と <code>--disable-shared</code> フラグを送り， -x11 バリアントの場合のみ <code>--with-x11</code> を送ってください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>GCC</itemt>
					<itemd>
						<p>
							当フィールドは，パッケージ内の C++ コードが使用する GCC-ABI を指定します．
							(このフィールドは，ABI が２度変わり，C++ コードと，それがリンクするライブラリが同じ ABI でなければならないために必要である．)
						</p><p>
							値としては:
							<code>2.95.2</code> (or <code>2.95</code>),
							<code>3.1</code>,
							<code>3.3</code>
							があります．
							最後の値は， gcc 3.1 およびそれ以降の gcc の GCC-ABI です．
						</p><p>
							注記: GCC 値が既定値と異なる場合， (CC や CXX フラグを設定するなど) パッケージ内でコンパイラを指定する必要があります．
							また， (virtual) gcc パッケージへの依存性を指定します．
						</p>
						<p>
							Fink 0.13.8 以降，このフラグが指定されると， gcc のバージョンは <code>gcc_select</code> によって調べられ，
							誤ったバージョンのものが存在すると Fink はエラー終了します．
						</p>
						<p>
							このフィールドは gcc コンパイラ間の移行をメンテナが知ることができるように Fink に加えられた．
							gcc では， C++ コードの関わるライブラリ間で，実行可能・ファイル同士の (バージョン名に反映されない) 非互換が生じることがあります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>CompileScript</itemt>
					<itemd>
						<p>
							コンパイル段階で実行されるコマンドのリスト．
							下記のスクリプトの注意書きを参照してください．
							パッケージの configure およびコンパイルを行うコマンドをここに指定します．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
							通常は以下の通り．
						</p>
<codeblock>./configure %c
make</codeblock>
						<p>
							これは GNU autoconf を利用するパッケージには適切でしょう．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							通常，次のようになります (0.13.4) ．
						</p>
<codeblock>perl Makefile.PL PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5 \
 INSTALLARCHLIB=%p/lib/perl5/darwin \
 INSTALLSITELIB=%p/lib/perl5 \
 INSTALLSITEARCH=%p/lib/perl5/darwin \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
						<p>
							タイプが <code>perl $version</code> となっていて，バージョンが指定されているものでは
							(例えば <code>$version</code> は 5.6.0 とする)，
							デフォルト値は次のようになります．
						</p>
<codeblock>perl$version Makefile.PL \
 PERL=perl$version PREFIX=%p \
 INSTALLPRIVLIB=%p/lib/perl5/$version \
 INSTALLARCHLIB=%p/lib/perl5/$version/$perlarchdir \
 INSTALLSITELIB=%p/lib/perl5/$version \
 INSTALLSITEARCH=%p/lib/perl5/$version/$perlarchdir \
 INSTALLMAN1DIR=%p/share/man/man1 \
 INSTALLMAN3DIR=%p/share/man/man3 \
 INSTALLSITEMAN1DIR=%p/share/man/man1 \
 INSTALLSITEMAN3DIR=%p/share/man/man3 \
 INSTALLBIN=%p/bin \
 INSTALLSITEBIN=%p/bin \
 INSTALLSCRIPT=%p/bin
make
make test</codeblock>
<p>
ここで， <code>$perlarchdir</code> はバージョン 5.8.0 以前では &quot;darwin&quot; であり，
バージョン 5.8.1 以降では &quot;darwin-thread-multi-2level&quot; となります．
</p>
					</itemd>
				</item>
				<item>
					<itemt>NoPerlTests</itemt>
					<itemd>
						<p>
							<em>Fink 0.13.7 以降で導入:</em>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定します．
							&quot;true&quot; にすると， <code>CompileScript</code> のうち <code>make test</code> の部分が，
							その perl モジュールのパッケージでは無視されます．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>インストール段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>UpdatePOD</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.5 で導入:</em>
							真偽値フィールド．
							Perl モジュールのパッケージでのみ指定します．
							&quot;true&quot; にすると， install, postrm および postinst スクリプトに，
							perl パッケージの提供する .pod ファイルを管理するためのコードを追加します．
							これには，中央のファイル <filename>/sw/lib/perl5/darwin/perllocal.pod</filename> に .pod ファイルのデータを追加したり，
							そこから削除することも含まれます．
							(<code>perl $version</code> のように，5.6.0 などの perl の特定のバージョンと共にタイプが指定された場合は，
							それらのスクリプトが扱う中央 .pod ファイルは <filename>/sw/lib/perl5/$version/perllocal.pod</filename> になる．)
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InstallScript</itemt>
					<itemd>
						<p>
							インストール段階におけるコマンドの一覧．
							ここでコマンドを指定することで，必要な全てのファイルを一時 dpkg ディレクトリにコピーします．
							下記の<xref chapter="reference" section="scripts">スクリプトに関する注記</xref>もあわせて参照してください．
							コマンド実行前に，<xref chapter="format" section="percent">パーセント展開</xref>が行われます．
							通常，デフォルトでは:
						</p>
<codeblock>make install prefix=%i</codeblock>
						<p>
							となります．
							このデフォルト値は GNU autoconf を利用するパッケージには適切です．
							Perl タイプ (フィールド Type で指定される) のパッケージのうち perl のバージョン指定がないものでは，
							デフォルト値は次のようになります．
						</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5 \
INSTALLARCHLIB=%i/lib/perl5/darwin \
INSTALLSITELIB=%i/lib/perl5 \
INSTALLSITEARCH=%i/lib/perl5/darwin \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3 \
INSTALLSITEMAN1DIR=%i/share/man/man1 \
INSTALLSITEMAN3DIR=%i/share/man/man3 \
INSTALLBIN=%i/bin \
INSTALLSITEBIN=%i/bin \
INSTALLSCRIPT=%i/bin
</codeblock>
						<p>
							タイプが <code>perl $version</code> となっていて，バージョンが指定されているものでは 
							(例えば <code>$version</code> は 5.6.0 とする)，
							デフォルト値は次のようになります．
						</p>
<codeblock>make install INSTALLPRIVLIB=%i/lib/perl5/$version \
INSTALLARCHLIB=%i/lib/perl5/$version/$perlarchdir \
INSTALLSITELIB=%i/lib/perl5/$version \
INSTALLSITEARCH=%i/lib/perl5/$version/$perlarchdir \
INSTALLMAN1DIR=%i/share/man/man1 \
INSTALLMAN3DIR=%i/share/man/man3 \
INSTALLSITEMAN1DIR=%i/share/man/man1 \
INSTALLSITEMAN3DIR=%i/share/man/man3 \
INSTALLBIN=%i/bin \
INSTALLSITEBIN=%i/bin \
INSTALLSCRIPT=%i/bin
</codeblock>
<p>
ここで， <code>$perlarchdir</code> はバージョン 5.8.0 以前では &quot;darwin&quot; であり，
バージョン 5.8.1 以降では &quot;darwin-thread-multi-2level&quot; である．
</p>
						<p>
							パッケージが対応しているなら，代わりに <code>make install DESTDIR=%d</code> を使うことが望ましい．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>AppBundles</itemt>
					<itemd>
						<p>
							<em>post-0.23.1 バージョンから導入:</em>
							当フィールドは，アプリケーションバンドルを <filename>%p/Applications</filename> にインストールし， <filename>/Applications/Fink</filename>  にシンボリックリンクを作成します．
							例:
						</p>
<codeblock>AppBundles: build/*.app Foo.app</codeblock>
					</itemd>
				</item>
				<item>
					<itemt>JarFiles</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドは DocFiles に似ています．
							ここで指定した jar ファイルは <filename>%p/share/java/%n</filename> にインストールされます．
							例:
						</p>
<codeblock>JarFiles: lib/*.jar foo.jar:fooBar.jar</codeblock>
						<p>
							こうすると，ディレクトリ lib 内の全ての jar ファイルをインストールし，
							foo.jar を fooBar.jar としてインストールします．
						</p>
						<p>
							また，これらの jar ファイル (正確にはディレクトリ <filename>%p/share/java/%n</filename> 内にある .jar で終わるファイル)
							は環境変数 CLASSPATH に確実に追加されませ．
							このフィールドにより， configure や ant といったツールが，インストールされた jar ファイルを適切に認識できるようになります．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DocFiles</itemt>
					<itemd>
						<p>
							このフィールドにより，ファイル README や COPYING を，
							パッケージの doc ディレクトリ (<filename>%p/share/doc/%n</filename>) に容易にインストールできます．
							値にはスペース区切りでファイルのリストを指定します．
							ビルド用ディレクトリのサブディレクトリからファイルをコピーすることはできますが，
							それらのファイルは doc ディレクトリそのものに入れなければいけません (そのサブディレクトリに入れてはいけない)．
							シェルのワイルドカードが利用できます．
							単一のファイルを，実行時にリネームすることもできます．
							新ファイル名はコロンで区切って後置してください．
							例:
							<code>libgimp/COPYING:COPYING.libgimp</code>.
							このフィールドは InstallScript に適切な <code>install</code> コマンドを追加することで動作します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Shlibs</itemt>
					<itemd>
						<p>
							<em>Fink 0.11.0 で導入:</em>
							このフィールドでは，そのパッケージでインストールされる共有ライブラリを指定します．
							各共有ライブラリ毎に1行ずつ，空白文字で区切った以下の3項目を記述します．
							1) ライブラリの <code>-install_name</code> 2) ライブラリの <code>-compatibility_version</code>
							3) そのライブラリを提供する Fink パッケージを指定するバージョン付き依存性情報
							(ただし -compatibility_version が同じでなければならない)．
							依存情報は <code>foo (>= バージョン-版)</code> という型式で指定しなければいけません．
							ここで <code>バージョン-版</code> は， (互換性バージョンの同じ) そのライブラリを利用可能にしてくれる Fink パッケージの
							<em>一番古い</em>バージョンを指します．
							フィールド Shlibs の設定は「この名前がついていて compatibility_version がこれ以上のライブラリは，
							その Fink パッケージの今後のバージョンでも必ず含まれている」というメンテナからの保証に相当します．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>RuntimeVars</itemt>
					<itemd>
						<p>
							<em>Fink 0.10.0 で導入:</em>
							このフィールドにより，実行時に環境変数を何らかの固定された値に設定できます．
							(柔軟性が必要なら<xref section="profile.d">profile.d スクリプトの節</xref>を参照．)
							そのパッケージがインストールされる限り，
							ここに指定した環境変数はスクリプト <filename>/sw/bin/init.[c]sh</filename> によって設定されます．
						</p>
						<p>
							環境変数の値には空白文字が使えます (値の末尾に来ると取り除かれます)．
							また，パーセント展開が行われます．
							例:
						</p>
<codeblock>RuntimeVars: &lt;&lt;
SomeVar: %p/Value
AnotherVar: foo bar
&lt;&lt;</codeblock>
						<p>
							これは2つの環境変数 'SomeVar' および 'AnotherVar' を，
							それぞれ '/sw/Value' (環境のインストールディレクトリの値による) および 'foo bar' に設定します．
						</p>
						<p>
							このフィールドは InstallScript に適切なコマンドを追加することで機能します．
							それらのコマンドは，各環境変数に対してパッケージの profile.d スクリプトに setenv/export を追加します．
							よってパッケージメンテナ独自の環境変数は上書きされないので，自由に追加できます．
							これらの行はスクリプトに前置されるので，これらの環境変数をスクリプト内で利用できます．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SplitOff</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							1 回のコンパイル/インストール操作で第 2 のパッケージを生成する．
							詳細については，個別に書かれた<link url="#splitoffs">splitoff の節</link>を参照．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>SplitOff<em>N</em></itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							これはフィールド <code>SplitOff</code> と同様ですが，
							1 回のコンパイル/インストール操作で第 3 ，第 4 のパッケージを生成するために使われます．
							バージョン 0.19.2 以降の CVS 版 Fink では， 2 以上の任意の (つまり，必ずしも連続しない) 整数を N に使うことができます．
							しかし，重複はやはり許されていません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>Files</itemt>
					<itemd>
						<p>
							<em>Fink 0.9.9 で導入:</em>
							フィールド <code>SplitOff</code> または <code>SplitOff<em>N</em></code> の内部<em>のみ</em>で使われます．
							ここでは，splitoff したパッケージのインストールディレクトリ %i に親パッケージのインストールディレクトリ %I から
							どのファイルやディレクトリを移動するかを指定します．
							注記:
							これが実行されるタイミングは，親パッケージの InstallScript や DocFiles のコマンドの実行後で，
							splitoff したパッケージの InstallScript や Docfiles の実行前．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>ビルド段階関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
					<itemd>
						<p>
							これらのフィールドには，パッケージがインストール，アップグレード，または削除される時点で実行されるシェルスクリプトの断片を記述します．
							Fink はシェルスクリプトのヘッダ <code>#!/bin/sh</code> を自動的に追加します．
							また <code>set -e</code> で実行するので，どのコマンドが実行に失敗しても，スクリプトはその時点で停止します．
							また Fink は末尾に <code>exit 0</code> を追加します．
							エラーの発生を示すには，非ゼロの終了コードでスクリプトから exit します．
							第 1 実引数 (<code>$1</code>) は，どのアクションが実行されているかを示す値に設定されます．
							値としては <code>install</code>, <code>upgrade</code>, <code>remove</code> および <code>purge</code> が使用できます．
							ただしこれらの他にも使われる値があることに注意してください．
							エラー回復や，別パッケージのインストールによりパッケージを取り除くことを表す値などがあります．
						</p>
						<p>
							各スクリプトは以下のタイミングで実行される．
						</p>
						<ul>
							<li>PreInstScript: パッケージが初めてインストールされたときと，パッケージをそのバージョンにアップグレードする前．</li>
							<li>PostInstScript: パッケージを解凍し，設定する前．</li>
							<li>PreRmScript: パッケージが削除される前，または新しいバージョンにアップグレードされる前．</li>
							<li>PostRmScript: パッケージが削除された後，または新しいバージョンにアップグレードされた後．</li>
						</ul>
						<p>
							補足説明: アップグレードは新バージョンの ...InstScript と，旧バージョンの ...RmScript を実行します．
							詳細については the Debian Policy Manual,
							<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">第6章</link> を参照．
						</p>
						<p>
							スクリプト内ではパーセント展開が行われます．
							一般に，コマンドはフルパスを指定しなくても実行できます．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>ConfFiles</itemt>
					<itemd>
						<p>
							ユーザが修正し得る設定ファイルの空白区切りのリスト．
							パーセント展開は行われます．
							ファイルは，次のように絶対パスで指定しなければいけません．
							<filename>%p/etc/%n.conf</filename>.
							dpkg はここで指定されたファイルを以下のように特別な扱いをします．
							パッケージがアップグレードされたとき，新設定ファイルが提供され，しかもユーザが旧パッケージの設定ファイルが修正していた場合は，
							ユーザはどちらのバージョンを使うか尋ねられ，設定ファイルのバックアップが作られます．
							パッケージを &quot;remove&quot; しても，設定ファイルは削除されずにディスク上に残ります．
							設定ファイルも削除されるのは &quot;purge&quot; を命じたときのみ．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>InfoDocs</itemt>
					<itemd>
						<p>
							パッケージが <filename>%p/share/info</filename> にインストールする Info 文書のリスト．
							この設定により，Info ディレクトリ・ファイル <code>dir</code> を管理するための適切なコードが
							postinst および prerm スクリプトに追加されます．
							この機能はまだ流動的で，将来，精密な管理のためにさらにフィールドが追加されるかも知れません．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DaemonicFile</itemt>
					<itemd>
						<p>
							<code>daemonic</code> のサービスの説明を記述します．
							Fink は <code>daemonic</code> を使ってデーモン・プロセス (web サーバなど) のための StartupItems を生成したり削除します．
							説明は <code>%p/etc/daemons/<em>名前</em>.xml</code> という名前のファイルとしてパッケージに追加されます．
							ここで <em>名前</em> はフィールド DaemonicName で指定される (デフォルト値は「パッケージ名」)．
							このフィールドの値ではパーセント展開が行われます．
							パッケージが <code>daemonic</code> を利用するなら，それを依存性リストに加えなければいけないことに注意．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DaemonicName</itemt>
					<itemd>
						<p>
							<code>daemonic</code> サービスの記述ファイルの名前．
							詳細はフィールド DaemonicFile を参照．
						</p>
					</itemd>
				</item>
			</itemtable>
			<p>
				<em>付加的データ関連:</em>
			</p>
			<itemtable>
				<item>
					<itemt>Homepage</itemt>
					<itemd>
						<p>
							upstream パッケージのホームページの URL．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescDetail</itemt>
					<itemd>
						<p>
							フィールド <code>Description</code> よりも詳しい説明．
							(それが何であるか，何のために使うものか？)
							複数行に渡っても構いません．
							このフィールドは児童開業されずに表示されるので， (可能ならば) 手動で改行を挿入して各行 79 文字以内に収めてください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescUsage</itemt>
					<itemd>
						<p>
							パッケージを利用する上で必要になる情報を記述します．
							(そのパッケージはどのように使うものなのか？)
							例えば「 WindowMaker を使う前に wmaker.inst を起動．」等を (訳注: 英語で) ここに記述します．
							複数行に渡っても構いません．
							このフィールドはワードラップの恩恵に預らずに表示されるので， (可能ならば) 手動で改行を挿入して各行 79 文字以内に収めてください．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescPackaging</itemt>
					<itemd>
						<p>
							パッケージングに関する注意書き．
							「ファイルを適切な場所に置くために Makefile にパッチを当てる」等を (英語で) ここに記述します．
							複数行に渡ってよい．
						</p>
					</itemd>
				</item>
				<item>
					<itemt>DescPort</itemt>
					<itemd>
						<p>
							パッケージを Darwin に移植する場合に特有の注意書き．
							「config.guess と libtool スクリプトはアップデートする． -no-cpp-precomp が必要」等を (英語で) ここに記述します．
							複数行に渡ってよい．
						</p>
					</itemd>
				</item>

			</itemtable>
		</section>
		<section name="splitoffs">
			<title>スプリットオフ (SplitOff)</title>
			<p>
				Fink 0.9.9 で導入．
				単一の .info ファイルで複数のパッケージを作成することが可能です．
				インストール段階は普通に始まり， <code>InstallScript</code> と <code>DocFiles</code> コマンドを実行します．
				フィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> が存在すれば，それらに対しインストールディレクトリを作成します．
				<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中では，対応して新しく作られたインストールディレクトリは %i で，
				親パッケージのインストールディレクトリは %I で参照されます．
			</p>
			<p>
				フィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> には，独自のフィールドが多数あります．
				完全なパッケージ記述とよく似ていますが，抜けているフィールドもあります．
				以下は <code>SplitOff</code> に含まれる部分パッケージ記述 (分野別)です．
			</p>
			<ul>
				<li>
					初期データ関連:
					指定する必要があるのは <code>Package</code> のみで，
					その他は全て親パッケージから引き継がれます．
					<code>Type</code> と <code>License</code> は
					<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中で宣言することで変更できます．
					パーセント展開も使えます．
					特に，親パッケージの名称を参照する %N を使用すると良いでしょう．
				</li>
				<li>
					依存性関連: 全てのフィールドが記述可能．
				</li>
				<li>
					解凍段階, パッチ段階, コンパイル段階関連: これらのフィールドは意味がないため無視されます．
				</li>
				<li>
					インストール段階, ビルド段階関連: 全てのフィールドが記述可能．
					(ただし <code>SplitOff</code> や <code>SplitOff<em>N</em></code> を入れ子にはできません．)
				</li>
				<li>
					付加的データ関連: 親パッケージから引き継がれますが，
					<code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中で宣言して修正することができます．
				</li>
			</ul>
			<p>
				インストール段階では，まず親パッケージの <code>InstallScript</code> と <code>DocFiles</code> が実行されます．
				次にフィールド <code>SplitOff</code> や <code>SplitOff<em>N</em></code> の処理が行われます．
				すなわち，そのそれぞれの中の <code>Files</code> のコマンドが実行され，
				指定されたファイルやディレクトリが親インストールディレクトリ %I から splitoff パッケージのインストールディレクトリ %i に移されます．
				続いて <code>SplitOff</code> や <code>SplitOff<em>N</em></code> の中の
				<code>InstallScript</code> や <code>DocFiles</code> などが順に実行されます．
			</p>
			<p>
				現在の Fink では，最初に <code>SplitOff</code> が (あれば) 処理され，その後に
				<code>SplitOff2</code>, <code>SplitOff3</code> などがさらに存在する場合，数の順に処理されます．
				しかしこの順番は将来変更されるかもしれません．
				よって， <code>SplitOff</code> が <code>SplitOff2</code> より先に処理される現状でしか正しく動作しない，次のようなコード
			</p>
<codeblock>
SplitOff: &lt;&lt;
  Description: Some header files
  Files: include/foo.h include/bar.h
&lt;&lt;
SplitOff2: &lt;&lt;
  Description: All other header files
  Files: include/*
&lt;&lt;
</codeblock>
			<p>
				を避け，それぞれの中で明示的なファイル名を使うか，より精密なファイルグロブ (いわゆるワイルドカード) を使う方がよいでしょう．
			</p>
			<p>
				ビルド段階では，各パッケージの pre/post install/remove スクリプトをビルド段階コマンドを使って作成します．
			</p>
			<p>
				ビルドされるパッケージは，ライセンス条項を <filename>%i/share/doc/%n</filename> に明記する必要があります
				(%n の値は当然パッケージ毎に異なる)．
				<code>DocFiles</code> はファイルを移動ではなくコピーすることに注意．
				よって <code>DocFiles</code> を使えば同一のドキュメントを各 splitoff パッケージ向けに複数回インストールできます．
			</p>
		</section>
		<section name="scripts">
			<title>スクリプト</title>
			<p>
				フィールド PatchScript, CompileScript, InstallScript には，実行させたいシェルコマンドを記述できる．
				形式は 2 種類ある．
			</p>
			<p>
				このフィールドには単にコマンドを列挙すれば，シェルスクリプトと同様です．
				しかし，コマンドが一行ごとに system() によって実行される点が異なります．
				よって変数の設定やディレクトリの移動はその行内でのみ有効になります．
				0.18.2 以降の CVS 版 Fink では，
				通常のシェルスクリプトと同様に長い行を改行できます．
				行末にバックスラッシュ (<code>\</code>) を置くと次の行は継続行になります．
			</p>
			<p>
				または，任意のスクリプト処理系の完全なスクリプトを記述することもできます．
				その場合，他の Unix のスクリプトファイルと同様，第1行目は <code>#!</code> にインタプリタのフルパス名を続け，
				さらに必要なフラグを続けたものでなければいけない
				(<code>#!/bin/csh</code>, <code>#!/bin/bash -ev</code> など)．
				その場合，フィールド *Script の値全体が一時ファイルにダンプされ，実行されます．
			</p>
		</section>
		<section name="patches">
			<title>パッチ</title>
			<p>
				パッケージを Darwin でコンパイルするために (または Fink と協調して動作するようにするために) パッチが必要な場合，
				パッチにはパッケージ記述の拡張子 &quot;.info&quot; を &quot;.patch&quot; に変えたファイル名を使い， 
				.info ファイルと同じディレクトリに入れます．
				パッケージファイル名に完全名を使っている場合は，次のどちらかを使います (どちらも同等)．
			</p>
<codeblock>Patch: %f.patch</codeblock>
<codeblock>PatchScript: patch -p1 &lt;%a/%f.patch</codeblock>
			<p>
				新しく導入された方の簡潔なパッケージファイル命名規則を採用しているなら， %f でなく %n を使うこと．
				これら2つのフィールドは互いに排他的ではなく，両方指定することもできます (PatchScript, Patch の順に両方実行されます)．
			</p>
			<p>
				パッチファイルではユーザがインストールディレクトリを選択できるようにする方がよいので，
				<code>/sw</code> という決め打ちではなく <code>@PREFIX@</code> 等の変数を使います．
				以下のようにすると良いでしょう．
			</p>
<codeblock>PatchScript: sed 's|@PREFIX@|%p|g' &lt;%a/%f.patch | patch -p1</codeblock>
			<p>
				パッチの書式は unidiff (unified diff) でなければいけません．
				普通，次のようにして生成できます．
			</p>
<codeblock>diff -urN &lt;originalsourcedir&gt; &lt;patchedsourcedir&gt;</codeblock>
			<p>
				エディタに Emacs を使っているなら，上記のコマンド diff の引数に <code>-x'*~'</code> を加え，
				自動生成されたバックアップファイルを比較対象から除きます．
			</p>
			<p>
				巨大なサイズのパッチを cvs に入れるのは好ましくないことにも注意．
				そういうパッチは web/ftp サーバに置き，フィールド <code>SourceN:</code> に指定します．
				自分のウェブサイトを持っていなくても，
				Fink プロジェクトの管理者がそのファイルを Fink のサイトからダウンロードできるようにすることも可能です．
				パッチが 30KB より大きければ，独立にダウンロードする方法を考慮した方がよいでしょう．
			</p>
		</section>
		<section name="profile.d">
			<title>Profile.d スクリプト</title>
			<p>
				パッケージが実行時に何らかの初期化 (環境変数の設定など) を必要とするなら， profile.d スクリプトを使えばよいでしょう．
				これらのスクリプト断片はスクリプト <filename>/sw/bin/init.[c]sh</filename> によって読み込まれます．
				通常，全ての Fink ユーザがシェルのスタートアップファイル (<filename>.cshrc</filename> またはそれと互換なファイル) でそれを読み込むようになっています．
				パッケージの方では，どのスクリプトにも2種類を用意しなければいけません:
				sh 互換シェル (sh, zsh, bash, ksh, ...) 用と， csh 互換シェル (csh, tcsh) 用です．
				両スクリプトとも <filename>/sw/etc/profile.d/%n.[c]sh</filename> としてインストールされる必要があります．
				(ここで %n は，他と同様に「パッケージ名」を表す．)
				また，正しく読み込まれるためには，それらのパーミッションは実行，読み込みが共に可能でなければいけません．
				(すなわち，それらのインストールには引数 <code>-m 755</code> を付ける．)
			</p>
			<p>
				環境変数をいくつか設定したいだけなら (QTDIR を '/sw' にする，など)，フィールド RuntimeVars を使えばよいでしょう．
				このフィールドはまさにその作業を簡略化するために用意されたものです．
			</p>
		</section>
	</chapter>
</document>
