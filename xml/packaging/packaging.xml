<?xml version="1.0" encoding="iso-8859-1"?>

<document filename="index">
<title>Creating Fink Packages</title>
<shorttitle>Packaging</shorttitle>
<cvsid>$Id: packaging.xml,v 1.19 2002/02/24 04:29:19 dmrrsn Exp $</cvsid>

<preface>
<p>
This manual documents how to create package descriptions for the Fink
package manager.
It also provides a policy and guidelines for the Fink distribution.
Both the description format and the distribution policy are still
evolving, so watch the "Last changed" info and the CVS tag on this
page to detect updates.
What you're reading right now is a description of the format and
policy used in post-0.9.0 development versions of the <tt>fink</tt>
package manager.
</p>
<p>
If you create packages for Fink, you may want to subscribe to the
<link url="http://lists.sourceforge.net/lists/listinfo/fink-devel">fink-devel</link>
mailing list.
</p>
</preface>


<chapter filename="intro">
<title>Introduction</title>
<shorttitle>Intro</shorttitle>


<section name="def1"><title>What is a Package?</title>
<p>
A package is a piece of software that forms an atomic unit.
A typical package contains an executable program, the data files it
needs, message catalogs for internationalisation and documentation.
In Fink, packages can exist in two forms: the package description
and the ready-to-install binary package file.
</p>
<p>
The package description is a human readable text file that contains
everything needed to build a package, i.e. to create the binary
package file.
The information includes meta-data (like the package's name and a prose
description of its purpose), the URL of the source code and the
instructions necessary to configure, compile and wrap up the package.
The description may be accompanied by a patch file.
</p>
<p>
A binary package file is a file archive that contains the actual files
that make up the package,
i.e. executables, data files, message catalogs, libraries, include
files, etc.
The package file also contains some meta-data for the package.
Installing a binary package mainly consists of unpacking its contents
as it is already in an ready-to-use form.
Since Fink builds on the dpkg package manager, the binary package
files are in the dpkg format and have the extension .deb.
</p>
</section>


<section name="ident"><title>Identifying a Package</title>
<p>
A package is identified by three strings: the package name, the
version and the revision.
All of these may contain lower-case letters (a-z), numbers (0-9),
dashes (-), plus signs (+) and dots (.).
Other characters are not allowed.
In particular, capital letters and underscores are not allowed.
</p>
<p>
The package name is simply the name of the software, e.g. openssh.
The version, also called the upstream version, is the version
identifier of the original software package.
It is okay to use letters in the version, e.g. 2.9p1.
Both fink and dpkg know how to sort these correctly.
The revision is a counter that is increased when the package
description changes.
It starts at 1 and should be reset to 1 when the upstream version
changes.
The revision must not contain dashes.
The full name of a package is all three items concatenated, with
dashes in between, e.g. openssh-2.9p1-2.
</p>
</section>

</chapter>


<chapter filename="format">
<title>Package Descriptions</title>
<shorttitle>Package Descriptions</shorttitle>

<section name="trees"><title>Tree Layout</title>
<p>
Package descriptions are read from the <code>finkinfo</code>
directories below the <code>/sw/fink/dists</code> directory.
The "Trees" setting in <code>/sw/etc/fink.conf</code> controls which
directories are read.
The name of package description files must be the full package name
plus the extension ".info".
</p>
<p>
The package description tree is organized with several levels of
directories.
The directories in top-down order:
</p>
<ul>
<li><code>dists</code> is where is starts. The <code>dists</code>
directory is necessary for the Debian tools.</li>
<li>The distribution. There is <code>stable</code>,
<code>unstable</code> and <code>local</code>. The <code>local</code>
directory is under the control of the local administrator/user. The
<code>stable</code> and <code>unstable</code> directores are part of
Fink.</li>
<li>The tree. The <code>main</code> tree contains the bulk of the
packages. Cryptographic software is kept in a separate tree,
<code>crypto</code>, to make removal easy should it become
necessary.</li>
<li><code>finkinfo</code>
vs. <code>binary-darwin-powerpc</code>. <code>finkinfo</code> contains
the Fink package descriptions and patches, while
<code>binary-darwin-powerpc</code> contains the <code>.deb</code>
binary packages.</li>
<li>Sections. The <code>main</code> tree is subdivided into thematic
sections to make it manageable. The <code>crypto</code> tree is not
divided into sections at the moment.</li>
</ul>
</section>

<section name="format"><title>File Format</title>
<p>
The description files are simple lists of key-value pairs, also called
'fields'.
The format is based on the popular RFC 822 header format.
Each line starts with a key, terminated by a colon (:) and followed by
the value, like this:
</p>
<codeblock>Key: Value</codeblock>
<p>
There are two notations for fields that must span multiple lines.
The traditional notation is crafted after the RFC 822 header folding
method.
A line that starts with whitespace is treated as a continuation of the
previous line.
Example:
</p>
<codeblock>InstallScript: mkdir -p %i/share/man
 make install prefix=%i mandir=%i/share/man
 mkdir -p %i/share/doc/%n
 install -m 644 COPYING %i/share/doc/%n</codeblock>
<p>
Note the indentation of the lines.
</p>
<p>
The more recent alternative notation is based on the here-document
syntax in shell scripts.
The first line consists of the key, followed by <code>&lt;&lt;</code>
as the value.
All following lines are treated as the actual value, until a line with
just <code>&lt;&lt;</code> on it is encountered.
The example from above now looks like this:
</p>
<codeblock>InstallScript: &lt;&lt;
mkdir -p %i/share/man
make install prefix=%i mandir=%i/share/man
mkdir -p %i/share/doc/%n
install -m 644 COPYING %i/share/doc/%n
&lt;&lt;</codeblock>
<p>
Note the lack of indentation and the terminating
<code>&lt;&lt;</code>.
</p>
<p>
Empty lines and lines starting with a hash (#) are ignored.
Keys (field names) are case-insensitive in Fink, so you can write
<code>InstallScript</code>, <code>installscript</code> or
<code>INSTALLSCRIPT</code> as you please.
The first form is preferred for readability, though.
Some fields take a boolean value - any of "true", "yes", "on", "1"
(case-insensitive) are treated as true, all other values are treated
as false.
</p>
</section>

<section name="percent"><title>Percent Expansion</title>
<p>
To make life easier, Fink supports a set of expansions that are
performed on some fields.
The available expansions are:
</p>
<dl>
<dt>%n</dt><dd>the package <em>n</em>ame</dd>
<dt>%v</dt><dd>the package <em>v</em>ersion</dd>
<dt>%r</dt><dd>the package <em>r</em>evision</dd>
<dt>%f</dt><dd>the <em>f</em>ull package name, i.e. %n-%v-%r</dd>
<dt>%p</dt><dd>the <em>p</em>refix where Fink is installed, e.g. /sw</dd>
<dt>%d</dt><dd>the <em>d</em>estination directory where the tree to be
packaged is built, e.g. /sw/src/root-gimp-1.2.1-1</dd>
<dt>%i</dt><dd>the full <em>i</em>nstall-phase prefix, equivalent to %d%p</dd>
<dt>%a</dt><dd>the path where the p<em>a</em>tches can be found</dd>
<dt>%b</dt><dd>the <em>b</em>uild directory,
e.g. /sw/src/gimp-1.2.1-1/gimp-1.2.1
<p>Note: Use this only when there is no other way. The build
directory is the current directory when scripts are executed; you
should use relative path names in commands.</p>
</dd>
<dt>%c</dt><dd>the parameters for <em>c</em>onfigure:
<code>--prefix=%p</code> plus anything specified with
ConfigureParams</dd>
</dl>

</section>

</chapter>


<chapter filename="policy">
<title>Packaging Policy</title>
<shorttitle>Policy</shorttitle>

<section name="licenses"><title>Package Licenses</title>
<p>
The packages included in Fink come with a wide variety of licenses.
Most of them place restrictions on redistributing the full source and
especially on distributing binaries.
Some packages can not be included in the binary distribution of Fink
because of these license restrictions.
Thus it is very important that package maintainers check the license
of their package carefully.
</p>
<p>
Every package that is to be distributed as a binary package must
contain a copy of the license.
It must be installed in the doc directory,
i.e. in <code>%p/share/doc/%n</code>.
(In the InstallScript, %i must be used instead of %p, of course.
The DocFiles field takes care of the details automatically.)
If there is no explicit license in the original source, include a
small text file with a note about the status of the package.
Most licenses require that the license accompanies any distribution.
Fink's policy is to always do this, even if it is not explicitly
required.
</p>
<p>
To make an automated maintenance of the binary distribution possible,
any package that is to be distributed must have a <code>License</code>
field.
This field denotes the nature of the license and is used to decide
which packages make it into the binary distribution and which must be
held back.
The field may only be present if the actual license terms are included
in the binary package, as explained above.
</p>
<p>
To make the <code>License</code> field useful, only one of the
following pre-defined values may be used.
If you're packaging something that doesn't fit into these categories,
ask for help on the developer mailing list.
</p>
<ul>

<li><code>GPL</code> - the GNU General Public License.
This license requires that the source is available from the same place
as the binary.</li>
<li><code>LGPL</code> - the GNU Lesser General Public License.
This license requires that the source is available from the same place
as the binary.</li>
<li><code>GPL/LGPL</code> - this if a special case for packages where
one part is licensed under the GPL (e.g. the executables) and another
part is licensed under the LGPL (e.g. the libraries).</li>

<li><code>BSD</code> - for BSD-style licenses.
This includes the so-called "original" BSD license, the "modified" BSD
license and the MIT license. The Apache license also counts as
BSD. With these licenses the distribution of source code is
optional.</li>

<li><code>Artistic</code> - for the Artistic license and
derivatives.</li>

<li><code>OSI-Approved</code> - for other Open Source licenses
approved by the <link url="http://www.opensource.org/">Open Source
Initiative</link>. One of OSI's requirements is that free distribution
of binaries and sources is allowed. This value can also be used as an
umbrella for dual-licensed packages.</li>

<li><code>Restrictive</code> - for restrictive licenses.
Use this for packages that are available from the author in source
form for free use, but don't allow free redistribution.</li>

<li><code>Commercial</code> - for restrictive, commercial licenses.
Use this for commercial packages (e.g. Freeware, Shareware) that do
not allow free redistribution of source or binaries.</li>

<li><code>Public Domain</code> - for packages that are in the Public
Domain, i.e. the author has given up his copyright on the code. These
packages don't have licenses at all and anyone can do anything with
them.</li>

</ul>
<p>
If the documentation included in a package is explicitly put under the
GNU Free Documentation License, a <code>/GFDL</code> may be appended to
the License field, e.g. <code>GPL/GFDL</code>. If the documentation
included in a package is explicitly put under the Linux Documentation
Project license, the same applies, e.g. <code>GPL/LDP</code>.
</p>
</section>


<section name="prefix"><title>Base System Interference</title>
<p>
Fink is an add-on distribution that is installed in a directory
separate from the base system.
It is crucial that a package does not install files outside of Fink's
directory.
</p>
<p>
Exceptions can be made when there is no other possibility, e.g. with
XFree86.
In this case the package must check for existing files before
installation and refuse to install if it would overwrite existing
files.
The package must make sure that all files it installed outside of the
Fink directory are deleted when the package is removed, or that they
cause no harm if they are left there (i.e. they need to check binaries
for existence before calling them and the like).
</p>
</section>

<section name="sharedlibs"><title>Shared Libraries</title>
<p>
Fink has a new policy about shared libraries, effective in February 2002.
(This section of the documentation contains a preliminary discussion
of the policy, which may evolve slightly as it becomes more fully
implemented.)
We first discuss the policy as applied to newly ported software, and
then turn to the question of upgrading existing fink packages.  For an
example of the policy in action, see the  libpng and 
libpng-shlibs packages.
</p><p>
Software which has been ported to Darwin should build shared libraries (as 
opposed to static libraries) whenever possible.  When this has been done,
<em>two</em> closely related fink packages should be made, named foo 
and foo-shlibs.  At present, this must be done by hand, but an extension to 
fink is under development which will allow both fink packages to be generated 
from a single .info file.  (In fact, more than two packages can be
generated if necessary.)
</p><p>
Each software package for which shared libraries can be built must have
a <em>major version number</em> N.  The major version number is only supposed
to change when a backwards-incompatible change in the library's API has been
made.  Fink uses the following naming convention: if the upstream name
of the package is bar, then the fink packages are called barN and 
barN-shlibs.  (This is only strictly applied to new packages, or when the 
major version number changes.)  For example, the major version number for
the pre-existing libpng package was 2, but recent versions of the
library have major version number 3.  So there are now four fink packages
to handle this: libpng, libpng-shlibs, libpng3, libpng3-shlibs.
Only one of libpng and libpng3 can be installed at any given time,
but libpnd-shlibs and libpng3-shlibs can be installed at the same time.
</p><p>
The shared library itself and certain related files will be put into 
the package barN-shlibs; the "include" files and certain other files will
be put into the package barN.  There can be no overlapping files
between these two packages, and everything stored in barN-shlibs must have
a pathname which somehow includes the major version number N.  In many
instances, your package will need some files at runtime which are
typically installed into <code>%i/lib/bar/</code> or 
<code>%i/share/bar/</code> ; you should
adjust the installation paths to <code>%i/lib/bar/N/</code> or 
<code>%i/share/bar/N/</code>.
</p><p>
All other packages which depend on bar, major version N, will be asked to
use the dependencies
<codeblock>
  Depends: barN-shlibs
  BuildDepends: barN
</codeblock>
Once this system is fully in place, it will not be permitted for 
another package to depend on barN itself.  (For backward compatibility,
such dependencies are allowed for pre-existing packages.)
</p><p>
If your package includes both shared libraries and binary files, and
if the binary files need to be present at runtime (not just at build
time), then the binaries must be split off into a third package, which
could be called barN-bin.  Other packages are allowed to depend on
barN-bin as well as barN-shlibs.
</p><p>
When building shared libraries under major version N, it is important that
the "install_name" of the library be <code>%p/lib/bar.N.dylib</code>.  
(You can
find the install_name by running <code>otool -L</code> on your library.)  The
actual library file should be installed at
<codeblock>
  %i/lib/bar.N.x.y.dylib
</codeblock>
and your packages should create symbolic links
<codeblock>
  %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
  %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
</codeblock>
If the static library is also built, then it will be installed at
<codeblock>
  %i/lib/bar.a
</codeblock>
These things are usually handled automatically by libtool, but you should
check that they have been done correctly in your case.  You should also
check that current_version and compatibility_version were defined 
appropriately for your shared libraries.  (These are also shown with the 
<code>otool -L</code> query.)
</p><p>
Files are then divided between the two packages as follows
<ul>
<li>  in package barN-shlibs:
<codeblock>
    %i/lib/bar.N.x.y.dylib
    %i/lib/bar.N.dylib -> %p/lib/bar.N.x.y.dylib
    %i/lib/bar/N/*
    %i/share/bar/N/*
    %i/share/doc/barN-shlibs/*
</codeblock></li>
<li>  in package barN:
<codeblock>
    %i/include/*
    %i/lib/bar.dylib -> %p/lib/bar.N.x.y.dylib
    %i/lib/bar.a
    %i/share/doc/barN/*
    other files, if needed
</codeblock></li></ul>
Notice that both packages are required to have some documentation about
the license, but that the directories containing the DocFiles will be
different.
</p><p>
At the moment, the only way to do this is to let each package run the
original CompileScript and InstallScript, and then remove some of the files
prior to installation.  (Notice that, as in the examples libpng, 
libpng-shlibs, you may be able to use %v in place of N.x.y or x.y in
the .info file, which is more robust for updating minor versions of the
same package later on.)  In the extension of fink under development,
you will be able to just specify which files are to be installed into 
barN-shlibs rather than into barN.
</p><p>
There should be a dependency specifed in package barN:
<codeblock>
  Depends: barN-shlibs (= exact.version.of.barN)
</codeblock>
This ensures that the versions match, and also guarantees that barN
automatically "inherits" all the dependencies of barN-shlibs.
</p><p>
<em>What to do when the major version number changes:</em>
</p><p>
If the major version number changes from N to M, you will create two new
packages barM and barM-shlibs.  The package barM-shlibs can have no
overlap with the package barN-shlibs, since many users will have both of
these installed simultaneously.  In package barM, you should use dependencies
<codeblock>
  Conflicts: barN
  Replaces: barN
</codeblock>
and similarly, you should revise barN to include dependencies
<codeblock>
  Conflicts: barM
  Replaces: barM
</codeblock>
Users will then see barN and barM shuffling in and out as various other
packages are built which depend on one version or another of the shared
library, while barN-shlibs and barM-shlibs remain permanently installed.
</p><p>
<em>How to upgrade an existing fink package:</em>
</p><p>
For an existing fink package which installs either static or shared 
libraries, the best way to upgrade is to create a new version foo of
your package, accompanied by a new package foo-shlibs, which satisfy
the above policy.  If shared libraries (or any other files now present
in foo-shlibs) were installed previously, then these new packages should 
say
<codeblock>
  Replaces: foo (&lt;&lt; earliest.compliant.version)
</codeblock>
so that upgrading will be transparent to users.  (You should <em>not</em>
say "Conflicts: foo" because this will prevent the upgrade.)
</p><p>
After your upgrade, packages which say "Depends: foo" will continue to
function normally.  However, you should contact the fink maintainers
of all such packages and urge them to modify their packages to say 
"Depends: foo-shlibs, BuildDepends: foo" as soon as possible.  You will 
not be able to create new packages fooM, fooM-shlibs which implement a 
new major version of the shared library until they have done so.
</p><p>
Existing fink packages which have not used the correct install_name or
which have not used the correct names or symbolic links for shared libraries
must be upgraded carefully, on a case-by-case basis.  If you are
having trouble finding an upgrade strategy to make your packages compliant
with the new policy, please discuss it on the fink-devel mailing list.
</p>

</section>
</chapter>


<chapter filename="fslayout">
<title>Filesystem Layout</title>
<shorttitle>FS Layout</shorttitle>


<preface>
<p>
The following file system layout guidelines are part of the Fink
packaging policy.
</p>
</preface>


<section name="fhs"><title>The Filesystem Hierarchy Standard</title>
<p>
Fink follows the spirit of the <link
url="http://www.pathname.com/fhs/">Filesystem Hierarchy
Standard</link>, or FHS for short.
It can only follow it in spirit because the FHS was created for system
vendors that have control over the <code>/</code> and
<code>/usr</code> hierarchies.
Fink is an add-on distribution that controls only its install
directory (or prefix).
The examples use the default prefix of <code>/sw</code>.
</p>
</section>

<section name="dirs"><title>The Directories</title>
<p>
Files should go into the following subdirectories of the hierarchy:
</p>

<itemtable>

<item><itemt><code>/sw/bin</code></itemt>
<itemd>
<p>
This directory is for general executable programs.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><code>/sw/sbin</code></itemt>
<itemd>
<p>
This directory is for executable programs that are intended to be used
by administrators only.
Background daemons go here.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><code>/sw/include</code></itemt>
<itemd>
<p>
This directory is for C and C++ header files.
Subdirectories can be created as necessary.
If a package installs header files that can be confused with standard
C headers, those headers <em>must</em> go to a subdirectory.
</p>
</itemd></item>

<item><itemt><code>/sw/lib</code></itemt>
<itemd>
<p>
This directory is for architecture-dependend data files and
libraries.
Static and shared libraries should be placed directly in
<code>/sw/lib</code> unless there is a good reason not to.
This is also the place for executables that should not be executed
directly by the user (which would otherwise be places in libexec).
</p>
<p>
A package is free to create a subdirectory to store private data or
loadable modules.
Make sure to use directory names that make sense for compatibility.
It is wise to use the package major version in the directory name or
as an additional hierarchy level, e.g. <code>/sw/lib/perl5</code> or
<code>/sw/lib/apache/1.3</code>.
Care should be taken when the host type is used to create
directories.
A <code>powerpc-apple-darwin1.3.3</code> directory is bad for
compatibility, <code>powerpc-apple-darwin1.3</code> or just
<code>powerpc-apple-darwin</code> are better choices.
</p>
</itemd></item>

<item><itemt><code>/sw/share</code></itemt>
<itemd>
<p>
This directory is for architecture-independent data files.
The same rules as for <code>/sw/lib</code> apply.
Some common subdirectories are described below.
</p>
</itemd></item>

<item><itemt><code>/sw/share/man</code></itemt>
<itemd>
<p>
This directory contains manual pages.
It is organized into the usual section tree.
Every program in <code>/sw/bin</code> and <code>/sw/sbin</code> should
have an associated manual page here.
</p>
</itemd></item>

<item><itemt><code>/sw/share/info</code></itemt>
<itemd>
<p>
This directory contains documentation in the Info format (produced
from Texinfo sources).
Maintenance of the <code>dir</code> file is automated through Debian's
version of <code>install-info</code> (part of the <code>dpkg</code>
package).
Use the <code>InfoDocs</code> description field to automatically
generate appropriate code for the <code>postinst</code> and
<code>prerm</code> package scripts.
Fink makes sure that no package installs a <code>dir</code> file of
its own.
There are no subdirectories.
</p>
</itemd></item>

<item><itemt><code>/sw/share/doc</code></itemt>
<itemd>
<p>
This directory contains documentation that is neither a man page nor
an Info document.
README, LICENSE and COPYING files go here.
Every package must create a subdirectory here, named after the
package.
The subdirectory name must not contain any version numbers (unless
they are a part of the package name proper).
Hint: Just use <code>%n</code>.
</p>
</itemd></item>

<item><itemt><code>/sw/share/locale</code></itemt>
<itemd>
<p>
This directory contains message catalogs for internationalization.
</p>
</itemd></item>

<item><itemt><code>/sw/var</code></itemt>
<itemd>
<p>
The <code>var</code> directory stores variable data.
This includes spool directories, lock files, state databases, game
high scores and log files.
</p>
</itemd></item>

<item><itemt><code>/sw/etc</code></itemt>
<itemd>
<p>
This directory holds configuration files.
For packages that have more than one or two files here a subdirectory
should be made.
The subdirectory must have the name of the package or program in it so
that it is identifyable.
</p>
</itemd></item>

<item><itemt><code>/sw/src</code></itemt>
<itemd>
<p>
This directory is for storing and building source code.
Nothing should be installed here by a package.
</p>
</itemd></item>

</itemtable>
</section>


<section name="avoid"><title>Things to Avoid</title>
<p>
No other directories than the ones mentioned above should exist
in /sw.
In particular, the following should not be used: /sw/man, /sw/info,
/sw/doc, /sw/libexec, /sw/lib/locale.
</p>
</section>


</chapter>


<chapter filename="reference">
<title>Reference</title>
<shorttitle>Reference</shorttitle>


<section name="build"><title>The Build Process</title>

<p>To understand some of the fields, you need some knowledge of the
build process Fink uses. It consists of five phases: unpack, patch,
compile, install and build. The example paths below are for an
installation in /sw and the package gimp-1.2.1-1.</p>
<p>In the <em>unpack phase</em> the directory /sw/src/gimp-1.2.1-1 is created
and the source tarball(s) are unpacked there. In most cases, this will
create a directory gimp-1.2.1 with the source in it; all following
steps will be executed in that directory
(i.e. /sw/src/gimp-1.2.1-1/gimp-1.2.1). Details can be controlled with
the SourceDirectory, NoSourceDirectory and Source<i>N</i>ExtractDir
fields.</p>
<p>In the <em>patch phase</em> the source is patched so that it will
build on Darwin. The actions specified by the UpdateConfigGuess,
UpdateLibtool, Patch and PatchScript fields will be executed, in that
order.</p>
<p>In the <em>compile phase</em> the source is configured and
compiled. Usually this means calling the <code>configure</code> script
with some parameters and then issuing a <code>make</code> command. See the
ConfigureScript field description for details.</p>
<p>In the <em>install phase</em> the package is installed to a temporary
directory, /sw/src/root-gimp-1.2.1-1 (= %d). (Note the "root-" part.)
All files that would normally be installed to /sw are installed in
/sw/src/root-gimp-1.2.1-1/sw (= %i = %d%p) instead. See the
InstallScript field description for details.</p>
<p>In the <em>build phase</em> a binary package file (.deb) is built
from the temporary directory. You can't influence this step directly,
but various information from the package description is used to
generate a <code>control</code> file for dpkg.</p>
</section>

<section name="fields"><title>Fields</title>

<p>This list is not necessarily complete. <code>:-)</code></p>

<itemtable>
<item><itemt>Package</itemt>
<itemd>
<p>
The package name.
May contain lowercase letters, numbers and the special characters '.',
'+' and '-'.
No underscores ('_'), no capital letters.
Required field.
</p>
</itemd></item>

<item><itemt>Version</itemt>
<itemd>
<p>
The upstream version number.
Same limitations as the Package field.
Required field.
</p>
</itemd></item>

<item><itemt>Revision</itemt>
<itemd>
<p>
The package revision.
Increase this when you make a new description for the same upstream
version.
Revision numbers start at 1.
Required field.
</p>
</itemd></item>

<item><itemt>Type</itemt>
<itemd>
<p>
This can be set to <code>bundle</code>.
Bundle packages are used to group a set of related packages together.
They only have dependencies, but no code and no installed files.
The fields Source, PatchScript, CompileScript, InstallScript and
related ones are ignored for bundle packages.
</p>
<p>
<code>nosource</code> is a very similar type.
It indicates that there is no source tarball, so nothing is fetched
and the unpack phase creates just an empty directory.
However, the patch, compile and install phases are executed normally.
This way you can bring in all the code with a patch, or just create
some directories in the InstallScript.
</p>
<p>
Finally since fink 0.9.5 there is type <code>perl</code> which causes
alternate default values for the compile and install scripts to be used. 
</p>
</itemd></item>

<item><itemt>Maintainer</itemt>
<itemd>
<p>
The name and e-mail address of the person responsible for the package.
This field is required, and there must be exactly one name and address
in the following format:
</p>
<codeblock>Firstname Lastname &lt;user@host.domain.com&gt;</codeblock>
</itemd></item>

<item><itemt>Depends</itemt>
<itemd>
<p>
A list of packages which must be installed before this package can be
built.
Usually, this is just a comma-separated list for plain package names,
but Fink now supports alternatives and version clauses with the same
syntax as dpkg.
A fully featured example:
</p>
<codeblock>Depends: daemonic (&gt;= 20010902-1), emacs | xemacs</codeblock>
<p>
Note that there is no way to express real optional dependencies.
If a package works both with and without another package, you must
either make sure that the other package is not used even when it is
present or add it to the Depends field.
If you want to offer the user both options, make two separate
packages, e.g. wget and wget-ssl.
</p>
</itemd></item>

<item><itemt>BuildDepends</itemt>
<itemd>
<p>
<i>Introduced in fink 0.9.0.</i>
A list of dependencies that is applied at build time only.
This can be used to list tools (e.g. flex) that must be present to
build the packages, but which are not used at run time.
Supports the same syntax as Depends.
</p>
</itemd></item>

<item><itemt>Provides</itemt>
<itemd>
<p>
A comma-separated list of package names that this package is
considered to "provide".
If a package named "pine" specifies <code>Provides: mailer</code>,
then any dependency on "mailer" is considered satisfied when "pine" is
installed.
You'll usually also want to name these packages in the "Conflicts" and
the "Replaces" field.
</p>
</itemd></item>

<item><itemt>Conflicts</itemt>
<itemd>
<p>
A comma-separated list of package names that must not be installed at
the same time as this package.
For virtual packages it is allowed to list the names of the provided
packages here; they will be handled appropriately.
This fields also supports versioned dependencies like the Depends
field, but not alternatives (wouldn't make sense).
</p>
<p>
<em>Note:</em> Fink itself currently ignores this field.
However, it is passed on to dpkg and will be handled accordingly.
In summary, it only effects run-time, not build-time.
</p>
</itemd></item>

<item><itemt>Replaces</itemt>
<itemd>
<p>
This is used together with "Conflicts", when this package not only
takes over the function of the conflicting package, but also has some
common files.
Without this field, dpkg may generate errors when installing the
package because files are still owned by the other package.
It is also a hint that the two packages involved are genuine
alternatives and one can be removed in favor of the other.
</p>
<p>
<em>Note:</em> Fink itself currently ignores this field.
However, it is passed on to dpkg and will be handled accordingly.
In summary, it only effects run-time, not build-time.
</p>
</itemd></item>

<item><itemt>Recommends, Suggests, Enhances</itemt>
<itemd>
<p>
These fields specify additional package relations in the same style as
the other dependency fields.
These three relations don't affect actual installation via
<code>dpkg</code> or <code>apt-get</code>.
However, they are used by <code>dselect</code> and other frontends to
help the user make sensible choices.
</p>
</itemd></item>

<item><itemt>Pre-Depends</itemt>
<itemd>
<p>
A special variation of the Depends field with more strict semantics.
This field must only be used after the case has been discussed on the
developer mailing list and a consensus has been reached that it is
necessary.
</p>
</itemd></item>

<item><itemt>Essential</itemt>
<itemd>
<p>
A boolean value that denotes essential packages. Essential
packages are installed as part of the bootstrap process. All
non-essential packages implicitly depend on the essential ones. dpkg
will refuse to remove essential packages from the system unless
special flags are used to override this.
</p>
</itemd></item>

<item><itemt>Source</itemt>
<itemd>
<p>
An URL to the source tarball. It should be a HTTP or FTP URL, but
Fink doesn't really care - it just passes the URL to wget. This field
supports a special URL scheme for mirrors:
<code>mirror:&lt;mirror-name&gt;:&lt;relative-path&gt;</code>. This will
look up the mirror setting for <i>mirror-name</i> in Fink's
configuration, append the <i>relative-path</i> part and use that as
the actual URL. Alternatively, using <code>custom</code> as the
<i>mirror-name</i> will cause Fink to use the <code>CustomMirror</code>
field.
</p>
<p>
Before the URL is used, percent expansion takes place.
The value <code>gnu</code> is a shorthand for
<code>mirror:gnu:%n/%n-%v.tar.gz</code>; <code>gnome</code> is a shorthand for
<code>mirror:gnome:stable/sources/%n/%n-%v.tar.gz</code>. The
default is <code>%n-%v.tar.gz</code> (i.e. a manual
download).
</p>
</itemd></item>

<item><itemt>CustomMirror</itemt>
<itemd>
<p>
A list of mirror sites. Each mirror site appears on a separate line,
in the following format: <code>&lt;location&gt;: &lt;url&gt;</code>.
<i>location</i> can be a continent code (e.g. <code>nam</code>), a
country code (e.g. <code>nam-us</code>), or anything else;
mirrors are tried in that order.
Example:
</p>
<codeblock>CustomMirror: &lt;&lt;
nam-US: ftp://ftp.fooquux.com/pub/bar
asi-JP: ftp://ftp.qiixbar.jp/pub/mirror/bar
eur-DE: ftp://ftp.barfoo.de/bar
Primary: ftp://ftp.barbarorg/pub/
&gt;&gt;</codeblock>
</itemd></item>

<item><itemt>SourceDirectory</itemt>
<itemd>
<p>
Must be used when the tarball expands to a single directory, but
the directory's name is different from the basename of the tarball.
Usually, a tarball named "foo-1.0.tar.gz" will produce a directory
named "foo-1.0". If it produces a directory with a different name,
specify it with this parameter. Percent expansion is performed on this
field.
</p>
</itemd></item>

<item><itemt>NoSourceDirectory</itemt>
<itemd>
<p>
Set this boolean parameter to a true value if the tarball does not
expand to a single directory. Usually, a tarball named "foo-1.0.tar.gz"
will produce a directory named "foo-1.0". If it just unpacks the files
to the current directory, use this parameter and set it to a boolean
true value.
</p>
</itemd></item>

<item><itemt>Source<i>N</i></itemt>
<itemd>
<p>
If a package consists of several tarballs, name them with these
additional fields, starting with N = 2. So, the first tarball (which
should be some kind of "main" tarball) goes into <code>Source</code>, the
second tarball in <code>Source2</code> and so on. The rules are the same
as for Source, only that the "gnu" and "gnome" shortcuts are not
expanded - that would be useless anyway.
</p>
</itemd></item>

<item><itemt>Source<i>N</i>ExtractDir</itemt>
<itemd>
<p>
Normally, an auxillary tarball will be extracted in the same
directory as the main tarball. If you need to extract it in a
specific subdirectory instead, use this field to specify
it. Source2ExtractDir corresponds to the Source2 tarball, as one would
expect. See ghostscript, vim and tetex for examples of usage.
</p>
</itemd></item>

<item><itemt>SourceRename</itemt>
<itemd>
<p>
This field can renames a source tar ball on the fly. This is useful
if for example the version of the source is encoded in the directory name on
the server, but the tar ball itself has the same name for all versions, e.g.
http://www.foobar.org/coolapp/1.2.3/source.tar.gz. To circumvent the problems
caused by this, you would then use something like
</p>
<codeblock>SourceRename: %n-%v.tar.gz</codeblock>
<p>
In the above example this would result in the tarball being stored under
/sw/src/coolapp-1.2.3.tar.gz as one would expect.
</p>
</itemd></item>

<item><itemt>Source<i>N</i>Rename</itemt>
<itemd>
<p>
This is just the same as the <code>SourceRename</code> field, except that it
is used to rename the Nth tarball as specified by the <code>Source<i>N</i></code>
field. See context or hyperref for examples of usage.
</p>
</itemd></item>

<item><itemt>UpdateConfigGuess</itemt>
<itemd>
<p>
A boolean value. If true, the files config.guess and config.sub
in the build directory will be replaced with versions that know about
Darwin. This happens in the patch phase and before the PatchScript
is run. <em>Only</em> use this when you know it is necessary,
i.e. when the configure script fails with a "unknown host"
message.
</p>
</itemd></item>

<item><itemt>UpdateConfigGuessInDirs</itemt>
<itemd>
<p>
<i>Introduced in a post-0.9.0 CVS version.</i>
A list of subdirectories.
This does the same as UpdateConfigGuess, but is useful for packages
that have outdated config.guess files in several directories
throughout the source tree.
Previously you had to copy/move the files there manually in the
PatchScript.
With this new field you can just list the directories.
Use <code>.</code> to update files in the build directory itself.
</p>
</itemd></item>

<item><itemt>UpdateLibtool</itemt>
<itemd>
<p>
A boolean value. If true, the files ltconfig and ltmain.sh in the
build directory will be replaced with versions that know about
Darwin. This happens in the patch phase and before the PatchScript
is run. <em>Only</em> use this when you know that the package needs
it. Some packages can be broken by overwriting the libtool scripts
with mismatching versions. See the <link
url="http://fink.sourceforge.net/doc/porting/libtool.php">libtool
page</link> for further information.
</p>
</itemd></item>

<item><itemt>UpdateLibtoolInDirs</itemt>
<itemd>
<p>
<i>Introduced in a post-0.9.0 CVS version.</i>
A list of subdirectories.
This does the same as UpdateLibtool, but is useful for packages
that have outdated libtool 1.3.x scripts in several directories
throughout the source tree.
Previously you had to copy/move the files there manually in the
PatchScript.
With this new field you can just list the directories.
Use <code>.</code> to update files in the build directory itself.
</p>
</itemd></item>

<item><itemt>UpdatePoMakefile</itemt>
<itemd>
<p>
A boolean value.
If true, the file <code>Makefile.in.in</code> in the subdirectory
<code>po</code> is replaced with a patched version.
This happens in the patch phase and before the PatchScript is run.
</p>
<p>
The patched version respects DESTDIR and makes sure that message
catalogs end up in <code>/sw/share/locale</code>, not
<code>/sw/lib/locale</code>.
Before using this field, make sure that you won't break the package
and that it's really required.
You can run <code>diff</code> to find the differences between the
packages's version and Fink's version (in
<code>/sw/lib/fink/update</code>).
</p>
</itemd></item>

<item><itemt>UpdatePOD</itemt>
<itemd>
<p>
<i>Introduced in fink 0.9.5.</i>
A boolean value, specific for perl module packages.
If true, this will add code to the install, postrm and postinst
scripts that maintains the .pod files provided by perl packages.
This includes adding and removing the .pod date from the central
<code>/sw/lib/perl5/darwin/perllocal.pod</code> file
</p>
</itemd></item>

<item><itemt>Patch</itemt>
<itemd>
<p>
The filename of a patch to be applied with <code>patch -p1
&lt;<i>patch-file</i></code>. This should be just a filename; the
appropriate path will be prepended automatically. Percent expansion is
performed on this field, so a typical value is simply
<code>%f.patch</code>. The patch is applied before the PatchScript
is run (if any).
</p>
</itemd></item>

<item><itemt>PatchScript</itemt>
<itemd>
<p>
A list of commands that are run in the patch phase. See the note
on scripts below. This is the place to put commands that patch or
otherwise modify the package. There is no default. Before the
commands are executed, percent expansion takes place (see last
section).
</p>
</itemd></item>

<item><itemt>ConfigureParams</itemt>
<itemd>
<p>
Additional parameters to pass to the configure script. (See
CompileScript for details.)
</p>
</itemd></item>

<item><itemt>CompileScript</itemt>
<itemd>
<p>
A list of commands that are run in the compile phase. See the note
on scripts below. This is the place to put commands that configure and
compile the package. Normally the default is:
</p>
<codeblock>./configure %c
make</codeblock>
<p>
This is appropriate for packages that use GNU autoconf.
For packages with of type perl (as specified via the Type field),
the default instead is:
</p>
<codeblock>perl Makefile.PL PREFIX=\%p INSTALLPRIVLIB=\%p/lib/perl5 \
 INSTALLARCHLIB=\%p/lib/perl5/darwin INSTALLSITELIB=\%p/lib/perl5 \
 INSTALLSITEARCH=\%p/lib/perl5/darwin INSTALLMAN1DIR=\%p/share/man/man1 \
 INSTALLMAN3DIR=\%p/share/man/man3
make
make test</codeblock>
<p>
Before the commands are executed, percent expansion takes place
(see previous section).
</p>
</itemd></item>

<item><itemt>InstallScript</itemt>
<itemd>
<p>
A list of commands that are run in the install phase. See the note
on scripts below. This is the place to put commands that copy all
necessary files to the stow directory for the package. Normally the
default is:
</p>
<codeblock>make install prefix=%i</codeblock>
<p>
The default is appropriate for packages that use GNU autoconf.
For packages with of type perl (as specified via the Type field),
the default instead is:
</p>
<codeblock>make install INSTALLPRIVLIB=\%i/lib/perl5 \
 INSTALLARCHLIB=\%i/lib/perl5/darwin INSTALLSITELIB=\%i/lib/perl5 \
 INSTALLSITEARCH=\%i/lib/perl5/darwin INSTALLMAN1DIR=\%i/share/man/man1 \
 INSTALLMAN3DIR=\%i/share/man/man3</codeblock>
<p>
If the package supports it, it is preferably to use <code>make install
DESTDIR=%d</code> instead. Before the commands are executed, percent
expansion takes place (see previous section).
</p>
</itemd></item>

<item><itemt>DocFiles</itemt>
<itemd>
<p>
This field provides a convenient way to install README or COPYING
files in the doc directory for the package,
<code>%p/share/doc/%n</code>.
The value is a space-separated list of files.
You can copy files from subdirectories of the build directory, but
they will end up in the doc directory itself, not in a subdirectory.
Shell wildcards are allowed.
It is also possible to rename single files on the fly by appending the
new name separated by a colon (:),
e.g. <code>libgimp/COPYING:COPYING.libgimp</code>.
This field works by appending appropriate <code>install</code>
commands to the InstallScript.
</p>
</itemd></item>

<item><itemt>Set<i>ENVVAR</i></itemt>
<itemd>
<p>
Causes certain environment variables to be set in the
compile and install phases. This can be used to pass compiler flags
etc. to configure scripts and Makefiles. Currently supported variables
are: CC, CFLAGS, CPP, CPPFLAGS, CXX, CXXFLAGS, LD, LDFLAGS, LIBS,
MAKE, MFLAGS. The value you specify is subject to the
percent expansion described in the last section. A common example:
</p>
<codeblock>SetCPPFLAGS: -no-cpp-precomp</codeblock>
<p>
The variables CPPFLAGS and LDFLAGS are special. They default to
<code>-I%p/include</code> and <code>-L%p/lib</code>,
respectively. If you specify a value for one of these, it will be
prepended to the default value.
</p>
</itemd></item>

<item><itemt>NoSet<i>ENVVAR</i></itemt>
<itemd>
<p>
When set to a true value, deactivates the default values for
CPPFLAGS and LDFLAGS mentioned above. That is, if you want LDFLAGS to
remain unset, specify <code>NoSetLDFLAGS: true</code> .
</p>
</itemd></item>


<item><itemt>PreInstScript, PostInstScript, PreRmScript, PostRmScript</itemt>
<itemd>
<p>
These fields specify pieces of shell scripts that will be called when
the package is installed, upgraded or removed.
Fink automatically adds a shell script header that calls 'set -e', so
any command that fails will result in instant termination of the
script.
Fink also adds an <code>exit 0</code> at the end.
To indicate an error, exit from the script with a non-zero exit code.
The first parameter (<code>$1</code>) is set to a value indicating
what action is being performed.
Some possible values are <code>install</code>, <code>upgrade</code>,
<code>remove</code> and <code>purge</code>.
Note that there are more values, used during error rollback or when
removing a package in favor of another one.
</p>
<p>
The scripts are called at the following times:
</p>
<ul>
<li>PreInstScript: When the package is installed for the first time
and before upgrading the package to this version.</li>
<li>PostInstScript: After unpacking and setting up the package.</li>
<li>PreRmScript: Before the package is removed or upgraded to a later
version.</li>
<li>PostRmScript: After the package was removed or upgraded to a later
version.</li>
</ul>
<p>
To make it more clear, an upgrade invokes both the ...Inst scripts of
the new version and the ...Rm scripts of the old version.
Details can be found in the Debian Policy Manual,
<link url="http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">Chapter 6</link>.
</p>
<p>
Percent expansion is performed on the scripts.
Commands can generally be called without giving a full path.
</p>
</itemd></item>

<item><itemt>ConfFiles</itemt>
<itemd>
<p>
A space-separated list of files that are user-modifiable configuration
files.
The files must be specified with an absolute path,
e.g. <code>%p/etc/foo.conf</code>.
The named files will receive special treatment by dpkg.
When a package is upgraded and the file has changed both on disk and
in the package, the user is asked which version to use and backups
of the file will be made.
When a package is "remove"d, the configuration files will remain on
disk.
Only a "purge" also removes the configuration files.
</p>
</itemd></item>

<item><itemt>InfoDocs</itemt>
<itemd>
<p>
Lists the names of Info documents that the package installs in
%p/share/info.
This will add appropriate code to the postinst and prerm scripts to
maintain the Info directory file, <code>dir</code>.
This feature is still in flux, more fields for finer control may be
added in the future.
</p>
</itemd></item>

<item><itemt>DaemonicFile</itemt>
<itemd>
<p>
Gives a service description for <code>daemonic</code>.
<code>daemonic</code> is used by Fink to create and remove
StartupItems for daemon processes (e.g. web servers).
The description will added to the package as a file named
<code>%p/etc/daemons/<i>name</i>.xml</code>, where <i>name</i> is
specified by the DaemonicName field and defaults to the package
name.
Percent expansion is performed on the contents of this field.
Note that you must add <code>daemonic</code> to the dependency list if
your package uses it.
</p>
</itemd></item>

<item><itemt>DaemonicName</itemt>
<itemd>
<p>
A name for the <code>daemonic</code> service description file.
See the description of DaemonicFile for details.
</p>
</itemd></item>


<item><itemt>Description</itemt>
<itemd>
<p>
A short description of the package (what is it?). This is a
one-line description that will be displayed in lists, so it must be
short and informative.  Keep it to around 30 to 50 chars. It is not
necessary to repeat the package name in this field - it will always
be displayed in proper context. Required field.
</p>
</itemd></item>

<item><itemt>DescDetail</itemt>
<itemd>
<p>
A more detailed description (what is it, what can I use it for?).
Multiple lines allowed.
</p>
</itemd></item>

<item><itemt>DescUsage</itemt>
<itemd>
<p>
This is for information that is needed to use the package (how do
I use it?). As in "run wmaker.inst once before using WindowMaker".
Multiple lines allowed.
</p>
</itemd></item>

<item><itemt>DescPackaging</itemt>
<itemd>
<p>
Notes about the packaging. Stuff like "patches the Makefile to put
everything in place" goes here. Multiple lines allowed.
</p>
</itemd></item>

<item><itemt>DescPort</itemt>
<itemd>
<p>
Notes that are specific to porting the package to Darwin. Stuff
like "config.guess and libtool scripts are updated, -no-cpp-precomp
is necessary" goes here. Multiple lines allowed.
</p>
</itemd></item>

<item><itemt>License</itemt>
<itemd>
<p>
This field gives the nature of the license under which the package is
distributed.
The value must be one of the values described in <xref
chapter="policy" section="license">Package Licenses</xref> earlier in
this document.
Additionally, this field must only be given if the package actually
complies to the packaging policy in these respects, i.e. a copy of the
license is installed in the doc directory for the package.
</p>
</itemd></item>

<item><itemt>Homepage</itemt>
<itemd>
<p>
The URL of the upstream home page of the package.
</p>
</itemd></item>


<item><itemt>Comment</itemt>
<itemd>
<p>
<em>Obsolete.</em> Was: General comments on the package.
</p>
</itemd></item>

<item><itemt>CommentPort</itemt>
<itemd>
<p>
<em>Obsolete.</em> Was: Comments on the package that are specific to the
Darwin port. Describe what special parameters or patches are
necessary, what doesn't work (yet), etc.
</p>
</itemd></item>

<item><itemt>CommentStow</itemt>
<itemd>
<p>
<em>Obsolete.</em> Was: Comments on the package that apply to using it
with stow. Describe special treatment necessary and potential
problems.
</p>
</itemd></item>

<item><itemt>UsesGettext</itemt>
<itemd>
<p>
<em>Obsolete.</em> gettext is now an essential package and
always available.
</p>
</itemd></item>

</itemtable>
</section>

<section name="scripts"><title>Scripts</title>

<p>The PatchScript, CompileScript and InstallScript fields allow you
to specify shell commands to be executed. This is sort of like a shell
script. However, the commands are executed via system(), one by one,
so you can't use constructs that span multiple lines. It also means
the <code>cd</code> commands only affect commands that are on the same
line. This may be fixed one day in the future.</p>
</section>

<section name="patches"><title>Patches</title>

<p>If your package needs a patch to compile on Darwin (or to work with
fink), name the patch with the full package name plus the extension
".patch" and put it in the same directory as the .info file. Specify
either one of these (they are equivalent):</p>
<codeblock>Patch: %f.patch</codeblock>
<codeblock>PatchScript: patch -p1 &lt;%a/%f.patch</codeblock>
<p>These two fields are not mutually-exclusive - you can use both, and
they will both be executed. In that case the PatchScript is executed
last.</p>
</section>


</chapter>


</document>
